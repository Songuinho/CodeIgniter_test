{"version":3,"file":"index.es5.js","sources":["src/base.js","src/decorators.js","src/tables/cmap.js","src/tables/head.js","src/tables/hhea.js","src/tables/hmtx.js","src/tables/maxp.js","src/encodings.js","src/tables/name.js","src/tables/OS2.js","src/tables/post.js","src/tables/cvt.js","src/tables/fpgm.js","src/tables/loca.js","src/tables/prep.js","src/tables/glyf.js","src/cff/CFFIndex.js","src/cff/CFFOperand.js","src/cff/CFFDict.js","src/cff/CFFPointer.js","src/cff/CFFPrivateDict.js","src/cff/CFFStandardStrings.js","src/cff/CFFEncodings.js","src/cff/CFFCharsets.js","src/tables/opentype.js","src/tables/variations.js","src/cff/CFFTop.js","src/cff/CFFFont.js","src/tables/VORG.js","src/tables/EBDT.js","src/tables/EBLC.js","src/tables/sbix.js","src/tables/COLR.js","src/tables/CPAL.js","src/tables/BASE.js","src/tables/GDEF.js","src/tables/GPOS.js","src/tables/GSUB.js","src/tables/JSTF.js","src/tables/HVAR.js","src/tables/DSIG.js","src/tables/gasp.js","src/tables/hdmx.js","src/tables/kern.js","src/tables/LTSH.js","src/tables/PCLT.js","src/tables/VDMX.js","src/tables/vhea.js","src/tables/vmtx.js","src/tables/avar.js","src/tables/aat.js","src/tables/bsln.js","src/tables/feat.js","src/tables/fvar.js","src/tables/gvar.js","src/tables/just.js","src/tables/morx.js","src/tables/opbd.js","src/tables/index.js","src/tables/directory.js","src/utils.js","src/CmapProcessor.js","src/layout/KernProcessor.js","src/layout/UnicodeLayoutEngine.js","src/glyph/BBox.js","src/layout/Script.js","src/layout/GlyphRun.js","src/layout/GlyphPosition.js","src/aat/AATFeatureMap.js","src/aat/AATLookupTable.js","src/aat/AATStateMachine.js","src/aat/AATMorxProcessor.js","src/aat/AATLayoutEngine.js","src/opentype/ShapingPlan.js","src/opentype/shapers/DefaultShaper.js","src/opentype/shapers/ArabicShaper.js","src/opentype/GlyphIterator.js","src/opentype/OTProcessor.js","src/opentype/GlyphInfo.js","src/opentype/shapers/HangulShaper.js","src/opentype/shapers/indic-data.js","src/opentype/shapers/IndicShaper.js","src/opentype/shapers/UniversalShaper.js","src/opentype/shapers/index.js","src/opentype/GSUBProcessor.js","src/opentype/GPOSProcessor.js","src/opentype/OTLayoutEngine.js","src/layout/LayoutEngine.js","src/glyph/Path.js","src/glyph/StandardNames.js","src/glyph/Glyph.js","src/glyph/TTFGlyph.js","src/glyph/CFFGlyph.js","src/glyph/SBIXGlyph.js","src/glyph/COLRGlyph.js","src/glyph/GlyphVariationProcessor.js","src/subset/Subset.js","src/glyph/TTFGlyphEncoder.js","src/subset/TTFSubset.js","src/subset/CFFSubset.js","src/TTFFont.js","src/tables/WOFFDirectory.js","src/WOFFFont.js","src/glyph/WOFF2Glyph.js","src/tables/WOFF2Directory.js","src/WOFF2Font.js","src/TrueTypeCollection.js","src/DFont.js","src/index.js"],"sourcesContent":["import r from '@foliojs-fork/restructure';\r\nconst fs = require('fs');\r\n\r\nvar fontkit = {};\r\nexport default fontkit;\r\n\r\nfontkit.logErrors = false;\r\n\r\nlet formats = [];\r\nfontkit.registerFormat = function(format) {\r\n  formats.push(format);\r\n};\r\n\r\nfontkit.openSync = function(filename, postscriptName) {\r\n  let buffer = fs.readFileSync(filename);\r\n  return fontkit.create(buffer, postscriptName);\r\n};\r\n\r\nfontkit.open = function(filename, postscriptName, callback) {\r\n  if (typeof postscriptName === 'function') {\r\n    callback = postscriptName;\r\n    postscriptName = null;\r\n  }\r\n\r\n  fs.readFile(filename, function(err, buffer) {\r\n    if (err) { return callback(err); }\r\n\r\n    try {\r\n      var font = fontkit.create(buffer, postscriptName);\r\n    } catch (e) {\r\n      return callback(e);\r\n    }\r\n\r\n    return callback(null, font);\r\n  });\r\n\r\n  return;\r\n};\r\n\r\nfontkit.create = function(buffer, postscriptName) {\r\n  for (let i = 0; i < formats.length; i++) {\r\n    let format = formats[i];\r\n    if (format.probe(buffer)) {\r\n      let font = new format(new r.DecodeStream(buffer));\r\n      if (postscriptName) {\r\n        return font.getFont(postscriptName);\r\n      }\r\n\r\n      return font;\r\n    }\r\n  }\r\n\r\n  throw new Error('Unknown font format');\r\n};\r\n\r\nfontkit.defaultLanguage = 'en';\r\nfontkit.setDefaultLanguage = function(lang = 'en') {\r\n  fontkit.defaultLanguage = lang;\r\n};","/**\r\n * This decorator caches the results of a getter or method such that\r\n * the results are lazily computed once, and then cached.\r\n * @private\r\n */\r\nexport function cache(target, key, descriptor) {\r\n  if (descriptor.get) {\r\n    let get = descriptor.get;\r\n    descriptor.get = function() {\r\n      let value = get.call(this);\r\n      Object.defineProperty(this, key, { value });\r\n      return value;\r\n    };\r\n  } else if (typeof descriptor.value === 'function') {\r\n    let fn = descriptor.value;\r\n\r\n    return {\r\n      get() {\r\n        let cache = new Map;\r\n        function memoized(...args) {\r\n          let key = args.length > 0 ? args[0] : 'value';\r\n          if (cache.has(key)) {\r\n            return cache.get(key);\r\n          }\r\n\r\n          let result = fn.apply(this, args);\r\n          cache.set(key, result);\r\n          return result;\r\n        };\r\n\r\n        Object.defineProperty(this, key, {value: memoized});\r\n        return memoized;\r\n      }\r\n    };\r\n  }\r\n}\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet SubHeader = new r.Struct({\r\n  firstCode:      r.uint16,\r\n  entryCount:     r.uint16,\r\n  idDelta:        r.int16,\r\n  idRangeOffset:  r.uint16\r\n});\r\n\r\nlet CmapGroup = new r.Struct({\r\n  startCharCode:  r.uint32,\r\n  endCharCode:    r.uint32,\r\n  glyphID:        r.uint32\r\n});\r\n\r\nlet UnicodeValueRange = new r.Struct({\r\n  startUnicodeValue:  r.uint24,\r\n  additionalCount:    r.uint8\r\n});\r\n\r\nlet UVSMapping = new r.Struct({\r\n  unicodeValue: r.uint24,\r\n  glyphID:      r.uint16\r\n});\r\n\r\nlet DefaultUVS = new r.Array(UnicodeValueRange, r.uint32);\r\nlet NonDefaultUVS = new r.Array(UVSMapping, r.uint32);\r\n\r\nlet VarSelectorRecord = new r.Struct({\r\n  varSelector:    r.uint24,\r\n  defaultUVS:     new r.Pointer(r.uint32, DefaultUVS, {type: 'parent'}),\r\n  nonDefaultUVS:  new r.Pointer(r.uint32, NonDefaultUVS, {type: 'parent'})\r\n});\r\n\r\nlet CmapSubtable = new r.VersionedStruct(r.uint16, {\r\n  0: { // Byte encoding\r\n    length:     r.uint16,   // Total table length in bytes (set to 262 for format 0)\r\n    language:   r.uint16,   // Language code for this encoding subtable, or zero if language-independent\r\n    codeMap:    new r.LazyArray(r.uint8, 256)\r\n  },\r\n\r\n  2: { // High-byte mapping (CJK)\r\n    length:           r.uint16,\r\n    language:         r.uint16,\r\n    subHeaderKeys:    new r.Array(r.uint16, 256),\r\n    subHeaderCount:   t => Math.max.apply(Math, t.subHeaderKeys),\r\n    subHeaders:       new r.LazyArray(SubHeader, 'subHeaderCount'),\r\n    glyphIndexArray:  new r.LazyArray(r.uint16, 'subHeaderCount')\r\n  },\r\n\r\n  4: { // Segment mapping to delta values\r\n    length:           r.uint16,              // Total table length in bytes\r\n    language:         r.uint16,              // Language code\r\n    segCountX2:       r.uint16,\r\n    segCount:         t => t.segCountX2 >> 1,\r\n    searchRange:      r.uint16,\r\n    entrySelector:    r.uint16,\r\n    rangeShift:       r.uint16,\r\n    endCode:          new r.LazyArray(r.uint16, 'segCount'),\r\n    reservedPad:      new r.Reserved(r.uint16),       // This value should be zero\r\n    startCode:        new r.LazyArray(r.uint16, 'segCount'),\r\n    idDelta:          new r.LazyArray(r.int16, 'segCount'),\r\n    idRangeOffset:    new r.LazyArray(r.uint16, 'segCount'),\r\n    glyphIndexArray:  new r.LazyArray(r.uint16, t => (t.length - t._currentOffset) / 2)\r\n  },\r\n\r\n  6: { // Trimmed table\r\n    length:         r.uint16,\r\n    language:       r.uint16,\r\n    firstCode:      r.uint16,\r\n    entryCount:     r.uint16,\r\n    glyphIndices:   new r.LazyArray(r.uint16, 'entryCount')\r\n  },\r\n\r\n  8: { // mixed 16-bit and 32-bit coverage\r\n    reserved: new r.Reserved(r.uint16),\r\n    length:   r.uint32,\r\n    language: r.uint16,\r\n    is32:     new r.LazyArray(r.uint8, 8192),\r\n    nGroups:  r.uint32,\r\n    groups:   new r.LazyArray(CmapGroup, 'nGroups')\r\n  },\r\n\r\n  10: { // Trimmed Array\r\n    reserved:       new r.Reserved(r.uint16),\r\n    length:         r.uint32,\r\n    language:       r.uint32,\r\n    firstCode:      r.uint32,\r\n    entryCount:     r.uint32,\r\n    glyphIndices:   new r.LazyArray(r.uint16, 'numChars')\r\n  },\r\n\r\n  12: { // Segmented coverage\r\n    reserved: new r.Reserved(r.uint16),\r\n    length:   r.uint32,\r\n    language: r.uint32,\r\n    nGroups:  r.uint32,\r\n    groups:   new r.LazyArray(CmapGroup, 'nGroups')\r\n  },\r\n\r\n  13: { // Many-to-one range mappings (same as 12 except for group.startGlyphID)\r\n    reserved: new r.Reserved(r.uint16),\r\n    length:   r.uint32,\r\n    language: r.uint32,\r\n    nGroups:  r.uint32,\r\n    groups:   new r.LazyArray(CmapGroup, 'nGroups')\r\n  },\r\n\r\n  14: { // Unicode Variation Sequences\r\n    length:       r.uint32,\r\n    numRecords:   r.uint32,\r\n    varSelectors: new r.LazyArray(VarSelectorRecord, 'numRecords')\r\n  }\r\n});\r\n\r\nlet CmapEntry = new r.Struct({\r\n  platformID:  r.uint16,  // Platform identifier\r\n  encodingID:  r.uint16,  // Platform-specific encoding identifier\r\n  table:       new r.Pointer(r.uint32, CmapSubtable, {type: 'parent', lazy: true})\r\n});\r\n\r\n// character to glyph mapping\r\nexport default new r.Struct({\r\n  version:      r.uint16,\r\n  numSubtables: r.uint16,\r\n  tables:       new r.Array(CmapEntry, 'numSubtables')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// font header\r\nexport default new r.Struct({\r\n  version:            r.int32,                   // 0x00010000 (version 1.0)\r\n  revision:           r.int32,                   // set by font manufacturer\r\n  checkSumAdjustment: r.uint32,\r\n  magicNumber:        r.uint32,                  // set to 0x5F0F3CF5\r\n  flags:              r.uint16,\r\n  unitsPerEm:         r.uint16,                  // range from 64 to 16384\r\n  created:            new r.Array(r.int32, 2),\r\n  modified:           new r.Array(r.int32, 2),\r\n  xMin:               r.int16,                   // for all glyph bounding boxes\r\n  yMin:               r.int16,                   // for all glyph bounding boxes\r\n  xMax:               r.int16,                   // for all glyph bounding boxes\r\n  yMax:               r.int16,                   // for all glyph bounding boxes\r\n  macStyle:           new r.Bitfield(r.uint16, [\r\n    'bold', 'italic', 'underline', 'outline',\r\n    'shadow', 'condensed', 'extended'\r\n  ]),\r\n  lowestRecPPEM:      r.uint16,                  // smallest readable size in pixels\r\n  fontDirectionHint:  r.int16,\r\n  indexToLocFormat:   r.int16,                   // 0 for short offsets, 1 for long\r\n  glyphDataFormat:    r.int16                    // 0 for current format\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// horizontal header\r\nexport default new r.Struct({\r\n  version:              r.int32,\r\n  ascent:               r.int16,   // Distance from baseline of highest ascender\r\n  descent:              r.int16,   // Distance from baseline of lowest descender\r\n  lineGap:              r.int16,   // Typographic line gap\r\n  advanceWidthMax:      r.uint16,  // Maximum advance width value in 'hmtx' table\r\n  minLeftSideBearing:   r.int16,   // Maximum advance width value in 'hmtx' table\r\n  minRightSideBearing:  r.int16,   // Minimum right sidebearing value\r\n  xMaxExtent:           r.int16,\r\n  caretSlopeRise:       r.int16,   // Used to calculate the slope of the cursor (rise/run); 1 for vertical\r\n  caretSlopeRun:        r.int16,   // 0 for vertical\r\n  caretOffset:          r.int16,   // Set to 0 for non-slanted fonts\r\n  reserved:             new r.Reserved(r.int16, 4),\r\n  metricDataFormat:     r.int16,   // 0 for current format\r\n  numberOfMetrics:      r.uint16   // Number of advance widths in 'hmtx' table\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet HmtxEntry = new r.Struct({\r\n  advance: r.uint16,\r\n  bearing: r.int16\r\n});\r\n\r\nexport default new r.Struct({\r\n  metrics:    new r.LazyArray(HmtxEntry, t => t.parent.hhea.numberOfMetrics),\r\n  bearings:   new r.LazyArray(r.int16, t => t.parent.maxp.numGlyphs - t.parent.hhea.numberOfMetrics)\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// maxiumum profile\r\nexport default new r.Struct({\r\n  version:                r.int32,\r\n  numGlyphs:              r.uint16,  // The number of glyphs in the font\r\n  maxPoints:              r.uint16,  // Maximum points in a non-composite glyph\r\n  maxContours:            r.uint16,  // Maximum contours in a non-composite glyph\r\n  maxComponentPoints:     r.uint16,  // Maximum points in a composite glyph\r\n  maxComponentContours:   r.uint16,  // Maximum contours in a composite glyph\r\n  maxZones:               r.uint16,  // 1 if instructions do not use the twilight zone, 2 otherwise\r\n  maxTwilightPoints:      r.uint16,  // Maximum points used in Z0\r\n  maxStorage:             r.uint16,  // Number of Storage Area locations\r\n  maxFunctionDefs:        r.uint16,  // Number of FDEFs\r\n  maxInstructionDefs:     r.uint16,  // Number of IDEFs\r\n  maxStackElements:       r.uint16,  // Maximum stack depth\r\n  maxSizeOfInstructions:  r.uint16,  // Maximum byte count for glyph instructions\r\n  maxComponentElements:   r.uint16,  // Maximum number of components referenced at “top level” for any composite glyph\r\n  maxComponentDepth:      r.uint16   // Maximum levels of recursion; 1 for simple components\r\n});\r\n","/**\r\n * Gets an encoding name from platform, encoding, and language ids.\r\n * Returned encoding names can be used in iconv-lite to decode text.\r\n */\r\nexport function getEncoding(platformID, encodingID, languageID = 0) {\r\n  if (platformID === 1 && MAC_LANGUAGE_ENCODINGS[languageID]) {\r\n    return MAC_LANGUAGE_ENCODINGS[languageID];\r\n  }\r\n  \r\n  return ENCODINGS[platformID][encodingID];\r\n}\r\n\r\n// Map of platform ids to encoding ids.\r\nexport const ENCODINGS = [\r\n  // unicode\r\n  ['utf16be', 'utf16be', 'utf16be', 'utf16be', 'utf16be', 'utf16be'],\r\n  \r\n  // macintosh\r\n  // Mappings available at http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/\r\n  // 0\tRoman                 17\tMalayalam\r\n  // 1\tJapanese\t            18\tSinhalese\r\n  // 2\tTraditional Chinese\t  19\tBurmese\r\n  // 3\tKorean\t              20\tKhmer\r\n  // 4\tArabic\t              21\tThai\r\n  // 5\tHebrew\t              22\tLaotian\r\n  // 6\tGreek\t                23\tGeorgian\r\n  // 7\tRussian\t              24\tArmenian\r\n  // 8\tRSymbol\t              25\tSimplified Chinese\r\n  // 9\tDevanagari\t          26\tTibetan\r\n  // 10\tGurmukhi\t            27\tMongolian\r\n  // 11\tGujarati\t            28\tGeez\r\n  // 12\tOriya\t                29\tSlavic\r\n  // 13\tBengali\t              30\tVietnamese\r\n  // 14\tTamil\t                31\tSindhi\r\n  // 15\tTelugu\t              32\t(Uninterpreted)\r\n  // 16\tKannada\r\n  ['macroman', 'shift-jis', 'big5', 'euc-kr', 'iso-8859-6', 'iso-8859-8',\r\n   'macgreek', 'maccyrillic', 'symbol', 'Devanagari', 'Gurmukhi', 'Gujarati',\r\n   'Oriya', 'Bengali', 'Tamil', 'Telugu', 'Kannada', 'Malayalam', 'Sinhalese',\r\n   'Burmese', 'Khmer', 'macthai', 'Laotian', 'Georgian', 'Armenian', 'gb-2312-80', \r\n   'Tibetan', 'Mongolian', 'Geez', 'maccenteuro', 'Vietnamese', 'Sindhi'],\r\n  \r\n  // ISO (deprecated)\r\n  ['ascii'],\r\n  \r\n  // windows\r\n  // Docs here: http://msdn.microsoft.com/en-us/library/system.text.encoding(v=vs.110).aspx\r\n  ['symbol', 'utf16be', 'shift-jis', 'gb18030', 'big5', 'wansung', 'johab', null, null, null, 'utf16be']\r\n];\r\n\r\n// Overrides for Mac scripts by language id.\r\n// See http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\r\nexport const MAC_LANGUAGE_ENCODINGS = {\r\n  15: 'maciceland',\r\n  17: 'macturkish',\r\n  18: 'maccroatian',\r\n  24: 'maccenteuro',\r\n  25: 'maccenteuro',\r\n  26: 'maccenteuro',\r\n  27: 'maccenteuro',\r\n  28: 'maccenteuro',\r\n  30: 'maciceland',\r\n  37: 'macromania',\r\n  38: 'maccenteuro',\r\n  39: 'maccenteuro',\r\n  40: 'maccenteuro',\r\n  143: 'macinuit', // Unsupported by iconv-lite\r\n  146: 'macgaelic' // Unsupported by iconv-lite\r\n};\r\n\r\n// Map of platform ids to BCP-47 language codes.\r\nexport const LANGUAGES = [\r\n  // unicode\r\n  [],\r\n  \r\n  { // macintosh\r\n    0: 'en',        30: 'fo',       60: 'ks',       90: 'rw',\r\n    1: 'fr',        31: 'fa',       61: 'ku',       91: 'rn',\r\n    2: 'de',        32: 'ru',       62: 'sd',       92: 'ny',\r\n    3: 'it',        33: 'zh',       63: 'bo',       93: 'mg',\r\n    4: 'nl',        34: 'nl-BE',    64: 'ne',       94: 'eo',\r\n    5: 'sv',        35: 'ga',       65: 'sa',       128: 'cy',\r\n    6: 'es',        36: 'sq',       66: 'mr',       129: 'eu',\r\n    7: 'da',        37: 'ro',       67: 'bn',       130: 'ca',\r\n    8: 'pt',        38: 'cz',       68: 'as',       131: 'la',\r\n    9: 'no',        39: 'sk',       69: 'gu',       132: 'qu',\r\n    10: 'he',       40: 'si',       70: 'pa',       133: 'gn',\r\n    11: 'ja',       41: 'yi',       71: 'or',       134: 'ay',\r\n    12: 'ar',       42: 'sr',       72: 'ml',       135: 'tt',\r\n    13: 'fi',       43: 'mk',       73: 'kn',       136: 'ug',\r\n    14: 'el',       44: 'bg',       74: 'ta',       137: 'dz',\r\n    15: 'is',       45: 'uk',       75: 'te',       138: 'jv',\r\n    16: 'mt',       46: 'be',       76: 'si',       139: 'su',\r\n    17: 'tr',       47: 'uz',       77: 'my',       140: 'gl',\r\n    18: 'hr',       48: 'kk',       78: 'km',       141: 'af',\r\n    19: 'zh-Hant',  49: 'az-Cyrl',  79: 'lo',       142: 'br',\r\n    20: 'ur',       50: 'az-Arab',  80: 'vi',       143: 'iu',\r\n    21: 'hi',       51: 'hy',       81: 'id',       144: 'gd',\r\n    22: 'th',       52: 'ka',       82: 'tl',       145: 'gv',\r\n    23: 'ko',       53: 'mo',       83: 'ms',       146: 'ga',\r\n    24: 'lt',       54: 'ky',       84: 'ms-Arab',  147: 'to',\r\n    25: 'pl',       55: 'tg',       85: 'am',       148: 'el-polyton',\r\n    26: 'hu',       56: 'tk',       86: 'ti',       149: 'kl',\r\n    27: 'es',       57: 'mn-CN',    87: 'om',       150: 'az',\r\n    28: 'lv',       58: 'mn',       88: 'so',       151: 'nn',\r\n    29: 'se',       59: 'ps',       89: 'sw',\r\n  },\r\n  \r\n  // ISO (deprecated)\r\n  [],\r\n  \r\n  { // windows                                        \r\n    0x0436: 'af',       0x4009: 'en-IN',    0x0487: 'rw',          0x0432: 'tn',       \r\n    0x041C: 'sq',       0x1809: 'en-IE',    0x0441: 'sw',          0x045B: 'si',          \r\n    0x0484: 'gsw',      0x2009: 'en-JM',    0x0457: 'kok',         0x041B: 'sk',          \r\n    0x045E: 'am',       0x4409: 'en-MY',    0x0412: 'ko',          0x0424: 'sl',          \r\n    0x1401: 'ar-DZ',    0x1409: 'en-NZ',    0x0440: 'ky',          0x2C0A: 'es-AR',       \r\n    0x3C01: 'ar-BH',    0x3409: 'en-PH',    0x0454: 'lo',          0x400A: 'es-BO',       \r\n    0x0C01: 'ar',       0x4809: 'en-SG',    0x0426: 'lv',          0x340A: 'es-CL',       \r\n    0x0801: 'ar-IQ',    0x1C09: 'en-ZA',    0x0427: 'lt',          0x240A: 'es-CO',       \r\n    0x2C01: 'ar-JO',    0x2C09: 'en-TT',    0x082E: 'dsb',         0x140A: 'es-CR',       \r\n    0x3401: 'ar-KW',    0x0809: 'en-GB',    0x046E: 'lb',          0x1C0A: 'es-DO',       \r\n    0x3001: 'ar-LB',    0x0409: 'en',       0x042F: 'mk',          0x300A: 'es-EC',       \r\n    0x1001: 'ar-LY',    0x3009: 'en-ZW',    0x083E: 'ms-BN',       0x440A: 'es-SV',       \r\n    0x1801: 'ary',      0x0425: 'et',       0x043E: 'ms',          0x100A: 'es-GT',       \r\n    0x2001: 'ar-OM',    0x0438: 'fo',       0x044C: 'ml',          0x480A: 'es-HN',       \r\n    0x4001: 'ar-QA',    0x0464: 'fil',      0x043A: 'mt',          0x080A: 'es-MX',       \r\n    0x0401: 'ar-SA',    0x040B: 'fi',       0x0481: 'mi',          0x4C0A: 'es-NI',       \r\n    0x2801: 'ar-SY',    0x080C: 'fr-BE',    0x047A: 'arn',         0x180A: 'es-PA',       \r\n    0x1C01: 'aeb',      0x0C0C: 'fr-CA',    0x044E: 'mr',          0x3C0A: 'es-PY',       \r\n    0x3801: 'ar-AE',    0x040C: 'fr',       0x047C: 'moh',         0x280A: 'es-PE',       \r\n    0x2401: 'ar-YE',    0x140C: 'fr-LU',    0x0450: 'mn',          0x500A: 'es-PR',       \r\n    0x042B: 'hy',       0x180C: 'fr-MC',    0x0850: 'mn-CN',       0x0C0A: 'es',          \r\n    0x044D: 'as',       0x100C: 'fr-CH',    0x0461: 'ne',          0x040A: 'es',          \r\n    0x082C: 'az-Cyrl',  0x0462: 'fy',       0x0414: 'nb',          0x540A: 'es-US',       \r\n    0x042C: 'az',       0x0456: 'gl',       0x0814: 'nn',          0x380A: 'es-UY',     \r\n    0x046D: 'ba',       0x0437: 'ka',       0x0482: 'oc',          0x200A: 'es-VE',       \r\n    0x042D: 'eu',       0x0C07: 'de-AT',    0x0448: 'or',          0x081D: 'sv-FI',       \r\n    0x0423: 'be',       0x0407: 'de',       0x0463: 'ps',          0x041D: 'sv',          \r\n    0x0845: 'bn',       0x1407: 'de-LI',    0x0415: 'pl',          0x045A: 'syr',         \r\n    0x0445: 'bn-IN',    0x1007: 'de-LU',    0x0416: 'pt',          0x0428: 'tg',          \r\n    0x201A: 'bs-Cyrl',  0x0807: 'de-CH',    0x0816: 'pt-PT',       0x085F: 'tzm',         \r\n    0x141A: 'bs',       0x0408: 'el',       0x0446: 'pa',          0x0449: 'ta',          \r\n    0x047E: 'br',       0x046F: 'kl',       0x046B: 'qu-BO',       0x0444: 'tt',          \r\n    0x0402: 'bg',       0x0447: 'gu',       0x086B: 'qu-EC',       0x044A: 'te',          \r\n    0x0403: 'ca',       0x0468: 'ha',       0x0C6B: 'qu',          0x041E: 'th',          \r\n    0x0C04: 'zh-HK',    0x040D: 'he',       0x0418: 'ro',          0x0451: 'bo',          \r\n    0x1404: 'zh-MO',    0x0439: 'hi',       0x0417: 'rm',          0x041F: 'tr',          \r\n    0x0804: 'zh',       0x040E: 'hu',       0x0419: 'ru',          0x0442: 'tk',          \r\n    0x1004: 'zh-SG',    0x040F: 'is',       0x243B: 'smn',         0x0480: 'ug',          \r\n    0x0404: 'zh-TW',    0x0470: 'ig',       0x103B: 'smj-NO',      0x0422: 'uk',          \r\n    0x0483: 'co',       0x0421: 'id',       0x143B: 'smj',         0x042E: 'hsb',         \r\n    0x041A: 'hr',       0x045D: 'iu',       0x0C3B: 'se-FI',       0x0420: 'ur',          \r\n    0x101A: 'hr-BA',    0x085D: 'iu-Latn',  0x043B: 'se',          0x0843: 'uz-Cyrl',     \r\n    0x0405: 'cs',       0x083C: 'ga',       0x083B: 'se-SE',       0x0443: 'uz',          \r\n    0x0406: 'da',       0x0434: 'xh',       0x203B: 'sms',         0x042A: 'vi',          \r\n    0x048C: 'prs',      0x0435: 'zu',       0x183B: 'sma-NO',      0x0452: 'cy',          \r\n    0x0465: 'dv',       0x0410: 'it',       0x1C3B: 'sms',         0x0488: 'wo',          \r\n    0x0813: 'nl-BE',    0x0810: 'it-CH',    0x044F: 'sa',          0x0485: 'sah',         \r\n    0x0413: 'nl',       0x0411: 'ja',       0x1C1A: 'sr-Cyrl-BA',  0x0478: 'ii',          \r\n    0x0C09: 'en-AU',    0x044B: 'kn',       0x0C1A: 'sr',          0x046A: 'yo',           \r\n    0x2809: 'en-BZ',    0x043F: 'kk',       0x181A: 'sr-Latn-BA',  \r\n    0x1009: 'en-CA',    0x0453: 'km',       0x081A: 'sr-Latn',     \r\n    0x2409: 'en-029',   0x0486: 'quc',      0x046C: 'nso',         \r\n  }\r\n];\r\n","import r from '@foliojs-fork/restructure';\r\nimport {getEncoding, LANGUAGES} from '../encodings';\r\n\r\nlet NameRecord = new r.Struct({\r\n  platformID: r.uint16,\r\n  encodingID: r.uint16,\r\n  languageID: r.uint16,\r\n  nameID:     r.uint16,\r\n  length:     r.uint16,\r\n  string:     new r.Pointer(r.uint16,\r\n    new r.String('length', t => getEncoding(t.platformID, t.encodingID, t.languageID)),\r\n    { type: 'parent', relativeTo: ctx => ctx.parent.stringOffset, allowNull: false }\r\n  )\r\n});\r\n\r\nlet LangTagRecord = new r.Struct({\r\n  length:  r.uint16,\r\n  tag:     new r.Pointer(r.uint16, new r.String('length', 'utf16be'), {type: 'parent', relativeTo: ctx => ctx.stringOffset})\r\n});\r\n\r\nvar NameTable = new r.VersionedStruct(r.uint16, {\r\n  0: {\r\n    count:          r.uint16,\r\n    stringOffset:   r.uint16,\r\n    records:        new r.Array(NameRecord, 'count')\r\n  },\r\n  1: {\r\n    count:          r.uint16,\r\n    stringOffset:   r.uint16,\r\n    records:        new r.Array(NameRecord, 'count'),\r\n    langTagCount:   r.uint16,\r\n    langTags:       new r.Array(LangTagRecord, 'langTagCount')\r\n  }\r\n});\r\n\r\nexport default NameTable;\r\n\r\nconst NAMES = [\r\n  'copyright',\r\n  'fontFamily',\r\n  'fontSubfamily',\r\n  'uniqueSubfamily',\r\n  'fullName',\r\n  'version',\r\n  'postscriptName', // Note: A font may have only one PostScript name and that name must be ASCII.\r\n  'trademark',\r\n  'manufacturer',\r\n  'designer',\r\n  'description',\r\n  'vendorURL',\r\n  'designerURL',\r\n  'license',\r\n  'licenseURL',\r\n  null, // reserved\r\n  'preferredFamily',\r\n  'preferredSubfamily',\r\n  'compatibleFull',\r\n  'sampleText',\r\n  'postscriptCIDFontName',\r\n  'wwsFamilyName',\r\n  'wwsSubfamilyName'\r\n];\r\n\r\nNameTable.process = function(stream) {\r\n  var records = {};\r\n  for (let record of this.records) {\r\n    // find out what language this is for\r\n    let language = LANGUAGES[record.platformID][record.languageID];\r\n\r\n    if (language == null && this.langTags != null && record.languageID >= 0x8000) {\r\n      language = this.langTags[record.languageID - 0x8000].tag;\r\n    }\r\n\r\n    if (language == null) {\r\n      language = record.platformID + '-' + record.languageID;\r\n    }\r\n\r\n    // if the nameID is >= 256, it is a font feature record (AAT)\r\n    let key = record.nameID >= 256 ? 'fontFeatures' : (NAMES[record.nameID] || record.nameID);\r\n    if (records[key] == null) {\r\n      records[key] = {};\r\n    }\r\n\r\n    let obj = records[key];\r\n    if (record.nameID >= 256) {\r\n      obj = obj[record.nameID] || (obj[record.nameID] = {});\r\n    }\r\n\r\n    if (typeof record.string === 'string' || typeof obj[language] !== 'string') {\r\n      obj[language] = record.string;\r\n    }\r\n  }\r\n\r\n  this.records = records;\r\n};\r\n\r\nNameTable.preEncode = function() {\r\n  if (Array.isArray(this.records)) return;\r\n  this.version = 0;\r\n\r\n  let records = [];\r\n  for (let key in this.records) {\r\n    let val = this.records[key];\r\n    if (key === 'fontFeatures') continue;\r\n\r\n    records.push({\r\n      platformID: 3,\r\n      encodingID: 1,\r\n      languageID: 0x409,\r\n      nameID: NAMES.indexOf(key),\r\n      length: Buffer.byteLength(val.en, 'utf16le'),\r\n      string: val.en\r\n    });\r\n\r\n    if (key === 'postscriptName') {\r\n      records.push({\r\n        platformID: 1,\r\n        encodingID: 0,\r\n        languageID: 0,\r\n        nameID: NAMES.indexOf(key),\r\n        length: val.en.length,\r\n        string: val.en\r\n      });\r\n    }\r\n  }\r\n\r\n  this.records = records;\r\n  this.count = records.length;\r\n  this.stringOffset = NameTable.size(this, null, false);\r\n};\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nvar OS2 = new r.VersionedStruct(r.uint16, {\r\n  header: {\r\n    xAvgCharWidth:          r.int16,   // average weighted advance width of lower case letters and space\r\n    usWeightClass:          r.uint16,  // visual weight of stroke in glyphs\r\n    usWidthClass:           r.uint16,  // relative change from the normal aspect ratio (width to height ratio)\r\n    fsType:                 new r.Bitfield(r.uint16, [ // Indicates font embedding licensing rights\r\n      null, 'noEmbedding', 'viewOnly', 'editable', null,\r\n      null, null, null, 'noSubsetting', 'bitmapOnly'\r\n    ]),\r\n    ySubscriptXSize:        r.int16,   // recommended horizontal size in pixels for subscripts\r\n    ySubscriptYSize:        r.int16,   // recommended vertical size in pixels for subscripts\r\n    ySubscriptXOffset:      r.int16,   // recommended horizontal offset for subscripts\r\n    ySubscriptYOffset:      r.int16,   // recommended vertical offset form the baseline for subscripts\r\n    ySuperscriptXSize:      r.int16,   // recommended horizontal size in pixels for superscripts\r\n    ySuperscriptYSize:      r.int16,   // recommended vertical size in pixels for superscripts\r\n    ySuperscriptXOffset:    r.int16,   // recommended horizontal offset for superscripts\r\n    ySuperscriptYOffset:    r.int16,   // recommended vertical offset from the baseline for superscripts\r\n    yStrikeoutSize:         r.int16,   // width of the strikeout stroke\r\n    yStrikeoutPosition:     r.int16,   // position of the strikeout stroke relative to the baseline\r\n    sFamilyClass:           r.int16,   // classification of font-family design\r\n    panose:                 new r.Array(r.uint8, 10),   // describe the visual characteristics of a given typeface\r\n    ulCharRange:            new r.Array(r.uint32, 4),\r\n    vendorID:               new r.String(4),          // four character identifier for the font vendor\r\n    fsSelection:            new r.Bitfield(r.uint16, [  // bit field containing information about the font\r\n      'italic', 'underscore', 'negative', 'outlined', 'strikeout',\r\n      'bold', 'regular', 'useTypoMetrics', 'wws', 'oblique'\r\n    ]),\r\n    usFirstCharIndex:       r.uint16,  // The minimum Unicode index in this font\r\n    usLastCharIndex:        r.uint16   // The maximum Unicode index in this font\r\n  },\r\n\r\n  // The Apple version of this table ends here, but the Microsoft one continues on...\r\n  0: {},\r\n\r\n  1: {\r\n    typoAscender:       r.int16,\r\n    typoDescender:      r.int16,\r\n    typoLineGap:        r.int16,\r\n    winAscent:          r.uint16,\r\n    winDescent:         r.uint16,\r\n    codePageRange:      new r.Array(r.uint32, 2)\r\n  },\r\n\r\n  2: {\r\n    // these should be common with version 1 somehow\r\n    typoAscender:       r.int16,\r\n    typoDescender:      r.int16,\r\n    typoLineGap:        r.int16,\r\n    winAscent:          r.uint16,\r\n    winDescent:         r.uint16,\r\n    codePageRange:      new r.Array(r.uint32, 2),\r\n\r\n    xHeight:            r.int16,\r\n    capHeight:          r.int16,\r\n    defaultChar:        r.uint16,\r\n    breakChar:          r.uint16,\r\n    maxContent:         r.uint16\r\n  },\r\n\r\n  5: {\r\n    typoAscender:       r.int16,\r\n    typoDescender:      r.int16,\r\n    typoLineGap:        r.int16,\r\n    winAscent:          r.uint16,\r\n    winDescent:         r.uint16,\r\n    codePageRange:      new r.Array(r.uint32, 2),\r\n\r\n    xHeight:            r.int16,\r\n    capHeight:          r.int16,\r\n    defaultChar:        r.uint16,\r\n    breakChar:          r.uint16,\r\n    maxContent:         r.uint16,\r\n\r\n    usLowerOpticalPointSize: r.uint16,\r\n    usUpperOpticalPointSize: r.uint16\r\n  }\r\n});\r\n\r\nlet versions = OS2.versions;\r\nversions[3] = versions[4] = versions[2];\r\n\r\nexport default OS2;\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// PostScript information\r\nexport default new r.VersionedStruct(r.fixed32, {\r\n  header: { // these fields exist at the top of all versions\r\n    italicAngle:        r.fixed32, // Italic angle in counter-clockwise degrees from the vertical.\r\n    underlinePosition:  r.int16,   // Suggested distance of the top of the underline from the baseline\r\n    underlineThickness: r.int16,   // Suggested values for the underline thickness\r\n    isFixedPitch:       r.uint32,  // Whether the font is monospaced\r\n    minMemType42:       r.uint32,  // Minimum memory usage when a TrueType font is downloaded as a Type 42 font\r\n    maxMemType42:       r.uint32,  // Maximum memory usage when a TrueType font is downloaded as a Type 42 font\r\n    minMemType1:        r.uint32,  // Minimum memory usage when a TrueType font is downloaded as a Type 1 font\r\n    maxMemType1:        r.uint32   // Maximum memory usage when a TrueType font is downloaded as a Type 1 font\r\n  },\r\n\r\n  1: {}, // version 1 has no additional fields\r\n\r\n  2: {\r\n    numberOfGlyphs: r.uint16,\r\n    glyphNameIndex: new r.Array(r.uint16, 'numberOfGlyphs'),\r\n    names:          new r.Array(new r.String(r.uint8))\r\n  },\r\n\r\n  2.5: {\r\n    numberOfGlyphs: r.uint16,\r\n    offsets:        new r.Array(r.uint8, 'numberOfGlyphs')\r\n  },\r\n\r\n  3: {}, // version 3 has no additional fields\r\n\r\n  4: {\r\n    map: new r.Array(r.uint32, t => t.parent.maxp.numGlyphs)\r\n  }\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// An array of predefined values accessible by instructions\r\nexport default new r.Struct({\r\n  controlValues: new r.Array(r.int16)\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// A list of instructions that are executed once when a font is first used.\r\n// These instructions are known as the font program. The main use of this table\r\n// is for the definition of functions that are used in many different glyph programs.\r\nexport default new r.Struct({\r\n  instructions: new r.Array(r.uint8)\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet loca = new r.VersionedStruct('head.indexToLocFormat', {\r\n  0: {\r\n    offsets: new r.Array(r.uint16)\r\n  },\r\n  1: {\r\n    offsets: new r.Array(r.uint32)\r\n  }\r\n});\r\n\r\nloca.process = function() {\r\n  if (this.version === 0) {\r\n    for (let i = 0; i < this.offsets.length; i++) {\r\n      this.offsets[i] <<= 1;\r\n    }\r\n  }\r\n};\r\n\r\nloca.preEncode = function() {\r\n  if (this.version === 0) {\r\n    for (let i = 0; i < this.offsets.length; i++) {\r\n      this.offsets[i] >>>= 1;\r\n    }\r\n  }\r\n};\r\n\r\nexport default loca;\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// Set of instructions executed whenever the point size or font transformation change\r\nexport default new r.Struct({\r\n  controlValueProgram: new r.Array(r.uint8)\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// only used for encoding\r\nexport default new r.Array(new r.Buffer);\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nexport default class CFFIndex {\r\n  constructor(type) {\r\n    this.type = type;\r\n  }\r\n\r\n  getCFFVersion(ctx) {\r\n    while (ctx && !ctx.hdrSize) {\r\n      ctx = ctx.parent;\r\n    }\r\n\r\n    return ctx ? ctx.version : -1;\r\n  }\r\n\r\n  decode(stream, parent) {\r\n    let version = this.getCFFVersion(parent);\r\n    let count = version >= 2\r\n      ? stream.readUInt32BE()\r\n      : stream.readUInt16BE();\r\n\r\n    if (count === 0) {\r\n      return [];\r\n    }\r\n\r\n    let offSize = stream.readUInt8();\r\n    let offsetType;\r\n    if (offSize === 1) {\r\n      offsetType = r.uint8;\r\n    } else if (offSize === 2) {\r\n      offsetType = r.uint16;\r\n    } else if (offSize === 3) {\r\n      offsetType = r.uint24;\r\n    } else if (offSize === 4) {\r\n      offsetType = r.uint32;\r\n    } else {\r\n      throw new Error(`Bad offset size in CFFIndex: ${offSize} ${stream.pos}`);\r\n    }\r\n\r\n    let ret = [];\r\n    let startPos = stream.pos + ((count + 1) * offSize) - 1;\r\n\r\n    let start = offsetType.decode(stream);\r\n    for (let i = 0; i < count; i++) {\r\n      let end = offsetType.decode(stream);\r\n\r\n      if (this.type != null) {\r\n        let pos = stream.pos;\r\n        stream.pos = startPos + start;\r\n\r\n        parent.length = end - start;\r\n        ret.push(this.type.decode(stream, parent));\r\n        stream.pos = pos;\r\n      } else {\r\n        ret.push({\r\n          offset: startPos + start,\r\n          length: end - start\r\n        });\r\n      }\r\n\r\n      start = end;\r\n    }\r\n\r\n    stream.pos = startPos + start;\r\n    return ret;\r\n  }\r\n\r\n  size(arr, parent) {\r\n    let size = 2;\r\n    if (arr.length === 0) {\r\n      return size;\r\n    }\r\n\r\n    let type = this.type || new r.Buffer;\r\n\r\n    // find maximum offset to detminine offset type\r\n    let offset = 1;\r\n    for (let i = 0; i < arr.length; i++) {\r\n      let item = arr[i];\r\n      offset += type.size(item, parent);\r\n    }\r\n\r\n    let offsetType;\r\n    if (offset <= 0xff) {\r\n      offsetType = r.uint8;\r\n    } else if (offset <= 0xffff) {\r\n      offsetType = r.uint16;\r\n    } else if (offset <= 0xffffff) {\r\n      offsetType = r.uint24;\r\n    } else if (offset <= 0xffffffff) {\r\n      offsetType = r.uint32;\r\n    } else {\r\n      throw new Error(\"Bad offset in CFFIndex\");\r\n    }\r\n\r\n    size += 1 + offsetType.size() * (arr.length + 1);\r\n    size += offset - 1;\r\n\r\n    return size;\r\n  }\r\n\r\n  encode(stream, arr, parent) {\r\n    stream.writeUInt16BE(arr.length);\r\n    if (arr.length === 0) {\r\n      return;\r\n    }\r\n\r\n    let type = this.type || new r.Buffer;\r\n\r\n    // find maximum offset to detminine offset type\r\n    let sizes = [];\r\n    let offset = 1;\r\n    for (let item of arr) {\r\n      let s = type.size(item, parent);\r\n      sizes.push(s);\r\n      offset += s;\r\n    }\r\n\r\n    let offsetType;\r\n    if (offset <= 0xff) {\r\n      offsetType = r.uint8;\r\n    } else if (offset <= 0xffff) {\r\n      offsetType = r.uint16;\r\n    } else if (offset <= 0xffffff) {\r\n      offsetType = r.uint24;\r\n    } else if (offset <= 0xffffffff) {\r\n      offsetType = r.uint32;\r\n    } else {\r\n      throw new Error(\"Bad offset in CFFIndex\");\r\n    }\r\n\r\n    // write offset size\r\n    stream.writeUInt8(offsetType.size());\r\n\r\n    // write elements\r\n    offset = 1;\r\n    offsetType.encode(stream, offset);\r\n\r\n    for (let size of sizes) {\r\n      offset += size;\r\n      offsetType.encode(stream, offset);\r\n    }\r\n\r\n    for (let item of arr) {\r\n      type.encode(stream, item, parent);\r\n    }\r\n\r\n    return;\r\n  }\r\n}\r\n","const FLOAT_EOF = 0xf;\r\nconst FLOAT_LOOKUP = [\r\n  '0', '1', '2', '3', '4', '5', '6', '7',\r\n  '8', '9', '.', 'E', 'E-', null, '-'\r\n];\r\n\r\nconst FLOAT_ENCODE_LOOKUP = {\r\n  '.': 10,\r\n  'E': 11,\r\n  'E-': 12,\r\n  '-': 14\r\n};\r\n\r\nexport default class CFFOperand {\r\n  static decode(stream, value) {\r\n    if (32 <= value && value <= 246) {\r\n      return value - 139;\r\n    }\r\n\r\n    if (247 <= value && value <= 250) {\r\n      return (value - 247) * 256 + stream.readUInt8() + 108;\r\n    }\r\n\r\n    if (251 <= value && value <= 254) {\r\n      return -(value - 251) * 256 - stream.readUInt8() - 108;\r\n    }\r\n\r\n    if (value === 28) {\r\n      return stream.readInt16BE();\r\n    }\r\n\r\n    if (value === 29) {\r\n      return stream.readInt32BE();\r\n    }\r\n\r\n    if (value === 30) {\r\n      let str = '';\r\n      while (true) {\r\n        let b = stream.readUInt8();\r\n\r\n        let n1 = b >> 4;\r\n        if (n1 === FLOAT_EOF) { break; }\r\n        str += FLOAT_LOOKUP[n1];\r\n\r\n        let n2 = b & 15;\r\n        if (n2 === FLOAT_EOF) { break; }\r\n        str += FLOAT_LOOKUP[n2];\r\n      }\r\n\r\n      return parseFloat(str);\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  static size(value) {\r\n    // if the value needs to be forced to the largest size (32 bit)\r\n    // e.g. for unknown pointers, set to 32768\r\n    if (value.forceLarge) {\r\n      value = 32768;\r\n    }\r\n\r\n    if ((value | 0) !== value) { // floating point\r\n      let str = '' + value;\r\n      return 1 + Math.ceil((str.length + 1) / 2);\r\n\r\n    } else if (-107 <= value && value <= 107) {\r\n      return 1;\r\n\r\n    } else if (108 <= value && value <= 1131 || -1131 <= value && value <= -108) {\r\n      return 2;\r\n\r\n    } else if (-32768 <= value && value <= 32767) {\r\n      return 3;\r\n\r\n    } else {\r\n      return 5;\r\n    }\r\n  }\r\n\r\n  static encode(stream, value) {\r\n    // if the value needs to be forced to the largest size (32 bit)\r\n    // e.g. for unknown pointers, save the old value and set to 32768\r\n    let val = Number(value);\r\n\r\n    if (value.forceLarge) {\r\n      stream.writeUInt8(29);\r\n      return stream.writeInt32BE(val);\r\n\r\n    } else if ((val | 0) !== val) { // floating point\r\n      stream.writeUInt8(30);\r\n\r\n      let str = '' + val;\r\n      for (let i = 0; i < str.length; i += 2) {\r\n        let c1 = str[i];\r\n        let n1 = FLOAT_ENCODE_LOOKUP[c1] || +c1;\r\n\r\n        if (i === str.length - 1) {\r\n          var n2 = FLOAT_EOF;\r\n        } else {\r\n          let c2 = str[i + 1];\r\n          var n2 = FLOAT_ENCODE_LOOKUP[c2] || +c2;\r\n        }\r\n\r\n        stream.writeUInt8((n1 << 4) | (n2 & 15));\r\n      }\r\n\r\n      if (n2 !== FLOAT_EOF) {\r\n        return stream.writeUInt8((FLOAT_EOF << 4));\r\n      }\r\n\r\n    } else if (-107 <= val && val <= 107) {\r\n      return stream.writeUInt8(val + 139);\r\n\r\n    } else if (108 <= val && val <= 1131) {\r\n      val -= 108;\r\n      stream.writeUInt8((val >> 8) + 247);\r\n      return stream.writeUInt8(val & 0xff);\r\n\r\n    } else if (-1131 <= val && val <= -108) {\r\n      val = -val - 108;\r\n      stream.writeUInt8((val >> 8) + 251);\r\n      return stream.writeUInt8(val & 0xff);\r\n\r\n    } else if (-32768 <= val && val <= 32767) {\r\n      stream.writeUInt8(28);\r\n      return stream.writeInt16BE(val);\r\n\r\n    } else {\r\n      stream.writeUInt8(29);\r\n      return stream.writeInt32BE(val);\r\n    }\r\n  }\r\n}\r\n","import isEqual from 'deep-equal';\r\nimport r from '@foliojs-fork/restructure';\r\nimport CFFOperand from './CFFOperand';\r\nimport { PropertyDescriptor } from '@foliojs-fork/restructure/src/utils';\r\n\r\nexport default class CFFDict {\r\n  constructor(ops = []) {\r\n    this.ops = ops;\r\n    this.fields = {};\r\n    for (let field of ops) {\r\n      let key = Array.isArray(field[0]) ? field[0][0] << 8 | field[0][1] : field[0];\r\n      this.fields[key] = field;\r\n    }\r\n  }\r\n\r\n  decodeOperands(type, stream, ret, operands) {\r\n    if (Array.isArray(type)) {\r\n      return operands.map((op, i) => this.decodeOperands(type[i], stream, ret, [op]));\r\n    } else if (type.decode != null) {\r\n      return type.decode(stream, ret, operands);\r\n    } else {\r\n      switch (type) {\r\n        case 'number':\r\n        case 'offset':\r\n        case 'sid':\r\n          return operands[0];\r\n        case 'boolean':\r\n          return !!operands[0];\r\n        default:\r\n          return operands;\r\n      }\r\n    }\r\n  }\r\n\r\n  encodeOperands(type, stream, ctx, operands) {\r\n    if (Array.isArray(type)) {\r\n      return operands.map((op, i) => this.encodeOperands(type[i], stream, ctx, op)[0]);\r\n    } else if (type.encode != null) {\r\n      return type.encode(stream, operands, ctx);\r\n    } else if (typeof operands === 'number') {\r\n      return [operands];\r\n    } else if (typeof operands === 'boolean') {\r\n      return [+operands];\r\n    } else if (Array.isArray(operands)) {\r\n      return operands;\r\n    } else {\r\n      return [operands];\r\n    }\r\n  }\r\n\r\n  decode(stream, parent) {\r\n    let end = stream.pos + parent.length;\r\n    let ret = {};\r\n    let operands = [];\r\n\r\n    // define hidden properties\r\n    Object.defineProperties(ret, {\r\n      parent:         { value: parent },\r\n      _startOffset:   { value: stream.pos }\r\n    });\r\n\r\n    // fill in defaults\r\n    for (let key in this.fields) {\r\n      let field = this.fields[key];\r\n      ret[field[1]] = field[3];\r\n    }\r\n\r\n    while (stream.pos < end) {\r\n      let b = stream.readUInt8();\r\n      if (b < 28) {\r\n        if (b === 12) {\r\n          b = (b << 8) | stream.readUInt8();\r\n        }\r\n\r\n        let field = this.fields[b];\r\n        if (!field) {\r\n          throw new Error(`Unknown operator ${b}`);\r\n        }\r\n\r\n        let val = this.decodeOperands(field[2], stream, ret, operands);\r\n        if (val != null) {\r\n          if (val instanceof PropertyDescriptor) {\r\n            Object.defineProperty(ret, field[1], val);\r\n          } else {\r\n            ret[field[1]] = val;\r\n          }\r\n        }\r\n\r\n        operands = [];\r\n      } else {\r\n        operands.push(CFFOperand.decode(stream, b));\r\n      }\r\n    }\r\n\r\n    return ret;\r\n  }\r\n\r\n  size(dict, parent, includePointers = true) {\r\n    let ctx = {\r\n      parent,\r\n      val: dict,\r\n      pointerSize: 0,\r\n      startOffset: parent.startOffset || 0\r\n    };\r\n\r\n    let len = 0;\r\n\r\n    for (let k in this.fields) {\r\n      let field = this.fields[k];\r\n      let val = dict[field[1]];\r\n      if (val == null || isEqual(val, field[3])) {\r\n        continue;\r\n      }\r\n\r\n      let operands = this.encodeOperands(field[2], null, ctx, val);\r\n      for (let op of operands) {\r\n        len += CFFOperand.size(op);\r\n      }\r\n\r\n      let key = Array.isArray(field[0]) ? field[0] : [field[0]];\r\n      len += key.length;\r\n    }\r\n\r\n    if (includePointers) {\r\n      len += ctx.pointerSize;\r\n    }\r\n\r\n    return len;\r\n  }\r\n\r\n  encode(stream, dict, parent) {\r\n    let ctx = {\r\n      pointers: [],\r\n      startOffset: stream.pos,\r\n      parent,\r\n      val: dict,\r\n      pointerSize: 0\r\n    };\r\n\r\n    ctx.pointerOffset = stream.pos + this.size(dict, ctx, false);\r\n\r\n    for (let field of this.ops) {\r\n      let val = dict[field[1]];\r\n      if (val == null || isEqual(val, field[3])) {\r\n        continue;\r\n      }\r\n\r\n      let operands = this.encodeOperands(field[2], stream, ctx, val);\r\n      for (let op of operands) {\r\n        CFFOperand.encode(stream, op);\r\n      }\r\n\r\n      let key = Array.isArray(field[0]) ? field[0] : [field[0]];\r\n      for (let op of key) {\r\n        stream.writeUInt8(op);\r\n      }\r\n    }\r\n\r\n    let i = 0;\r\n    while (i < ctx.pointers.length) {\r\n      let ptr = ctx.pointers[i++];\r\n      ptr.type.encode(stream, ptr.val, ptr.parent);\r\n    }\r\n\r\n    return;\r\n  }\r\n}\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nexport default class CFFPointer extends r.Pointer {\r\n  constructor(type, options = {}) {\r\n    if (options.type == null) {\r\n      options.type = 'global';\r\n    }\r\n\r\n    super(null, type, options);\r\n  }\r\n\r\n  decode(stream, parent, operands) {\r\n    this.offsetType = {\r\n      decode: () => operands[0]\r\n    };\r\n\r\n    return super.decode(stream, parent, operands);\r\n  }\r\n\r\n  encode(stream, value, ctx) {\r\n    if (!stream) {\r\n      // compute the size (so ctx.pointerSize is correct)\r\n      this.offsetType = {\r\n        size: () => 0\r\n      };\r\n\r\n      this.size(value, ctx);\r\n      return [new Ptr(0)];\r\n    }\r\n\r\n    let ptr = null;\r\n    this.offsetType = {\r\n      encode: (stream, val) => ptr = val\r\n    };\r\n\r\n    super.encode(stream, value, ctx);\r\n    return [new Ptr(ptr)];\r\n  }\r\n}\r\n\r\nclass Ptr {\r\n  constructor(val) {\r\n    this.val = val;\r\n    this.forceLarge = true;\r\n  }\r\n\r\n  valueOf() {\r\n    return this.val;\r\n  }\r\n}\r\n","import CFFDict from './CFFDict';\r\nimport CFFIndex from './CFFIndex';\r\nimport CFFPointer from './CFFPointer';\r\n\r\nclass CFFBlendOp {\r\n  static decode(stream, parent, operands) {\r\n    let numBlends = operands.pop();\r\n\r\n    // TODO: actually blend. For now just consume the deltas\r\n    // since we don't use any of the values anyway.\r\n    while (operands.length > numBlends) {\r\n      operands.pop();\r\n    }\r\n  }\r\n}\r\n\r\nexport default new CFFDict([\r\n  // key       name                    type                                          default\r\n  [6,         'BlueValues',           'delta',                                       null],\r\n  [7,         'OtherBlues',           'delta',                                       null],\r\n  [8,         'FamilyBlues',          'delta',                                       null],\r\n  [9,         'FamilyOtherBlues',     'delta',                                       null],\r\n  [[12, 9],   'BlueScale',            'number',                                      0.039625],\r\n  [[12, 10],  'BlueShift',            'number',                                      7],\r\n  [[12, 11],  'BlueFuzz',             'number',                                      1],\r\n  [10,        'StdHW',                'number',                                      null],\r\n  [11,        'StdVW',                'number',                                      null],\r\n  [[12, 12],  'StemSnapH',            'delta',                                       null],\r\n  [[12, 13],  'StemSnapV',            'delta',                                       null],\r\n  [[12, 14],  'ForceBold',            'boolean',                                     false],\r\n  [[12, 17],  'LanguageGroup',        'number',                                      0],\r\n  [[12, 18],  'ExpansionFactor',      'number',                                      0.06],\r\n  [[12, 19],  'initialRandomSeed',    'number',                                      0],\r\n  [20,        'defaultWidthX',        'number',                                      0],\r\n  [21,        'nominalWidthX',        'number',                                      0],\r\n  [22,        'vsindex',              'number',                                      0],\r\n  [23,        'blend',                CFFBlendOp,                                    null],\r\n  [19,        'Subrs',                new CFFPointer(new CFFIndex, {type: 'local'}), null]\r\n]);\r\n","// Automatically generated from Appendix A of the CFF specification; do\r\n// not edit. Length should be 391.\r\nexport default [\r\n  \".notdef\", \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\",\r\n  \"percent\", \"ampersand\", \"quoteright\", \"parenleft\", \"parenright\",\r\n  \"asterisk\", \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\", \"zero\", \"one\",\r\n  \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\",\r\n  \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"at\", \"A\", \"B\", \"C\",\r\n  \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\",\r\n  \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\", \"backslash\",\r\n  \"bracketright\", \"asciicircum\", \"underscore\", \"quoteleft\", \"a\", \"b\", \"c\",\r\n  \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\",\r\n  \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\", \"braceright\",\r\n  \"asciitilde\", \"exclamdown\", \"cent\", \"sterling\", \"fraction\", \"yen\",\r\n  \"florin\", \"section\", \"currency\", \"quotesingle\", \"quotedblleft\",\r\n  \"guillemotleft\", \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\", \"endash\",\r\n  \"dagger\", \"daggerdbl\", \"periodcentered\", \"paragraph\", \"bullet\",\r\n  \"quotesinglbase\", \"quotedblbase\", \"quotedblright\", \"guillemotright\",\r\n  \"ellipsis\", \"perthousand\", \"questiondown\", \"grave\", \"acute\", \"circumflex\",\r\n  \"tilde\", \"macron\", \"breve\", \"dotaccent\", \"dieresis\", \"ring\", \"cedilla\",\r\n  \"hungarumlaut\", \"ogonek\", \"caron\", \"emdash\", \"AE\", \"ordfeminine\", \"Lslash\",\r\n  \"Oslash\", \"OE\", \"ordmasculine\", \"ae\", \"dotlessi\", \"lslash\", \"oslash\", \"oe\",\r\n  \"germandbls\", \"onesuperior\", \"logicalnot\", \"mu\", \"trademark\", \"Eth\",\r\n  \"onehalf\", \"plusminus\", \"Thorn\", \"onequarter\", \"divide\", \"brokenbar\",\r\n  \"degree\", \"thorn\", \"threequarters\", \"twosuperior\", \"registered\", \"minus\",\r\n  \"eth\", \"multiply\", \"threesuperior\", \"copyright\", \"Aacute\", \"Acircumflex\",\r\n  \"Adieresis\", \"Agrave\", \"Aring\", \"Atilde\", \"Ccedilla\", \"Eacute\",\r\n  \"Ecircumflex\", \"Edieresis\", \"Egrave\", \"Iacute\", \"Icircumflex\", \"Idieresis\",\r\n  \"Igrave\", \"Ntilde\", \"Oacute\", \"Ocircumflex\", \"Odieresis\", \"Ograve\",\r\n  \"Otilde\", \"Scaron\", \"Uacute\", \"Ucircumflex\", \"Udieresis\", \"Ugrave\",\r\n  \"Yacute\", \"Ydieresis\", \"Zcaron\", \"aacute\", \"acircumflex\", \"adieresis\",\r\n  \"agrave\", \"aring\", \"atilde\", \"ccedilla\", \"eacute\", \"ecircumflex\",\r\n  \"edieresis\", \"egrave\", \"iacute\", \"icircumflex\", \"idieresis\", \"igrave\",\r\n  \"ntilde\", \"oacute\", \"ocircumflex\", \"odieresis\", \"ograve\", \"otilde\",\r\n  \"scaron\", \"uacute\", \"ucircumflex\", \"udieresis\", \"ugrave\", \"yacute\",\r\n  \"ydieresis\", \"zcaron\", \"exclamsmall\", \"Hungarumlautsmall\",\r\n  \"dollaroldstyle\", \"dollarsuperior\", \"ampersandsmall\", \"Acutesmall\",\r\n  \"parenleftsuperior\", \"parenrightsuperior\", \"twodotenleader\",\r\n  \"onedotenleader\", \"zerooldstyle\", \"oneoldstyle\", \"twooldstyle\",\r\n  \"threeoldstyle\", \"fouroldstyle\", \"fiveoldstyle\", \"sixoldstyle\",\r\n  \"sevenoldstyle\", \"eightoldstyle\", \"nineoldstyle\", \"commasuperior\",\r\n  \"threequartersemdash\", \"periodsuperior\", \"questionsmall\", \"asuperior\",\r\n  \"bsuperior\", \"centsuperior\", \"dsuperior\", \"esuperior\", \"isuperior\",\r\n  \"lsuperior\", \"msuperior\", \"nsuperior\", \"osuperior\", \"rsuperior\",\r\n  \"ssuperior\", \"tsuperior\", \"ff\", \"ffi\", \"ffl\", \"parenleftinferior\",\r\n  \"parenrightinferior\", \"Circumflexsmall\", \"hyphensuperior\", \"Gravesmall\",\r\n  \"Asmall\", \"Bsmall\", \"Csmall\", \"Dsmall\", \"Esmall\", \"Fsmall\", \"Gsmall\",\r\n  \"Hsmall\", \"Ismall\", \"Jsmall\", \"Ksmall\", \"Lsmall\", \"Msmall\", \"Nsmall\",\r\n  \"Osmall\", \"Psmall\", \"Qsmall\", \"Rsmall\", \"Ssmall\", \"Tsmall\", \"Usmall\",\r\n  \"Vsmall\", \"Wsmall\", \"Xsmall\", \"Ysmall\", \"Zsmall\", \"colonmonetary\",\r\n  \"onefitted\", \"rupiah\", \"Tildesmall\", \"exclamdownsmall\", \"centoldstyle\",\r\n  \"Lslashsmall\", \"Scaronsmall\", \"Zcaronsmall\", \"Dieresissmall\", \"Brevesmall\",\r\n  \"Caronsmall\", \"Dotaccentsmall\", \"Macronsmall\", \"figuredash\",\r\n  \"hypheninferior\", \"Ogoneksmall\", \"Ringsmall\", \"Cedillasmall\",\r\n  \"questiondownsmall\", \"oneeighth\", \"threeeighths\", \"fiveeighths\",\r\n  \"seveneighths\", \"onethird\", \"twothirds\", \"zerosuperior\", \"foursuperior\",\r\n  \"fivesuperior\", \"sixsuperior\", \"sevensuperior\", \"eightsuperior\",\r\n  \"ninesuperior\", \"zeroinferior\", \"oneinferior\", \"twoinferior\",\r\n  \"threeinferior\", \"fourinferior\", \"fiveinferior\", \"sixinferior\",\r\n  \"seveninferior\", \"eightinferior\", \"nineinferior\", \"centinferior\",\r\n  \"dollarinferior\", \"periodinferior\", \"commainferior\", \"Agravesmall\",\r\n  \"Aacutesmall\", \"Acircumflexsmall\", \"Atildesmall\", \"Adieresissmall\",\r\n  \"Aringsmall\", \"AEsmall\", \"Ccedillasmall\", \"Egravesmall\", \"Eacutesmall\",\r\n  \"Ecircumflexsmall\", \"Edieresissmall\", \"Igravesmall\", \"Iacutesmall\",\r\n  \"Icircumflexsmall\", \"Idieresissmall\", \"Ethsmall\", \"Ntildesmall\",\r\n  \"Ogravesmall\", \"Oacutesmall\", \"Ocircumflexsmall\", \"Otildesmall\",\r\n  \"Odieresissmall\", \"OEsmall\", \"Oslashsmall\", \"Ugravesmall\", \"Uacutesmall\",\r\n  \"Ucircumflexsmall\", \"Udieresissmall\", \"Yacutesmall\", \"Thornsmall\",\r\n  \"Ydieresissmall\", \"001.000\", \"001.001\", \"001.002\", \"001.003\", \"Black\",\r\n  \"Bold\", \"Book\", \"Light\", \"Medium\", \"Regular\", \"Roman\", \"Semibold\"\r\n];\r\n","export let StandardEncoding = [\r\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\r\n  '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',\r\n  'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',\r\n  'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',\r\n  'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\r\n  'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',\r\n  'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\r\n  'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',\r\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\r\n  'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',\r\n  'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',\r\n  'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',\r\n  'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',\r\n  'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',\r\n  'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',\r\n  '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',\r\n  'lslash', 'oslash', 'oe', 'germandbls'\r\n];\r\n\r\nexport let ExpertEncoding = [\r\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\r\n  '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',\r\n  'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',\r\n  'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',\r\n  'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',\r\n  'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',\r\n  'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',\r\n  'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',\r\n  'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',\r\n  'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',\r\n  'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',\r\n  'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',\r\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\r\n  'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',\r\n  'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',\r\n  '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',\r\n  'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',\r\n  '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',\r\n  'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',\r\n  'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',\r\n  'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',\r\n  'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',\r\n  'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',\r\n  'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',\r\n  'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',\r\n  'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'\r\n];\r\n","export let ISOAdobeCharset = [\r\n  '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar',\r\n  'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright',\r\n  'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero',\r\n  'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight',\r\n  'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question',\r\n  'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\r\n  'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\r\n  'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',\r\n  'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\r\n  'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\r\n  'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent',\r\n  'sterling', 'fraction', 'yen', 'florin', 'section', 'currency',\r\n  'quotesingle', 'quotedblleft', 'guillemotleft', 'guilsinglleft',\r\n  'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl',\r\n  'periodcentered', 'paragraph', 'bullet', 'quotesinglbase',\r\n  'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis',\r\n  'perthousand', 'questiondown', 'grave', 'acute', 'circumflex', 'tilde',\r\n  'macron', 'breve', 'dotaccent', 'dieresis', 'ring', 'cedilla',\r\n  'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine',\r\n  'Lslash', 'Oslash', 'OE', 'ordmasculine', 'ae', 'dotlessi', 'lslash',\r\n  'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',\r\n  'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter',\r\n  'divide', 'brokenbar', 'degree', 'thorn', 'threequarters', 'twosuperior',\r\n  'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',\r\n  'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde',\r\n  'Ccedilla', 'Eacute', 'Ecircumflex', 'Edieresis', 'Egrave', 'Iacute',\r\n  'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',\r\n  'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex',\r\n  'Udieresis', 'Ugrave', 'Yacute', 'Ydieresis', 'Zcaron', 'aacute',\r\n  'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla',\r\n  'eacute', 'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex',\r\n  'idieresis', 'igrave', 'ntilde', 'oacute', 'ocircumflex', 'odieresis',\r\n  'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis',\r\n  'ugrave', 'yacute', 'ydieresis', 'zcaron'\r\n];\r\n\r\nexport let ExpertCharset = [\r\n  '.notdef', 'space', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle',\r\n  'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior',\r\n  'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma',\r\n  'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle',\r\n  'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle',\r\n  'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle',\r\n  'colon', 'semicolon', 'commasuperior', 'threequartersemdash',\r\n  'periodsuperior', 'questionsmall', 'asuperior', 'bsuperior',\r\n  'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',\r\n  'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior',\r\n  'tsuperior', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior',\r\n  'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall',\r\n  'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall',\r\n  'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall',\r\n  'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall',\r\n  'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary',\r\n  'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall', 'centoldstyle',\r\n  'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',\r\n  'Brevesmall', 'Caronsmall', 'Dotaccentsmall', 'Macronsmall',\r\n  'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall',\r\n  'Cedillasmall', 'onequarter', 'onehalf', 'threequarters',\r\n  'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths',\r\n  'seveneighths', 'onethird', 'twothirds', 'zerosuperior', 'onesuperior',\r\n  'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',\r\n  'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',\r\n  'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior',\r\n  'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior',\r\n  'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior',\r\n  'periodinferior', 'commainferior', 'Agravesmall', 'Aacutesmall',\r\n  'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall',\r\n  'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall',\r\n  'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',\r\n  'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall',\r\n  'Ogravesmall', 'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall',\r\n  'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',\r\n  'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall',\r\n  'Ydieresissmall'\r\n];\r\n\r\nexport let ExpertSubsetCharset = [\r\n  '.notdef', 'space', 'dollaroldstyle', 'dollarsuperior',\r\n  'parenleftsuperior', 'parenrightsuperior', 'twodotenleader',\r\n  'onedotenleader', 'comma', 'hyphen', 'period', 'fraction',\r\n  'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',\r\n  'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle',\r\n  'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', 'commasuperior',\r\n  'threequartersemdash', 'periodsuperior', 'asuperior', 'bsuperior',\r\n  'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',\r\n  'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior',\r\n  'tsuperior', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior',\r\n  'parenrightinferior', 'hyphensuperior', 'colonmonetary', 'onefitted',\r\n  'rupiah', 'centoldstyle', 'figuredash', 'hypheninferior', 'onequarter',\r\n  'onehalf', 'threequarters', 'oneeighth', 'threeeighths', 'fiveeighths',\r\n  'seveneighths', 'onethird', 'twothirds', 'zerosuperior', 'onesuperior',\r\n  'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',\r\n  'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',\r\n  'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior',\r\n  'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior',\r\n  'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior',\r\n  'periodinferior', 'commainferior'\r\n];\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n//########################\r\n// Scripts and Languages #\r\n//########################\r\n\r\nlet LangSysTable = new r.Struct({\r\n  reserved:         new r.Reserved(r.uint16),\r\n  reqFeatureIndex:  r.uint16,\r\n  featureCount:     r.uint16,\r\n  featureIndexes:   new r.Array(r.uint16, 'featureCount')\r\n});\r\n\r\nlet LangSysRecord = new r.Struct({\r\n  tag:      new r.String(4),\r\n  langSys:  new r.Pointer(r.uint16, LangSysTable, { type: 'parent' })\r\n});\r\n\r\nlet Script = new r.Struct({\r\n  defaultLangSys: new r.Pointer(r.uint16, LangSysTable),\r\n  count:          r.uint16,\r\n  langSysRecords: new r.Array(LangSysRecord, 'count')\r\n});\r\n\r\nlet ScriptRecord = new r.Struct({\r\n  tag:    new r.String(4),\r\n  script: new r.Pointer(r.uint16, Script, { type: 'parent' })\r\n});\r\n\r\nexport let ScriptList = new r.Array(ScriptRecord, r.uint16);\r\n\r\n//#######################\r\n// Features and Lookups #\r\n//#######################\r\n\r\nexport let Feature = new r.Struct({\r\n  featureParams:      r.uint16, // pointer\r\n  lookupCount:        r.uint16,\r\n  lookupListIndexes:  new r.Array(r.uint16, 'lookupCount')\r\n});\r\n\r\nlet FeatureRecord = new r.Struct({\r\n  tag:      new r.String(4),\r\n  feature:  new r.Pointer(r.uint16, Feature, { type: 'parent' })\r\n});\r\n\r\nexport let FeatureList = new r.Array(FeatureRecord, r.uint16);\r\n\r\nlet LookupFlags = new r.Struct({\r\n  markAttachmentType: r.uint8,\r\n  flags: new r.Bitfield(r.uint8, [\r\n    'rightToLeft', 'ignoreBaseGlyphs', 'ignoreLigatures',\r\n    'ignoreMarks', 'useMarkFilteringSet'\r\n  ])\r\n});\r\n\r\nexport function LookupList(SubTable) {\r\n  let Lookup = new r.Struct({\r\n    lookupType:         r.uint16,\r\n    flags:              LookupFlags,\r\n    subTableCount:      r.uint16,\r\n    subTables:          new r.Array(new r.Pointer(r.uint16, SubTable), 'subTableCount'),\r\n    markFilteringSet:   new r.Optional(r.uint16, t => t.flags.flags.useMarkFilteringSet)\r\n  });\r\n\r\n  return new r.LazyArray(new r.Pointer(r.uint16, Lookup), r.uint16);\r\n}\r\n\r\n//#################\r\n// Coverage Table #\r\n//#################\r\n\r\nlet RangeRecord = new r.Struct({\r\n  start:              r.uint16,\r\n  end:                r.uint16,\r\n  startCoverageIndex: r.uint16\r\n});\r\n\r\nexport let Coverage = new r.VersionedStruct(r.uint16, {\r\n  1: {\r\n    glyphCount:   r.uint16,\r\n    glyphs:       new r.Array(r.uint16, 'glyphCount')\r\n  },\r\n  2: {\r\n    rangeCount:   r.uint16,\r\n    rangeRecords: new r.Array(RangeRecord, 'rangeCount')\r\n  }\r\n});\r\n\r\n//#########################\r\n// Class Definition Table #\r\n//#########################\r\n\r\nlet ClassRangeRecord = new r.Struct({\r\n  start:  r.uint16,\r\n  end:    r.uint16,\r\n  class:  r.uint16\r\n});\r\n\r\nexport let ClassDef = new r.VersionedStruct(r.uint16, {\r\n  1: { // Class array\r\n    startGlyph:       r.uint16,\r\n    glyphCount:       r.uint16,\r\n    classValueArray:  new r.Array(r.uint16, 'glyphCount')\r\n  },\r\n  2: { // Class ranges\r\n    classRangeCount:  r.uint16,\r\n    classRangeRecord: new r.Array(ClassRangeRecord, 'classRangeCount')\r\n  }\r\n});\r\n\r\n//###############\r\n// Device Table #\r\n//###############\r\n\r\nexport let Device = new r.Struct({\r\n  a: r.uint16, // startSize for hinting Device, outerIndex for VariationIndex\r\n  b: r.uint16, // endSize for Device, innerIndex for VariationIndex\r\n  deltaFormat: r.uint16\r\n});\r\n\r\n//#############################################\r\n// Contextual Substitution/Positioning Tables #\r\n//#############################################\r\n\r\nlet LookupRecord = new r.Struct({\r\n  sequenceIndex:      r.uint16,\r\n  lookupListIndex:    r.uint16\r\n});\r\n\r\nlet Rule = new r.Struct({\r\n  glyphCount:     r.uint16,\r\n  lookupCount:    r.uint16,\r\n  input:          new r.Array(r.uint16, t => t.glyphCount - 1),\r\n  lookupRecords:  new r.Array(LookupRecord, 'lookupCount')\r\n});\r\n\r\nlet RuleSet = new r.Array(new r.Pointer(r.uint16, Rule), r.uint16);\r\n\r\nlet ClassRule = new r.Struct({\r\n  glyphCount:     r.uint16,\r\n  lookupCount:    r.uint16,\r\n  classes:        new r.Array(r.uint16, t => t.glyphCount - 1),\r\n  lookupRecords:  new r.Array(LookupRecord, 'lookupCount')\r\n});\r\n\r\nlet ClassSet = new r.Array(new r.Pointer(r.uint16, ClassRule), r.uint16);\r\n\r\nexport let Context = new r.VersionedStruct(r.uint16, {\r\n  1: { // Simple context\r\n    coverage:      new r.Pointer(r.uint16, Coverage),\r\n    ruleSetCount:  r.uint16,\r\n    ruleSets:      new r.Array(new r.Pointer(r.uint16, RuleSet), 'ruleSetCount')\r\n  },\r\n  2: { // Class-based context\r\n    coverage:      new r.Pointer(r.uint16, Coverage),\r\n    classDef:      new r.Pointer(r.uint16, ClassDef),\r\n    classSetCnt:   r.uint16,\r\n    classSet:      new r.Array(new r.Pointer(r.uint16, ClassSet), 'classSetCnt')\r\n  },\r\n  3: {\r\n    glyphCount:    r.uint16,\r\n    lookupCount:   r.uint16,\r\n    coverages:     new r.Array(new r.Pointer(r.uint16, Coverage), 'glyphCount'),\r\n    lookupRecords: new r.Array(LookupRecord, 'lookupCount')\r\n  }\r\n});\r\n\r\n//######################################################\r\n// Chaining Contextual Substitution/Positioning Tables #\r\n//######################################################\r\n\r\nlet ChainRule = new r.Struct({\r\n  backtrackGlyphCount:  r.uint16,\r\n  backtrack:            new r.Array(r.uint16, 'backtrackGlyphCount'),\r\n  inputGlyphCount:      r.uint16,\r\n  input:                new r.Array(r.uint16, t => t.inputGlyphCount - 1),\r\n  lookaheadGlyphCount:  r.uint16,\r\n  lookahead:            new r.Array(r.uint16, 'lookaheadGlyphCount'),\r\n  lookupCount:          r.uint16,\r\n  lookupRecords:        new r.Array(LookupRecord, 'lookupCount')\r\n});\r\n\r\nlet ChainRuleSet = new r.Array(new r.Pointer(r.uint16, ChainRule), r.uint16);\r\n\r\nexport let ChainingContext = new r.VersionedStruct(r.uint16, {\r\n  1: { // Simple context glyph substitution\r\n    coverage:           new r.Pointer(r.uint16, Coverage),\r\n    chainCount:         r.uint16,\r\n    chainRuleSets:      new r.Array(new r.Pointer(r.uint16, ChainRuleSet), 'chainCount')\r\n  },\r\n\r\n  2: { // Class-based chaining context\r\n    coverage:           new r.Pointer(r.uint16, Coverage),\r\n    backtrackClassDef:  new r.Pointer(r.uint16, ClassDef),\r\n    inputClassDef:      new r.Pointer(r.uint16, ClassDef),\r\n    lookaheadClassDef:  new r.Pointer(r.uint16, ClassDef),\r\n    chainCount:         r.uint16,\r\n    chainClassSet:      new r.Array(new r.Pointer(r.uint16, ChainRuleSet), 'chainCount')\r\n  },\r\n\r\n  3: { // Coverage-based chaining context\r\n    backtrackGlyphCount:    r.uint16,\r\n    backtrackCoverage:      new r.Array(new r.Pointer(r.uint16, Coverage), 'backtrackGlyphCount'),\r\n    inputGlyphCount:        r.uint16,\r\n    inputCoverage:          new r.Array(new r.Pointer(r.uint16, Coverage), 'inputGlyphCount'),\r\n    lookaheadGlyphCount:    r.uint16,\r\n    lookaheadCoverage:      new r.Array(new r.Pointer(r.uint16, Coverage), 'lookaheadGlyphCount'),\r\n    lookupCount:            r.uint16,\r\n    lookupRecords:          new r.Array(LookupRecord, 'lookupCount')\r\n  }\r\n});\r\n","import {Feature} from './opentype';\r\nimport r from '@foliojs-fork/restructure';\r\n\r\n/*******************\r\n * Variation Store *\r\n *******************/\r\n\r\nlet F2DOT14 = new r.Fixed(16, 'BE', 14);\r\nlet RegionAxisCoordinates = new r.Struct({\r\n  startCoord: F2DOT14,\r\n  peakCoord: F2DOT14,\r\n  endCoord: F2DOT14\r\n});\r\n\r\nlet VariationRegionList = new r.Struct({\r\n  axisCount: r.uint16,\r\n  regionCount: r.uint16,\r\n  variationRegions: new r.Array(new r.Array(RegionAxisCoordinates, 'axisCount'), 'regionCount')\r\n});\r\n\r\nlet DeltaSet = new r.Struct({\r\n  shortDeltas: new r.Array(r.int16, t => t.parent.shortDeltaCount),\r\n  regionDeltas: new r.Array(r.int8, t => t.parent.regionIndexCount - t.parent.shortDeltaCount),\r\n  deltas: t => t.shortDeltas.concat(t.regionDeltas)\r\n});\r\n\r\nlet ItemVariationData = new r.Struct({\r\n  itemCount: r.uint16,\r\n  shortDeltaCount: r.uint16,\r\n  regionIndexCount: r.uint16,\r\n  regionIndexes: new r.Array(r.uint16, 'regionIndexCount'),\r\n  deltaSets: new r.Array(DeltaSet, 'itemCount')\r\n});\r\n\r\nexport let ItemVariationStore = new r.Struct({\r\n  format: r.uint16,\r\n  variationRegionList: new r.Pointer(r.uint32, VariationRegionList),\r\n  variationDataCount: r.uint16,\r\n  itemVariationData: new r.Array(new r.Pointer(r.uint32, ItemVariationData), 'variationDataCount')\r\n});\r\n\r\n/**********************\r\n * Feature Variations *\r\n **********************/\r\n\r\nlet ConditionTable = new r.VersionedStruct(r.uint16, {\r\n  1: {\r\n    axisIndex: r.uint16,\r\n    axisIndex: r.uint16,\r\n    filterRangeMinValue: F2DOT14,\r\n    filterRangeMaxValue: F2DOT14\r\n  }\r\n});\r\n\r\nlet ConditionSet = new r.Struct({\r\n  conditionCount: r.uint16,\r\n  conditionTable: new r.Array(new r.Pointer(r.uint32, ConditionTable), 'conditionCount')\r\n});\r\n\r\nlet FeatureTableSubstitutionRecord = new r.Struct({\r\n  featureIndex: r.uint16,\r\n  alternateFeatureTable: new r.Pointer(r.uint32, Feature, {type: 'parent'})\r\n});\r\n\r\nlet FeatureTableSubstitution = new r.Struct({\r\n  version: r.fixed32,\r\n  substitutionCount: r.uint16,\r\n  substitutions: new r.Array(FeatureTableSubstitutionRecord, 'substitutionCount')\r\n});\r\n\r\nlet FeatureVariationRecord = new r.Struct({\r\n  conditionSet: new r.Pointer(r.uint32, ConditionSet, {type: 'parent'}),\r\n  featureTableSubstitution: new r.Pointer(r.uint32, FeatureTableSubstitution, {type: 'parent'})\r\n});\r\n\r\nexport let FeatureVariations = new r.Struct({\r\n  majorVersion: r.uint16,\r\n  minorVersion: r.uint16,\r\n  featureVariationRecordCount: r.uint32,\r\n  featureVariationRecords: new r.Array(FeatureVariationRecord, 'featureVariationRecordCount')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\nimport { resolveLength } from '@foliojs-fork/restructure/src/utils';\r\nimport CFFDict from './CFFDict';\r\nimport CFFIndex from './CFFIndex';\r\nimport CFFPointer from './CFFPointer';\r\nimport CFFPrivateDict from './CFFPrivateDict';\r\nimport StandardStrings from './CFFStandardStrings';\r\nimport { StandardEncoding, ExpertEncoding } from './CFFEncodings';\r\nimport { ISOAdobeCharset, ExpertCharset, ExpertSubsetCharset } from './CFFCharsets';\r\nimport { ItemVariationStore } from '../tables/variations';\r\n\r\n// Checks if an operand is an index of a predefined value,\r\n// otherwise delegates to the provided type.\r\nclass PredefinedOp {\r\n  constructor(predefinedOps, type) {\r\n    this.predefinedOps = predefinedOps;\r\n    this.type = type;\r\n  }\r\n\r\n  decode(stream, parent, operands) {\r\n    if (this.predefinedOps[operands[0]]) {\r\n      return this.predefinedOps[operands[0]];\r\n    }\r\n\r\n    return this.type.decode(stream, parent, operands);\r\n  }\r\n\r\n  size(value, ctx) {\r\n    return this.type.size(value, ctx);\r\n  }\r\n\r\n  encode(stream, value, ctx) {\r\n    let index = this.predefinedOps.indexOf(value);\r\n    if (index !== -1) {\r\n      return index;\r\n    }\r\n\r\n    return this.type.encode(stream, value, ctx);\r\n  }\r\n}\r\n\r\nclass CFFEncodingVersion extends r.Number {\r\n  constructor() {\r\n    super('UInt8');\r\n  }\r\n\r\n  decode(stream) {\r\n    return r.uint8.decode(stream) & 0x7f;\r\n  }\r\n}\r\n\r\nlet Range1 = new r.Struct({\r\n  first: r.uint16,\r\n  nLeft: r.uint8\r\n});\r\n\r\nlet Range2 = new r.Struct({\r\n  first: r.uint16,\r\n  nLeft: r.uint16\r\n});\r\n\r\nlet CFFCustomEncoding = new r.VersionedStruct(new CFFEncodingVersion(), {\r\n  0: {\r\n    nCodes: r.uint8,\r\n    codes: new r.Array(r.uint8, 'nCodes')\r\n  },\r\n\r\n  1: {\r\n    nRanges: r.uint8,\r\n    ranges: new r.Array(Range1, 'nRanges')\r\n  }\r\n\r\n  // TODO: supplement?\r\n});\r\n\r\nlet CFFEncoding = new PredefinedOp([ StandardEncoding, ExpertEncoding ], new CFFPointer(CFFCustomEncoding, { lazy: true }));\r\n\r\n// Decodes an array of ranges until the total\r\n// length is equal to the provided length.\r\nclass RangeArray extends r.Array {\r\n  decode(stream, parent) {\r\n    let length = resolveLength(this.length, stream, parent);\r\n    let count = 0;\r\n    let res = [];\r\n    while (count < length) {\r\n      let range = this.type.decode(stream, parent);\r\n      range.offset = count;\r\n      count += range.nLeft + 1;\r\n      res.push(range);\r\n    }\r\n\r\n    return res;\r\n  }\r\n}\r\n\r\nlet CFFCustomCharset = new r.VersionedStruct(r.uint8, {\r\n  0: {\r\n    glyphs: new r.Array(r.uint16, t => t.parent.CharStrings.length - 1)\r\n  },\r\n\r\n  1: {\r\n    ranges: new RangeArray(Range1, t => t.parent.CharStrings.length - 1)\r\n  },\r\n\r\n  2: {\r\n    ranges: new RangeArray(Range2, t => t.parent.CharStrings.length - 1)\r\n  }\r\n});\r\n\r\nlet CFFCharset = new PredefinedOp([ ISOAdobeCharset, ExpertCharset, ExpertSubsetCharset ], new CFFPointer(CFFCustomCharset, {lazy: true}));\r\n\r\nlet FDRange3 = new r.Struct({\r\n  first: r.uint16,\r\n  fd: r.uint8\r\n});\r\n\r\nlet FDRange4 = new r.Struct({\r\n  first: r.uint32,\r\n  fd: r.uint16\r\n});\r\n\r\nlet FDSelect = new r.VersionedStruct(r.uint8, {\r\n  0: {\r\n    fds: new r.Array(r.uint8, t => t.parent.CharStrings.length)\r\n  },\r\n\r\n  3: {\r\n    nRanges: r.uint16,\r\n    ranges: new r.Array(FDRange3, 'nRanges'),\r\n    sentinel: r.uint16\r\n  },\r\n\r\n  4: {\r\n    nRanges: r.uint32,\r\n    ranges: new r.Array(FDRange4, 'nRanges'),\r\n    sentinel: r.uint32\r\n  }\r\n});\r\n\r\nlet ptr = new CFFPointer(CFFPrivateDict);\r\nclass CFFPrivateOp {\r\n  decode(stream, parent, operands) {\r\n    parent.length = operands[0];\r\n    return ptr.decode(stream, parent, [operands[1]]);\r\n  }\r\n\r\n  size(dict, ctx) {\r\n    return [CFFPrivateDict.size(dict, ctx, false), ptr.size(dict, ctx)[0]];\r\n  }\r\n\r\n  encode(stream, dict, ctx) {\r\n    return [CFFPrivateDict.size(dict, ctx, false), ptr.encode(stream, dict, ctx)[0]];\r\n  }\r\n}\r\n\r\nlet FontDict = new CFFDict([\r\n  // key       name                   type(s)                                 default\r\n  [18,        'Private',              new CFFPrivateOp,                       null],\r\n  [[12, 38],  'FontName',             'sid',                                  null],\r\n  [[12, 7],   'FontMatrix',           'array',                                [0.001, 0, 0, 0.001, 0, 0]],\r\n  [[12, 5],   'PaintType',            'number',                               0],\r\n]);\r\n\r\nlet CFFTopDict = new CFFDict([\r\n  // key       name                   type(s)                                 default\r\n  [[12, 30],  'ROS',                  ['sid', 'sid', 'number'],               null],\r\n\r\n  [0,         'version',              'sid',                                  null],\r\n  [1,         'Notice',               'sid',                                  null],\r\n  [[12, 0],   'Copyright',            'sid',                                  null],\r\n  [2,         'FullName',             'sid',                                  null],\r\n  [3,         'FamilyName',           'sid',                                  null],\r\n  [4,         'Weight',               'sid',                                  null],\r\n  [[12, 1],   'isFixedPitch',         'boolean',                              false],\r\n  [[12, 2],   'ItalicAngle',          'number',                               0],\r\n  [[12, 3],   'UnderlinePosition',    'number',                               -100],\r\n  [[12, 4],   'UnderlineThickness',   'number',                               50],\r\n  [[12, 5],   'PaintType',            'number',                               0],\r\n  [[12, 6],   'CharstringType',       'number',                               2],\r\n  [[12, 7],   'FontMatrix',           'array',                                [0.001, 0, 0, 0.001, 0, 0]],\r\n  [13,        'UniqueID',             'number',                               null],\r\n  [5,         'FontBBox',             'array',                                [0, 0, 0, 0]],\r\n  [[12, 8],   'StrokeWidth',          'number',                               0],\r\n  [14,        'XUID',                 'array',                                null],\r\n  [15,        'charset',              CFFCharset,                             ISOAdobeCharset],\r\n  [16,        'Encoding',             CFFEncoding,                            StandardEncoding],\r\n  [17,        'CharStrings',          new CFFPointer(new CFFIndex),           null],\r\n  [18,        'Private',              new CFFPrivateOp,                       null],\r\n  [[12, 20],  'SyntheticBase',        'number',                               null],\r\n  [[12, 21],  'PostScript',           'sid',                                  null],\r\n  [[12, 22],  'BaseFontName',         'sid',                                  null],\r\n  [[12, 23],  'BaseFontBlend',        'delta',                                null],\r\n\r\n  // CID font specific\r\n  [[12, 31],  'CIDFontVersion',       'number',                               0],\r\n  [[12, 32],  'CIDFontRevision',      'number',                               0],\r\n  [[12, 33],  'CIDFontType',          'number',                               0],\r\n  [[12, 34],  'CIDCount',             'number',                               8720],\r\n  [[12, 35],  'UIDBase',              'number',                               null],\r\n  [[12, 37],  'FDSelect',             new CFFPointer(FDSelect),               null],\r\n  [[12, 36],  'FDArray',              new CFFPointer(new CFFIndex(FontDict)), null],\r\n  [[12, 38],  'FontName',             'sid',                                  null]\r\n]);\r\n\r\nlet VariationStore = new r.Struct({\r\n  length: r.uint16,\r\n  itemVariationStore: ItemVariationStore\r\n})\r\n\r\nlet CFF2TopDict = new CFFDict([\r\n  [[12, 7],   'FontMatrix',           'array',                                [0.001, 0, 0, 0.001, 0, 0]],\r\n  [17,        'CharStrings',          new CFFPointer(new CFFIndex),           null],\r\n  [[12, 37],  'FDSelect',             new CFFPointer(FDSelect),               null],\r\n  [[12, 36],  'FDArray',              new CFFPointer(new CFFIndex(FontDict)), null],\r\n  [24,        'vstore',               new CFFPointer(VariationStore),         null],\r\n  [25,        'maxstack',             'number',                               193]\r\n]);\r\n\r\nlet CFFTop = new r.VersionedStruct(r.fixed16, {\r\n  1: {\r\n    hdrSize:            r.uint8,\r\n    offSize:            r.uint8,\r\n    nameIndex:          new CFFIndex(new r.String('length')),\r\n    topDictIndex:       new CFFIndex(CFFTopDict),\r\n    stringIndex:        new CFFIndex(new r.String('length')),\r\n    globalSubrIndex:    new CFFIndex\r\n  },\r\n\r\n  2: {\r\n    hdrSize:            r.uint8,\r\n    length:             r.uint16,\r\n    topDict:            CFF2TopDict,\r\n    globalSubrIndex:    new CFFIndex\r\n  }\r\n});\r\n\r\nexport default CFFTop;\r\n","import r from '@foliojs-fork/restructure';\r\nimport CFFIndex from './CFFIndex';\r\nimport CFFTop from './CFFTop';\r\nimport CFFPrivateDict from './CFFPrivateDict';\r\nimport standardStrings from './CFFStandardStrings';\r\n\r\nclass CFFFont {\r\n  constructor(stream) {\r\n    this.stream = stream;\r\n    this.decode();\r\n  }\r\n\r\n  static decode(stream) {\r\n    return new CFFFont(stream);\r\n  }\r\n\r\n  decode() {\r\n    let start = this.stream.pos;\r\n    let top = CFFTop.decode(this.stream);\r\n    for (let key in top) {\r\n      let val = top[key];\r\n      this[key] = val;\r\n    }\r\n\r\n    if (this.version < 2) {\r\n      if (this.topDictIndex.length !== 1) {\r\n        throw new Error(\"Only a single font is allowed in CFF\");\r\n      }\r\n\r\n      this.topDict = this.topDictIndex[0];\r\n    }\r\n\r\n    this.isCIDFont = this.topDict.ROS != null;\r\n    return this;\r\n  }\r\n\r\n  string(sid) {\r\n    if (this.version >= 2) {\r\n      return null;\r\n    }\r\n\r\n    if (sid < standardStrings.length) {\r\n      return standardStrings[sid];\r\n    }\r\n\r\n    return this.stringIndex[sid - standardStrings.length];\r\n  }\r\n\r\n  get postscriptName() {\r\n    if (this.version < 2) {\r\n      return this.nameIndex[0];\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  get fullName() {\r\n    return this.string(this.topDict.FullName);\r\n  }\r\n\r\n  get familyName() {\r\n    return this.string(this.topDict.FamilyName);\r\n  }\r\n\r\n  getCharString(glyph) {\r\n    this.stream.pos = this.topDict.CharStrings[glyph].offset;\r\n    return this.stream.readBuffer(this.topDict.CharStrings[glyph].length);\r\n  }\r\n\r\n  getGlyphName(gid) {\r\n    // CFF2 glyph names are in the post table.\r\n    if (this.version >= 2) {\r\n      return null;\r\n    }\r\n\r\n    // CID-keyed fonts don't have glyph names\r\n    if (this.isCIDFont) {\r\n      return null;\r\n    }\r\n\r\n    let { charset } = this.topDict;\r\n    if (Array.isArray(charset)) {\r\n      return charset[gid];\r\n    }\r\n\r\n    if (gid === 0) {\r\n      return '.notdef';\r\n    }\r\n\r\n    gid -= 1;\r\n\r\n    switch (charset.version) {\r\n      case 0:\r\n        return this.string(charset.glyphs[gid]);\r\n\r\n      case 1:\r\n      case 2:\r\n        for (let i = 0; i < charset.ranges.length; i++) {\r\n          let range = charset.ranges[i];\r\n          if (range.offset <= gid && gid <= range.offset + range.nLeft) {\r\n            return this.string(range.first + (gid - range.offset));\r\n          }\r\n        }\r\n        break;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  fdForGlyph(gid) {\r\n    if (!this.topDict.FDSelect) {\r\n      return null;\r\n    }\r\n\r\n    switch (this.topDict.FDSelect.version) {\r\n      case 0:\r\n        return this.topDict.FDSelect.fds[gid];\r\n\r\n      case 3:\r\n      case 4:\r\n        let { ranges } = this.topDict.FDSelect;\r\n        let low = 0;\r\n        let high = ranges.length - 1;\r\n\r\n        while (low <= high) {\r\n          let mid = (low + high) >> 1;\r\n\r\n          if (gid < ranges[mid].first) {\r\n            high = mid - 1;\r\n          } else if (mid < high && gid >= ranges[mid + 1].first) {\r\n            low = mid + 1;\r\n          } else {\r\n            return ranges[mid].fd;\r\n          }\r\n        }\r\n      default:\r\n        throw new Error(`Unknown FDSelect version: ${this.topDict.FDSelect.version}`);\r\n    }\r\n  }\r\n\r\n  privateDictForGlyph(gid) {\r\n    if (this.topDict.FDSelect) {\r\n      let fd = this.fdForGlyph(gid);\r\n      if (this.topDict.FDArray[fd]) {\r\n        return this.topDict.FDArray[fd].Private;\r\n      }\r\n\r\n      return null;\r\n    }\r\n\r\n    if (this.version < 2) {\r\n      return this.topDict.Private;\r\n    }\r\n\r\n    return this.topDict.FDArray[0].Private;\r\n  }\r\n}\r\n\r\nexport default CFFFont;\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet VerticalOrigin = new r.Struct({\r\n  glyphIndex:   r.uint16,\r\n  vertOriginY:  r.int16\r\n});\r\n\r\nexport default new r.Struct({\r\n  majorVersion:           r.uint16,\r\n  minorVersion:           r.uint16,\r\n  defaultVertOriginY:     r.int16,\r\n  numVertOriginYMetrics:  r.uint16,\r\n  metrics:                new r.Array(VerticalOrigin, 'numVertOriginYMetrics')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nexport let BigMetrics = new r.Struct({\r\n  height: r.uint8,\r\n  width: r.uint8,\r\n  horiBearingX: r.int8,\r\n  horiBearingY: r.int8,\r\n  horiAdvance: r.uint8,\r\n  vertBearingX: r.int8,\r\n  vertBearingY: r.int8,\r\n  vertAdvance: r.uint8\r\n});\r\n\r\nexport let SmallMetrics = new r.Struct({\r\n  height: r.uint8,\r\n  width: r.uint8,\r\n  bearingX: r.int8,\r\n  bearingY: r.int8,\r\n  advance: r.uint8\r\n});\r\n\r\nlet EBDTComponent = new r.Struct({\r\n  glyph: r.uint16,\r\n  xOffset: r.int8,\r\n  yOffset: r.int8\r\n});\r\n\r\nclass ByteAligned {}\r\n\r\nclass BitAligned {}\r\n\r\nexport let glyph = new r.VersionedStruct('version', {\r\n  1: {\r\n    metrics: SmallMetrics,\r\n    data: ByteAligned\r\n  },\r\n\r\n  2: {\r\n    metrics: SmallMetrics,\r\n    data: BitAligned\r\n  },\r\n\r\n  // format 3 is deprecated\r\n  // format 4 is not supported by Microsoft\r\n\r\n  5: {\r\n    data: BitAligned\r\n  },\r\n\r\n  6: {\r\n    metrics: BigMetrics,\r\n    data: ByteAligned\r\n  },\r\n\r\n  7: {\r\n    metrics: BigMetrics,\r\n    data: BitAligned\r\n  },\r\n\r\n  8: {\r\n    metrics: SmallMetrics,\r\n    pad: new r.Reserved(r.uint8),\r\n    numComponents: r.uint16,\r\n    components: new r.Array(EBDTComponent, 'numComponents')\r\n  },\r\n\r\n  9: {\r\n    metrics: BigMetrics,\r\n    pad: new r.Reserved(r.uint8),\r\n    numComponents: r.uint16,\r\n    components: new r.Array(EBDTComponent, 'numComponents')\r\n  },\r\n\r\n  17: {\r\n    metrics: SmallMetrics,\r\n    dataLen: r.uint32,\r\n    data: new r.Buffer('dataLen')\r\n  },\r\n\r\n  18: {\r\n    metrics: BigMetrics,\r\n    dataLen: r.uint32,\r\n    data: new r.Buffer('dataLen')\r\n  },\r\n\r\n  19: {\r\n    dataLen: r.uint32,\r\n    data: new r.Buffer('dataLen')\r\n  }\r\n});\r\n\r\n","import r from '@foliojs-fork/restructure';\r\nimport {BigMetrics} from './EBDT';\r\n\r\nlet SBitLineMetrics = new r.Struct({\r\n  ascender: r.int8,\r\n  descender: r.int8,\r\n  widthMax: r.uint8,\r\n  caretSlopeNumerator: r.int8,\r\n  caretSlopeDenominator: r.int8,\r\n  caretOffset: r.int8,\r\n  minOriginSB: r.int8,\r\n  minAdvanceSB: r.int8,\r\n  maxBeforeBL: r.int8,\r\n  minAfterBL: r.int8,\r\n  pad: new r.Reserved(r.int8, 2)\r\n});\r\n\r\nlet CodeOffsetPair = new r.Struct({\r\n  glyphCode: r.uint16,\r\n  offset: r.uint16\r\n});\r\n\r\nlet IndexSubtable = new r.VersionedStruct(r.uint16, {\r\n  header: {\r\n    imageFormat: r.uint16,\r\n    imageDataOffset: r.uint32\r\n  },\r\n\r\n  1: {\r\n    offsetArray: new r.Array(r.uint32, t => t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1)\r\n  },\r\n\r\n  2: {\r\n    imageSize: r.uint32,\r\n    bigMetrics: BigMetrics\r\n  },\r\n\r\n  3: {\r\n    offsetArray: new r.Array(r.uint16, t => t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1)\r\n  },\r\n\r\n  4: {\r\n    numGlyphs: r.uint32,\r\n    glyphArray: new r.Array(CodeOffsetPair, t => t.numGlyphs + 1)\r\n  },\r\n\r\n  5: {\r\n    imageSize: r.uint32,\r\n    bigMetrics: BigMetrics,\r\n    numGlyphs: r.uint32,\r\n    glyphCodeArray: new r.Array(r.uint16, 'numGlyphs')\r\n  }\r\n});\r\n\r\nlet IndexSubtableArray = new r.Struct({\r\n  firstGlyphIndex: r.uint16,\r\n  lastGlyphIndex: r.uint16,\r\n  subtable: new r.Pointer(r.uint32, IndexSubtable)\r\n});\r\n\r\nlet BitmapSizeTable = new r.Struct({\r\n  indexSubTableArray: new r.Pointer(r.uint32, new r.Array(IndexSubtableArray, 1), { type: 'parent' }),\r\n  indexTablesSize: r.uint32,\r\n  numberOfIndexSubTables: r.uint32,\r\n  colorRef: r.uint32,\r\n  hori: SBitLineMetrics,\r\n  vert: SBitLineMetrics,\r\n  startGlyphIndex: r.uint16,\r\n  endGlyphIndex: r.uint16,\r\n  ppemX: r.uint8,\r\n  ppemY: r.uint8,\r\n  bitDepth: r.uint8,\r\n  flags: new r.Bitfield(r.uint8, ['horizontal', 'vertical'])\r\n});\r\n\r\nexport default new r.Struct({\r\n  version:  r.uint32, // 0x00020000\r\n  numSizes: r.uint32,\r\n  sizes:    new r.Array(BitmapSizeTable, 'numSizes')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet ImageTable = new r.Struct({\r\n  ppem: r.uint16,\r\n  resolution: r.uint16,\r\n  imageOffsets: new r.Array(new r.Pointer(r.uint32, 'void'), t => t.parent.parent.maxp.numGlyphs + 1)\r\n});\r\n\r\n// This is the Apple sbix table, used by the \"Apple Color Emoji\" font.\r\n// It includes several image tables with images for each bitmap glyph\r\n// of several different sizes.\r\nexport default new r.Struct({\r\n  version: r.uint16,\r\n  flags: new r.Bitfield(r.uint16, ['renderOutlines']),\r\n  numImgTables: r.uint32,\r\n  imageTables: new r.Array(new r.Pointer(r.uint32, ImageTable), 'numImgTables')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet LayerRecord = new r.Struct({\r\n  gid: r.uint16,          // Glyph ID of layer glyph (must be in z-order from bottom to top).\r\n  paletteIndex: r.uint16  // Index value to use in the appropriate palette. This value must\r\n});                       // be less than numPaletteEntries in the CPAL table, except for\r\n                          // the special case noted below. Each palette entry is 16 bits.\r\n                          // A palette index of 0xFFFF is a special case indicating that\r\n                          // the text foreground color should be used.\r\n\r\nlet BaseGlyphRecord = new r.Struct({\r\n  gid: r.uint16,             // Glyph ID of reference glyph. This glyph is for reference only\r\n                             // and is not rendered for color.\r\n  firstLayerIndex: r.uint16, // Index (from beginning of the Layer Records) to the layer record.\r\n                             // There will be numLayers consecutive entries for this base glyph.\r\n  numLayers: r.uint16\r\n});\r\n\r\nexport default new r.Struct({\r\n  version: r.uint16,\r\n  numBaseGlyphRecords: r.uint16,\r\n  baseGlyphRecord: new r.Pointer(r.uint32, new r.Array(BaseGlyphRecord, 'numBaseGlyphRecords')),\r\n  layerRecords: new r.Pointer(r.uint32, new r.Array(LayerRecord, 'numLayerRecords'), { lazy: true }),\r\n  numLayerRecords: r.uint16\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet ColorRecord = new r.Struct({\r\n  blue: r.uint8,\r\n  green: r.uint8,\r\n  red: r.uint8,\r\n  alpha: r.uint8\r\n});\r\n\r\nexport default new r.VersionedStruct(r.uint16, {\r\n  header: {\r\n    numPaletteEntries: r.uint16,\r\n    numPalettes: r.uint16,\r\n    numColorRecords: r.uint16,\r\n    colorRecords: new r.Pointer(r.uint32, new r.Array(ColorRecord, 'numColorRecords')),\r\n    colorRecordIndices: new r.Array(r.uint16, 'numPalettes'),\r\n  },\r\n  0: {},\r\n  1: {\r\n    offsetPaletteTypeArray: new r.Pointer(r.uint32, new r.Array(r.uint32, 'numPalettes')),\r\n    offsetPaletteLabelArray: new r.Pointer(r.uint32, new r.Array(r.uint16, 'numPalettes')),\r\n    offsetPaletteEntryLabelArray: new r.Pointer(r.uint32, new r.Array(r.uint16, 'numPaletteEntries'))\r\n  }\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\nimport {ScriptList, FeatureList, LookupList, Coverage, ClassDef, Device} from './opentype';\r\nimport {ItemVariationStore} from './variations';\r\n\r\nlet BaseCoord = new r.VersionedStruct(r.uint16, {\r\n  1: { // Design units only\r\n    coordinate:   r.int16 // X or Y value, in design units\r\n  },\r\n\r\n  2: { // Design units plus contour point\r\n    coordinate:     r.int16,   // X or Y value, in design units\r\n    referenceGlyph: r.uint16,  // GlyphID of control glyph\r\n    baseCoordPoint: r.uint16   // Index of contour point on the referenceGlyph\r\n  },\r\n\r\n  3: { // Design units plus Device table\r\n    coordinate:   r.int16,                         // X or Y value, in design units\r\n    deviceTable:  new r.Pointer(r.uint16, Device)  // Device table for X or Y value\r\n  }\r\n});\r\n\r\nlet BaseValues = new r.Struct({\r\n  defaultIndex:   r.uint16,  // Index of default baseline for this script-same index in the BaseTagList\r\n  baseCoordCount: r.uint16,\r\n  baseCoords:     new r.Array(new r.Pointer(r.uint16, BaseCoord), 'baseCoordCount')\r\n});\r\n\r\nlet FeatMinMaxRecord = new r.Struct({\r\n  tag:        new r.String(4),  // 4-byte feature identification tag-must match FeatureTag in FeatureList\r\n  minCoord:   new r.Pointer(r.uint16, BaseCoord, {type: 'parent'}), // May be NULL\r\n  maxCoord:   new r.Pointer(r.uint16, BaseCoord, {type: 'parent'})  // May be NULL\r\n});\r\n\r\nlet MinMax = new r.Struct({\r\n  minCoord:           new r.Pointer(r.uint16, BaseCoord),  // May be NULL\r\n  maxCoord:           new r.Pointer(r.uint16, BaseCoord),  // May be NULL\r\n  featMinMaxCount:    r.uint16,                            // May be 0\r\n  featMinMaxRecords:  new r.Array(FeatMinMaxRecord, 'featMinMaxCount') // In alphabetical order\r\n});\r\n\r\nlet BaseLangSysRecord = new r.Struct({\r\n  tag:    new r.String(4),  // 4-byte language system identification tag\r\n  minMax: new r.Pointer(r.uint16, MinMax, {type: 'parent'})\r\n});\r\n\r\nlet BaseScript = new r.Struct({\r\n  baseValues:         new r.Pointer(r.uint16, BaseValues), // May be NULL\r\n  defaultMinMax:      new r.Pointer(r.uint16, MinMax),     // May be NULL\r\n  baseLangSysCount:   r.uint16,                            // May be 0\r\n  baseLangSysRecords: new r.Array(BaseLangSysRecord, 'baseLangSysCount') // in alphabetical order by BaseLangSysTag\r\n});\r\n\r\nlet BaseScriptRecord = new r.Struct({\r\n  tag:      new r.String(4),  // 4-byte script identification tag\r\n  script:   new r.Pointer(r.uint16, BaseScript, {type: 'parent'})\r\n});\r\n\r\nlet BaseScriptList = new r.Array(BaseScriptRecord, r.uint16);\r\n\r\n// Array of 4-byte baseline identification tags-must be in alphabetical order\r\nlet BaseTagList = new r.Array(new r.String(4), r.uint16);\r\n\r\nlet Axis = new r.Struct({\r\n  baseTagList:    new r.Pointer(r.uint16, BaseTagList),  // May be NULL\r\n  baseScriptList: new r.Pointer(r.uint16, BaseScriptList)\r\n});\r\n\r\nexport default new r.VersionedStruct(r.uint32, {\r\n  header: {\r\n    horizAxis:    new r.Pointer(r.uint16, Axis),   // May be NULL\r\n    vertAxis:     new r.Pointer(r.uint16, Axis)    // May be NULL\r\n  },\r\n\r\n  0x00010000: {},\r\n  0x00010001: {\r\n    itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore)\r\n  }\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\nimport {ScriptList, FeatureList, LookupList, Coverage, ClassDef, Device} from './opentype';\r\nimport {ItemVariationStore} from './variations';\r\n\r\nlet AttachPoint = new r.Array(r.uint16, r.uint16);\r\nlet AttachList = new r.Struct({\r\n  coverage:       new r.Pointer(r.uint16, Coverage),\r\n  glyphCount:     r.uint16,\r\n  attachPoints:   new r.Array(new r.Pointer(r.uint16, AttachPoint), 'glyphCount')\r\n});\r\n\r\nlet CaretValue = new r.VersionedStruct(r.uint16, {\r\n  1: { // Design units only\r\n    coordinate: r.int16\r\n  },\r\n\r\n  2: { // Contour point\r\n    caretValuePoint: r.uint16\r\n  },\r\n\r\n  3: { // Design units plus Device table\r\n    coordinate:     r.int16,\r\n    deviceTable:    new r.Pointer(r.uint16, Device)\r\n  }\r\n});\r\n\r\nlet LigGlyph = new r.Array(new r.Pointer(r.uint16, CaretValue), r.uint16);\r\n\r\nlet LigCaretList = new r.Struct({\r\n  coverage:       new r.Pointer(r.uint16, Coverage),\r\n  ligGlyphCount:  r.uint16,\r\n  ligGlyphs:      new r.Array(new r.Pointer(r.uint16, LigGlyph), 'ligGlyphCount')\r\n});\r\n\r\nlet MarkGlyphSetsDef = new r.Struct({\r\n  markSetTableFormat: r.uint16,\r\n  markSetCount:       r.uint16,\r\n  coverage:           new r.Array(new r.Pointer(r.uint32, Coverage), 'markSetCount')\r\n});\r\n\r\nexport default new r.VersionedStruct(r.uint32, {\r\n  header: {\r\n    glyphClassDef:      new r.Pointer(r.uint16, ClassDef),\r\n    attachList:         new r.Pointer(r.uint16, AttachList),\r\n    ligCaretList:       new r.Pointer(r.uint16, LigCaretList),\r\n    markAttachClassDef: new r.Pointer(r.uint16, ClassDef)\r\n  },\r\n\r\n  0x00010000: {},\r\n  0x00010002: {\r\n    markGlyphSetsDef:   new r.Pointer(r.uint16, MarkGlyphSetsDef)\r\n  },\r\n  0x00010003: {\r\n    markGlyphSetsDef:   new r.Pointer(r.uint16, MarkGlyphSetsDef),\r\n    itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore)\r\n  }\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\nimport {ScriptList, FeatureList, LookupList, Coverage, ClassDef, Device, Context, ChainingContext} from './opentype';\r\nimport {FeatureVariations} from './variations';\r\n\r\nlet ValueFormat = new r.Bitfield(r.uint16, [\r\n  'xPlacement', 'yPlacement',\r\n  'xAdvance', 'yAdvance',\r\n  'xPlaDevice', 'yPlaDevice',\r\n  'xAdvDevice', 'yAdvDevice'\r\n]);\r\n\r\nlet types = {\r\n  xPlacement: r.int16,\r\n  yPlacement: r.int16,\r\n  xAdvance:   r.int16,\r\n  yAdvance:   r.int16,\r\n  xPlaDevice: new r.Pointer(r.uint16, Device, { type: 'global', relativeTo: ctx => ctx.rel }),\r\n  yPlaDevice: new r.Pointer(r.uint16, Device, { type: 'global', relativeTo: ctx => ctx.rel }),\r\n  xAdvDevice: new r.Pointer(r.uint16, Device, { type: 'global', relativeTo: ctx => ctx.rel }),\r\n  yAdvDevice: new r.Pointer(r.uint16, Device, { type: 'global', relativeTo: ctx => ctx.rel })\r\n};\r\n\r\nclass ValueRecord {\r\n  constructor(key = 'valueFormat') {\r\n    this.key = key;\r\n  }\r\n\r\n  buildStruct(parent) {\r\n    let struct = parent;\r\n    while (!struct[this.key] && struct.parent) {\r\n      struct = struct.parent;\r\n    }\r\n\r\n    if (!struct[this.key]) return;\r\n\r\n    let fields = {};\r\n    fields.rel = () => struct._startOffset;\r\n\r\n    let format = struct[this.key];\r\n    for (let key in format) {\r\n      if (format[key]) {\r\n        fields[key] = types[key];\r\n      }\r\n    }\r\n\r\n    return new r.Struct(fields);\r\n  }\r\n\r\n  size(val, ctx) {\r\n    return this.buildStruct(ctx).size(val, ctx);\r\n  }\r\n\r\n  decode(stream, parent) {\r\n    let res = this.buildStruct(parent).decode(stream, parent);\r\n    delete res.rel;\r\n    return res;\r\n  }\r\n}\r\n\r\nlet PairValueRecord = new r.Struct({\r\n  secondGlyph:    r.uint16,\r\n  value1:         new ValueRecord('valueFormat1'),\r\n  value2:         new ValueRecord('valueFormat2')\r\n});\r\n\r\nlet PairSet = new r.Array(PairValueRecord, r.uint16);\r\n\r\nlet Class2Record = new r.Struct({\r\n  value1: new ValueRecord('valueFormat1'),\r\n  value2: new ValueRecord('valueFormat2')\r\n});\r\n\r\nlet Anchor = new r.VersionedStruct(r.uint16, {\r\n  1: { // Design units only\r\n    xCoordinate:    r.int16,\r\n    yCoordinate:    r.int16\r\n  },\r\n\r\n  2: { // Design units plus contour point\r\n    xCoordinate:    r.int16,\r\n    yCoordinate:    r.int16,\r\n    anchorPoint:    r.uint16\r\n  },\r\n\r\n  3: { // Design units plus Device tables\r\n    xCoordinate:    r.int16,\r\n    yCoordinate:    r.int16,\r\n    xDeviceTable:   new r.Pointer(r.uint16, Device),\r\n    yDeviceTable:   new r.Pointer(r.uint16, Device)\r\n  }\r\n});\r\n\r\nlet EntryExitRecord = new r.Struct({\r\n  entryAnchor:    new r.Pointer(r.uint16, Anchor, {type: 'parent'}),\r\n  exitAnchor:     new r.Pointer(r.uint16, Anchor, {type: 'parent'})\r\n});\r\n\r\nlet MarkRecord = new r.Struct({\r\n  class:      r.uint16,\r\n  markAnchor: new r.Pointer(r.uint16, Anchor, {type: 'parent'})\r\n});\r\n\r\nlet MarkArray = new r.Array(MarkRecord, r.uint16);\r\n\r\nlet BaseRecord  = new r.Array(new r.Pointer(r.uint16, Anchor), t => t.parent.classCount);\r\nlet BaseArray   = new r.Array(BaseRecord, r.uint16);\r\n\r\nlet ComponentRecord = new r.Array(new r.Pointer(r.uint16, Anchor), t => t.parent.parent.classCount);\r\nlet LigatureAttach  = new r.Array(ComponentRecord, r.uint16);\r\nlet LigatureArray   = new r.Array(new r.Pointer(r.uint16, LigatureAttach), r.uint16);\r\n\r\nlet GPOSLookup = new r.VersionedStruct('lookupType', {\r\n  1: new r.VersionedStruct(r.uint16, { // Single Adjustment\r\n    1: { // Single positioning value\r\n      coverage:       new r.Pointer(r.uint16, Coverage),\r\n      valueFormat:    ValueFormat,\r\n      value:          new ValueRecord()\r\n    },\r\n    2: {\r\n      coverage:       new r.Pointer(r.uint16, Coverage),\r\n      valueFormat:    ValueFormat,\r\n      valueCount:     r.uint16,\r\n      values:         new r.LazyArray(new ValueRecord(), 'valueCount')\r\n    }\r\n  }),\r\n\r\n  2: new r.VersionedStruct(r.uint16, { // Pair Adjustment Positioning\r\n    1: { // Adjustments for glyph pairs\r\n      coverage:       new r.Pointer(r.uint16, Coverage),\r\n      valueFormat1:   ValueFormat,\r\n      valueFormat2:   ValueFormat,\r\n      pairSetCount:   r.uint16,\r\n      pairSets:       new r.LazyArray(new r.Pointer(r.uint16, PairSet), 'pairSetCount')\r\n    },\r\n\r\n    2: { // Class pair adjustment\r\n      coverage:       new r.Pointer(r.uint16, Coverage),\r\n      valueFormat1:   ValueFormat,\r\n      valueFormat2:   ValueFormat,\r\n      classDef1:      new r.Pointer(r.uint16, ClassDef),\r\n      classDef2:      new r.Pointer(r.uint16, ClassDef),\r\n      class1Count:    r.uint16,\r\n      class2Count:    r.uint16,\r\n      classRecords:   new r.LazyArray(new r.LazyArray(Class2Record, 'class2Count'), 'class1Count')\r\n    }\r\n  }),\r\n\r\n  3: { // Cursive Attachment Positioning\r\n    format:             r.uint16,\r\n    coverage:           new r.Pointer(r.uint16, Coverage),\r\n    entryExitCount:     r.uint16,\r\n    entryExitRecords:   new r.Array(EntryExitRecord, 'entryExitCount')\r\n  },\r\n\r\n  4: { // MarkToBase Attachment Positioning\r\n    format:             r.uint16,\r\n    markCoverage:       new r.Pointer(r.uint16, Coverage),\r\n    baseCoverage:       new r.Pointer(r.uint16, Coverage),\r\n    classCount:         r.uint16,\r\n    markArray:          new r.Pointer(r.uint16, MarkArray),\r\n    baseArray:          new r.Pointer(r.uint16, BaseArray)\r\n  },\r\n\r\n  5: { // MarkToLigature Attachment Positioning\r\n    format:             r.uint16,\r\n    markCoverage:       new r.Pointer(r.uint16, Coverage),\r\n    ligatureCoverage:   new r.Pointer(r.uint16, Coverage),\r\n    classCount:         r.uint16,\r\n    markArray:          new r.Pointer(r.uint16, MarkArray),\r\n    ligatureArray:      new r.Pointer(r.uint16, LigatureArray)\r\n  },\r\n\r\n  6: { // MarkToMark Attachment Positioning\r\n    format:             r.uint16,\r\n    mark1Coverage:      new r.Pointer(r.uint16, Coverage),\r\n    mark2Coverage:      new r.Pointer(r.uint16, Coverage),\r\n    classCount:         r.uint16,\r\n    mark1Array:         new r.Pointer(r.uint16, MarkArray),\r\n    mark2Array:         new r.Pointer(r.uint16, BaseArray)\r\n  },\r\n\r\n  7: Context,          // Contextual positioning\r\n  8: ChainingContext,  // Chaining contextual positioning\r\n\r\n  9: { // Extension Positioning\r\n    posFormat:   r.uint16,\r\n    lookupType:  r.uint16,   // cannot also be 9\r\n    extension:   new r.Pointer(r.uint32, GPOSLookup)\r\n  }\r\n});\r\n\r\n// Fix circular reference\r\nGPOSLookup.versions[9].extension.type = GPOSLookup;\r\n\r\nexport default new r.VersionedStruct(r.uint32, {\r\n  header: {\r\n    scriptList:     new r.Pointer(r.uint16, ScriptList),\r\n    featureList:    new r.Pointer(r.uint16, FeatureList),\r\n    lookupList:     new r.Pointer(r.uint16, new LookupList(GPOSLookup))\r\n  },\r\n\r\n  0x00010000: {},\r\n  0x00010001: {\r\n    featureVariations: new r.Pointer(r.uint32, FeatureVariations)\r\n  }\r\n});\r\n\r\n// export GPOSLookup for JSTF table\r\nexport { GPOSLookup };\r\n","import r from '@foliojs-fork/restructure';\r\nimport {ScriptList, FeatureList, LookupList, Coverage, ClassDef, Device, Context, ChainingContext} from './opentype';\r\nimport {FeatureVariations} from './variations';\r\n\r\nlet Sequence = new r.Array(r.uint16, r.uint16);\r\nlet AlternateSet = Sequence;\r\n\r\nlet Ligature = new r.Struct({\r\n  glyph:      r.uint16,\r\n  compCount:  r.uint16,\r\n  components: new r.Array(r.uint16, t => t.compCount - 1)\r\n});\r\n\r\nlet LigatureSet = new r.Array(new r.Pointer(r.uint16, Ligature), r.uint16);\r\n\r\nlet GSUBLookup = new r.VersionedStruct('lookupType', {\r\n  1: new r.VersionedStruct(r.uint16, {// Single Substitution\r\n    1: {\r\n      coverage:       new r.Pointer(r.uint16, Coverage),\r\n      deltaGlyphID:   r.int16\r\n    },\r\n    2: {\r\n      coverage:       new r.Pointer(r.uint16, Coverage),\r\n      glyphCount:     r.uint16,\r\n      substitute:     new r.LazyArray(r.uint16, 'glyphCount')\r\n    }\r\n  }),\r\n\r\n  2: { // Multiple Substitution\r\n    substFormat:    r.uint16,\r\n    coverage:       new r.Pointer(r.uint16, Coverage),\r\n    count:          r.uint16,\r\n    sequences:      new r.LazyArray(new r.Pointer(r.uint16, Sequence), 'count')\r\n  },\r\n\r\n  3: { // Alternate Substitution\r\n    substFormat:    r.uint16,\r\n    coverage:       new r.Pointer(r.uint16, Coverage),\r\n    count:          r.uint16,\r\n    alternateSet:   new r.LazyArray(new r.Pointer(r.uint16, AlternateSet), 'count')\r\n  },\r\n\r\n  4: { // Ligature Substitution\r\n    substFormat:    r.uint16,\r\n    coverage:       new r.Pointer(r.uint16, Coverage),\r\n    count:          r.uint16,\r\n    ligatureSets:   new r.LazyArray(new r.Pointer(r.uint16, LigatureSet), 'count')\r\n  },\r\n\r\n  5: Context,         // Contextual Substitution\r\n  6: ChainingContext, // Chaining Contextual Substitution\r\n\r\n  7: { // Extension Substitution\r\n    substFormat:   r.uint16,\r\n    lookupType:    r.uint16,   // cannot also be 7\r\n    extension:     new r.Pointer(r.uint32, GSUBLookup)\r\n  },\r\n\r\n  8: { // Reverse Chaining Contextual Single Substitution\r\n    substFormat:            r.uint16,\r\n    coverage:               new r.Pointer(r.uint16, Coverage),\r\n    backtrackCoverage:      new r.Array(new r.Pointer(r.uint16, Coverage), 'backtrackGlyphCount'),\r\n    lookaheadGlyphCount:    r.uint16,\r\n    lookaheadCoverage:      new r.Array(new r.Pointer(r.uint16, Coverage), 'lookaheadGlyphCount'),\r\n    glyphCount:             r.uint16,\r\n    substitutes:            new r.Array(r.uint16, 'glyphCount')\r\n  }\r\n});\r\n\r\n// Fix circular reference\r\nGSUBLookup.versions[7].extension.type = GSUBLookup;\r\n\r\nexport default new r.VersionedStruct(r.uint32, {\r\n  header: {\r\n    scriptList:     new r.Pointer(r.uint16, ScriptList),\r\n    featureList:    new r.Pointer(r.uint16, FeatureList),\r\n    lookupList:     new r.Pointer(r.uint16, new LookupList(GSUBLookup))\r\n  },\r\n\r\n  0x00010000: {},\r\n  0x00010001: {\r\n    featureVariations: new r.Pointer(r.uint32, FeatureVariations)\r\n  }\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\nimport { ScriptList, FeatureList, LookupList, Coverage, ClassDef, Device } from './opentype';\r\nimport { GPOSLookup } from './GPOS';\r\n\r\nlet JstfGSUBModList = new r.Array(r.uint16, r.uint16);\r\n\r\nlet JstfPriority = new r.Struct({\r\n  shrinkageEnableGSUB:    new r.Pointer(r.uint16, JstfGSUBModList),\r\n  shrinkageDisableGSUB:   new r.Pointer(r.uint16, JstfGSUBModList),\r\n  shrinkageEnableGPOS:    new r.Pointer(r.uint16, JstfGSUBModList),\r\n  shrinkageDisableGPOS:   new r.Pointer(r.uint16, JstfGSUBModList),\r\n  shrinkageJstfMax:       new r.Pointer(r.uint16, new LookupList(GPOSLookup)),\r\n  extensionEnableGSUB:    new r.Pointer(r.uint16, JstfGSUBModList),\r\n  extensionDisableGSUB:   new r.Pointer(r.uint16, JstfGSUBModList),\r\n  extensionEnableGPOS:    new r.Pointer(r.uint16, JstfGSUBModList),\r\n  extensionDisableGPOS:   new r.Pointer(r.uint16, JstfGSUBModList),\r\n  extensionJstfMax:       new r.Pointer(r.uint16, new LookupList(GPOSLookup))\r\n});\r\n\r\nlet JstfLangSys = new r.Array(new r.Pointer(r.uint16, JstfPriority), r.uint16);\r\n\r\nlet JstfLangSysRecord = new r.Struct({\r\n  tag:         new r.String(4),\r\n  jstfLangSys: new r.Pointer(r.uint16, JstfLangSys)\r\n});\r\n\r\nlet JstfScript = new r.Struct({\r\n  extenderGlyphs: new r.Pointer(r.uint16, new r.Array(r.uint16, r.uint16)), // array of glyphs to extend line length\r\n  defaultLangSys: new r.Pointer(r.uint16, JstfLangSys),\r\n  langSysCount:   r.uint16,\r\n  langSysRecords: new r.Array(JstfLangSysRecord, 'langSysCount')\r\n});\r\n\r\nlet JstfScriptRecord = new r.Struct({\r\n  tag:    new r.String(4),\r\n  script: new r.Pointer(r.uint16, JstfScript, {type: 'parent'})\r\n});\r\n\r\nexport default new r.Struct({\r\n  version:     r.uint32,  // should be 0x00010000\r\n  scriptCount: r.uint16,\r\n  scriptList:  new r.Array(JstfScriptRecord, 'scriptCount')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\nimport {resolveLength} from '@foliojs-fork/restructure/src/utils';\r\nimport {ItemVariationStore} from './variations';\r\n\r\n// TODO: add this to restructure\r\nclass VariableSizeNumber {\r\n  constructor(size) {\r\n    this._size = size;\r\n  }\r\n\r\n  decode(stream, parent) {\r\n    switch (this.size(0, parent)) {\r\n      case 1: return stream.readUInt8();\r\n      case 2: return stream.readUInt16BE();\r\n      case 3: return stream.readUInt24BE();\r\n      case 4: return stream.readUInt32BE();\r\n    }\r\n  }\r\n\r\n  size(val, parent) {\r\n    return resolveLength(this._size, null, parent);\r\n  }\r\n}\r\n\r\nlet MapDataEntry = new r.Struct({\r\n  entry: new VariableSizeNumber(t => ((t.parent.entryFormat & 0x0030) >> 4) + 1),\r\n  outerIndex: t => t.entry >> ((t.parent.entryFormat & 0x000F) + 1),\r\n  innerIndex: t => t.entry & ((1 << ((t.parent.entryFormat & 0x000F) + 1)) - 1)\r\n});\r\n\r\nlet DeltaSetIndexMap = new r.Struct({\r\n  entryFormat: r.uint16,\r\n  mapCount: r.uint16,\r\n  mapData: new r.Array(MapDataEntry, 'mapCount')\r\n});\r\n\r\nexport default new r.Struct({\r\n  majorVersion: r.uint16,\r\n  minorVersion: r.uint16,\r\n  itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore),\r\n  advanceWidthMapping: new r.Pointer(r.uint32, DeltaSetIndexMap),\r\n  LSBMapping: new r.Pointer(r.uint32, DeltaSetIndexMap),\r\n  RSBMapping: new r.Pointer(r.uint32, DeltaSetIndexMap)\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet Signature = new r.Struct({\r\n  format: r.uint32,\r\n  length: r.uint32,\r\n  offset: r.uint32\r\n});\r\n\r\nlet SignatureBlock = new r.Struct({\r\n  reserved:       new r.Reserved(r.uint16, 2),\r\n  cbSignature:    r.uint32,  // Length (in bytes) of the PKCS#7 packet in pbSignature\r\n  signature:      new r.Buffer('cbSignature')\r\n});\r\n\r\nexport default new r.Struct({\r\n  ulVersion:       r.uint32,  // Version number of the DSIG table (0x00000001)\r\n  usNumSigs:       r.uint16,  // Number of signatures in the table\r\n  usFlag:          r.uint16,  // Permission flags\r\n  signatures:      new r.Array(Signature, 'usNumSigs'),\r\n  signatureBlocks: new r.Array(SignatureBlock, 'usNumSigs')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet GaspRange = new r.Struct({\r\n  rangeMaxPPEM:       r.uint16,                  // Upper limit of range, in ppem\r\n  rangeGaspBehavior:  new r.Bitfield(r.uint16, [ // Flags describing desired rasterizer behavior\r\n    'grayscale', 'gridfit',\r\n    'symmetricSmoothing', 'symmetricGridfit'     // only in version 1, for ClearType\r\n  ])\r\n});\r\n\r\nexport default new r.Struct({\r\n  version:    r.uint16,  // set to 0\r\n  numRanges:  r.uint16,\r\n  gaspRanges: new r.Array(GaspRange, 'numRanges') // Sorted by ppem\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet DeviceRecord = new r.Struct({\r\n  pixelSize:      r.uint8,\r\n  maximumWidth:   r.uint8,\r\n  widths:         new r.Array(r.uint8, t => t.parent.parent.maxp.numGlyphs)\r\n});\r\n\r\n// The Horizontal Device Metrics table stores integer advance widths scaled to particular pixel sizes\r\nexport default new r.Struct({\r\n  version:            r.uint16,\r\n  numRecords:         r.int16,\r\n  sizeDeviceRecord:   r.int32,\r\n  records:            new r.Array(DeviceRecord, 'numRecords')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet KernPair = new r.Struct({\r\n  left:   r.uint16,\r\n  right:  r.uint16,\r\n  value:  r.int16\r\n});\r\n\r\nlet ClassTable = new r.Struct({\r\n  firstGlyph: r.uint16,\r\n  nGlyphs: r.uint16,\r\n  offsets: new r.Array(r.uint16, 'nGlyphs'),\r\n  max: t => t.offsets.length && Math.max.apply(Math, t.offsets)\r\n});\r\n\r\nlet Kern2Array = new r.Struct({\r\n  off: t => t._startOffset - t.parent.parent._startOffset,\r\n  len: t => (((t.parent.leftTable.max - t.off) / t.parent.rowWidth) + 1) * (t.parent.rowWidth / 2),\r\n  values: new r.LazyArray(r.int16, 'len')\r\n});\r\n\r\nlet KernSubtable = new r.VersionedStruct('format', {\r\n  0: {\r\n    nPairs:         r.uint16,\r\n    searchRange:    r.uint16,\r\n    entrySelector:  r.uint16,\r\n    rangeShift:     r.uint16,\r\n    pairs:          new r.Array(KernPair, 'nPairs')\r\n  },\r\n\r\n  2: {\r\n    rowWidth:   r.uint16,\r\n    leftTable:  new r.Pointer(r.uint16, ClassTable, {type: 'parent'}),\r\n    rightTable: new r.Pointer(r.uint16, ClassTable, {type: 'parent'}),\r\n    array:      new r.Pointer(r.uint16, Kern2Array, {type: 'parent'})\r\n  },\r\n\r\n  3: {\r\n    glyphCount:       r.uint16,\r\n    kernValueCount:   r.uint8,\r\n    leftClassCount:   r.uint8,\r\n    rightClassCount:  r.uint8,\r\n    flags:            r.uint8,\r\n    kernValue:        new r.Array(r.int16, 'kernValueCount'),\r\n    leftClass:        new r.Array(r.uint8, 'glyphCount'),\r\n    rightClass:       new r.Array(r.uint8, 'glyphCount'),\r\n    kernIndex:        new r.Array(r.uint8, t => t.leftClassCount * t.rightClassCount)\r\n  }\r\n});\r\n\r\nlet KernTable = new r.VersionedStruct('version', {\r\n  0: { // Microsoft uses this format\r\n    subVersion: r.uint16,  // Microsoft has an extra sub-table version number\r\n    length:     r.uint16,  // Length of the subtable, in bytes\r\n    format:     r.uint8,   // Format of subtable\r\n    coverage:   new r.Bitfield(r.uint8, [\r\n      'horizontal',    // 1 if table has horizontal data, 0 if vertical\r\n      'minimum',       // If set to 1, the table has minimum values. If set to 0, the table has kerning values.\r\n      'crossStream',   // If set to 1, kerning is perpendicular to the flow of the text\r\n      'override'      // If set to 1 the value in this table replaces the accumulated value\r\n    ]),\r\n    subtable:   KernSubtable,\r\n    padding: new r.Reserved(r.uint8, t => t.length - t._currentOffset)\r\n  },\r\n  1: { // Apple uses this format\r\n    length:     r.uint32,\r\n    coverage:   new r.Bitfield(r.uint8, [\r\n      null, null, null, null, null,\r\n      'variation',     // Set if table has variation kerning values\r\n      'crossStream',   // Set if table has cross-stream kerning values\r\n      'vertical'      // Set if table has vertical kerning values\r\n    ]),\r\n    format:     r.uint8,\r\n    tupleIndex: r.uint16,\r\n    subtable:   KernSubtable,\r\n    padding: new r.Reserved(r.uint8, t => t.length - t._currentOffset)\r\n  }\r\n});\r\n\r\nexport default new r.VersionedStruct(r.uint16, {\r\n  0: { // Microsoft Version\r\n    nTables:    r.uint16,\r\n    tables:     new r.Array(KernTable, 'nTables')\r\n  },\r\n\r\n  1: { // Apple Version\r\n    reserved:   new r.Reserved(r.uint16), // the other half of the version number\r\n    nTables:    r.uint32,\r\n    tables:     new r.Array(KernTable, 'nTables')\r\n  }\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// Linear Threshold table\r\n// Records the ppem for each glyph at which the scaling becomes linear again,\r\n// despite instructions effecting the advance width\r\nexport default new r.Struct({\r\n  version:    r.uint16,\r\n  numGlyphs:  r.uint16,\r\n  yPels:      new r.Array(r.uint8, 'numGlyphs')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// PCL 5 Table\r\n// NOTE: The PCLT table is strongly discouraged for OpenType fonts with TrueType outlines\r\nexport default new r.Struct({\r\n  version:              r.uint16,\r\n  fontNumber:           r.uint32,\r\n  pitch:                r.uint16,\r\n  xHeight:              r.uint16,\r\n  style:                r.uint16,\r\n  typeFamily:           r.uint16,\r\n  capHeight:            r.uint16,\r\n  symbolSet:            r.uint16,\r\n  typeface:             new r.String(16),\r\n  characterComplement:  new r.String(8),\r\n  fileName:             new r.String(6),\r\n  strokeWeight:         new r.String(1),\r\n  widthType:            new r.String(1),\r\n  serifStyle:           r.uint8,\r\n  reserved:             new r.Reserved(r.uint8)\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// VDMX tables contain ascender/descender overrides for certain (usually small)\r\n// sizes. This is needed in order to match font metrics on Windows.\r\n\r\nlet Ratio = new r.Struct({\r\n  bCharSet:       r.uint8,                             // Character set\r\n  xRatio:         r.uint8,                             // Value to use for x-Ratio\r\n  yStartRatio:    r.uint8,                             // Starting y-Ratio value\r\n  yEndRatio:      r.uint8                              // Ending y-Ratio value\r\n});\r\n\r\nlet vTable = new r.Struct({\r\n  yPelHeight:     r.uint16,                            // yPelHeight to which values apply\r\n  yMax:           r.int16,                             // Maximum value (in pels) for this yPelHeight\r\n  yMin:           r.int16                              // Minimum value (in pels) for this yPelHeight\r\n});\r\n\r\nlet VdmxGroup = new r.Struct({\r\n  recs:           r.uint16,                            // Number of height records in this group\r\n  startsz:        r.uint8,                             // Starting yPelHeight\r\n  endsz:          r.uint8,                             // Ending yPelHeight\r\n  entries:        new r.Array(vTable, 'recs')          // The VDMX records\r\n});\r\n\r\nexport default new r.Struct({\r\n  version:        r.uint16,                            // Version number (0 or 1)\r\n  numRecs:        r.uint16,                            // Number of VDMX groups present\r\n  numRatios:      r.uint16,                            // Number of aspect ratio groupings\r\n  ratioRanges:    new r.Array(Ratio, 'numRatios'),     // Ratio ranges\r\n  offsets:        new r.Array(r.uint16, 'numRatios'),  // Offset to the VDMX group for this ratio range\r\n  groups:         new r.Array(VdmxGroup, 'numRecs')    // The actual VDMX groupings\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// Vertical Header Table\r\nexport default new r.Struct({\r\n  version:                r.uint16,  // Version number of the Vertical Header Table\r\n  ascent:                 r.int16,   // The vertical typographic ascender for this font\r\n  descent:                r.int16,   // The vertical typographic descender for this font\r\n  lineGap:                r.int16,   // The vertical typographic line gap for this font\r\n  advanceHeightMax:       r.int16,   // The maximum advance height measurement found in the font\r\n  minTopSideBearing:      r.int16,   // The minimum top side bearing measurement found in the font\r\n  minBottomSideBearing:   r.int16,   // The minimum bottom side bearing measurement found in the font\r\n  yMaxExtent:             r.int16,\r\n  caretSlopeRise:         r.int16,   // Caret slope (rise/run)\r\n  caretSlopeRun:          r.int16,\r\n  caretOffset:            r.int16,   // Set value equal to 0 for nonslanted fonts\r\n  reserved:               new r.Reserved(r.int16, 4),\r\n  metricDataFormat:       r.int16,   // Set to 0\r\n  numberOfMetrics:        r.uint16   // Number of advance heights in the Vertical Metrics table\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet VmtxEntry = new r.Struct({\r\n  advance: r.uint16,  // The advance height of the glyph\r\n  bearing: r.int16    // The top sidebearing of the glyph\r\n});\r\n\r\n// Vertical Metrics Table\r\nexport default new r.Struct({\r\n  metrics:  new r.LazyArray(VmtxEntry, t => t.parent.vhea.numberOfMetrics),\r\n  bearings: new r.LazyArray(r.int16, t => t.parent.maxp.numGlyphs - t.parent.vhea.numberOfMetrics)\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet shortFrac = new r.Fixed(16, 'BE', 14);\r\n\r\nlet Correspondence = new r.Struct({\r\n  fromCoord: shortFrac,\r\n  toCoord: shortFrac\r\n});\r\n\r\nlet Segment = new r.Struct({\r\n  pairCount: r.uint16,\r\n  correspondence: new r.Array(Correspondence, 'pairCount')\r\n});\r\n\r\nexport default new r.Struct({\r\n  version: r.fixed32,\r\n  axisCount: r.uint32,\r\n  segment: new r.Array(Segment, 'axisCount')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nclass UnboundedArrayAccessor {\r\n  constructor(type, stream, parent) {\r\n    this.type = type;\r\n    this.stream = stream;\r\n    this.parent = parent;\r\n    this.base = this.stream.pos;\r\n    this._items = [];\r\n  }\r\n\r\n  getItem(index) {\r\n    if (this._items[index] == null) {\r\n      let pos = this.stream.pos;\r\n      this.stream.pos = this.base + this.type.size(null, this.parent) * index;\r\n      this._items[index] = this.type.decode(this.stream, this.parent);\r\n      this.stream.pos = pos;\r\n    }\r\n\r\n    return this._items[index];\r\n  }\r\n\r\n  inspect() {\r\n    return `[UnboundedArray ${this.type.constructor.name}]`;\r\n  }\r\n}\r\n\r\nexport class UnboundedArray extends r.Array {\r\n  constructor(type) {\r\n    super(type, 0);\r\n  }\r\n\r\n  decode(stream, parent) {\r\n    return new UnboundedArrayAccessor(this.type, stream, parent);\r\n  }\r\n}\r\n\r\nexport let LookupTable = function(ValueType = r.uint16) {\r\n  // Helper class that makes internal structures invisible to pointers\r\n  class Shadow {\r\n    constructor(type) {\r\n      this.type = type;\r\n    }\r\n\r\n    decode(stream, ctx) {\r\n      ctx = ctx.parent.parent;\r\n      return this.type.decode(stream, ctx);\r\n    }\r\n\r\n    size(val, ctx) {\r\n      ctx = ctx.parent.parent;\r\n      return this.type.size(val, ctx);\r\n    }\r\n\r\n    encode(stream, val, ctx) {\r\n      ctx = ctx.parent.parent;\r\n      return this.type.encode(stream, val, ctx);\r\n    }\r\n  }\r\n\r\n  ValueType = new Shadow(ValueType);\r\n\r\n  let BinarySearchHeader = new r.Struct({\r\n    unitSize: r.uint16,\r\n    nUnits: r.uint16,\r\n    searchRange: r.uint16,\r\n    entrySelector: r.uint16,\r\n    rangeShift: r.uint16\r\n  });\r\n\r\n  let LookupSegmentSingle = new r.Struct({\r\n    lastGlyph: r.uint16,\r\n    firstGlyph: r.uint16,\r\n    value: ValueType\r\n  });\r\n\r\n  let LookupSegmentArray = new r.Struct({\r\n    lastGlyph: r.uint16,\r\n    firstGlyph: r.uint16,\r\n    values: new r.Pointer(r.uint16, new r.Array(ValueType, t => t.lastGlyph - t.firstGlyph + 1), {type: 'parent'})\r\n  });\r\n\r\n  let LookupSingle = new r.Struct({\r\n    glyph: r.uint16,\r\n    value: ValueType\r\n  });\r\n\r\n  return new r.VersionedStruct(r.uint16, {\r\n    0: {\r\n      values: new UnboundedArray(ValueType) // length == number of glyphs maybe?\r\n    },\r\n    2: {\r\n      binarySearchHeader: BinarySearchHeader,\r\n      segments: new r.Array(LookupSegmentSingle, t => t.binarySearchHeader.nUnits)\r\n    },\r\n    4: {\r\n      binarySearchHeader: BinarySearchHeader,\r\n      segments: new r.Array(LookupSegmentArray, t => t.binarySearchHeader.nUnits)\r\n    },\r\n    6: {\r\n      binarySearchHeader: BinarySearchHeader,\r\n      segments: new r.Array(LookupSingle, t => t.binarySearchHeader.nUnits)\r\n    },\r\n    8: {\r\n      firstGlyph: r.uint16,\r\n      count: r.uint16,\r\n      values: new r.Array(ValueType, 'count')\r\n    }\r\n  });\r\n};\r\n\r\nexport function StateTable(entryData = {}, lookupType = r.uint16) {\r\n  let entry = Object.assign({\r\n    newState: r.uint16,\r\n    flags: r.uint16\r\n  }, entryData);\r\n\r\n  let Entry = new r.Struct(entry);\r\n  let StateArray = new UnboundedArray(new r.Array(r.uint16, t => t.nClasses));\r\n\r\n  let StateHeader = new r.Struct({\r\n    nClasses: r.uint32,\r\n    classTable: new r.Pointer(r.uint32, new LookupTable(lookupType)),\r\n    stateArray: new r.Pointer(r.uint32, StateArray),\r\n    entryTable: new r.Pointer(r.uint32, new UnboundedArray(Entry))\r\n  });\r\n\r\n  return StateHeader;\r\n}\r\n\r\n// This is the old version of the StateTable structure\r\nexport function StateTable1(entryData = {}, lookupType = r.uint16) {\r\n  let ClassLookupTable = new r.Struct({\r\n    version() { return 8; }, // simulate LookupTable\r\n    firstGlyph: r.uint16,\r\n    values: new r.Array(r.uint8, r.uint16)\r\n  });\r\n\r\n  let entry = Object.assign({\r\n    newStateOffset: r.uint16,\r\n    // convert offset to stateArray index\r\n    newState: t => (t.newStateOffset - (t.parent.stateArray.base - t.parent._startOffset)) / t.parent.nClasses,\r\n    flags: r.uint16\r\n  }, entryData);\r\n\r\n  let Entry = new r.Struct(entry);\r\n  let StateArray = new UnboundedArray(new r.Array(r.uint8, t => t.nClasses));\r\n\r\n  let StateHeader1 = new r.Struct({\r\n    nClasses: r.uint16,\r\n    classTable: new r.Pointer(r.uint16, ClassLookupTable),\r\n    stateArray: new r.Pointer(r.uint16, StateArray),\r\n    entryTable: new r.Pointer(r.uint16, new UnboundedArray(Entry))\r\n  });\r\n\r\n  return StateHeader1;\r\n}\r\n","import r from '@foliojs-fork/restructure';\r\nimport { LookupTable } from './aat';\r\n\r\nlet BslnSubtable = new r.VersionedStruct('format', {\r\n  0: { // Distance-based, no mapping\r\n    deltas: new r.Array(r.int16, 32)\r\n  },\r\n\r\n  1: { // Distance-based, with mapping\r\n    deltas: new r.Array(r.int16, 32),\r\n    mappingData: new LookupTable(r.uint16)\r\n  },\r\n\r\n  2: { // Control point-based, no mapping\r\n    standardGlyph: r.uint16,\r\n    controlPoints: new r.Array(r.uint16, 32)\r\n  },\r\n\r\n  3: { // Control point-based, with mapping\r\n    standardGlyph: r.uint16,\r\n    controlPoints: new r.Array(r.uint16, 32),\r\n    mappingData: new LookupTable(r.uint16)\r\n  }\r\n});\r\n\r\nexport default new r.Struct({\r\n  version: r.fixed32,\r\n  format: r.uint16,\r\n  defaultBaseline: r.uint16,\r\n  subtable: BslnSubtable\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet Setting = new r.Struct({\r\n  setting: r.uint16,\r\n  nameIndex: r.int16,\r\n  name: t => t.parent.parent.parent.name.records.fontFeatures[t.nameIndex]\r\n});\r\n\r\nlet FeatureName = new r.Struct({\r\n  feature: r.uint16,\r\n  nSettings: r.uint16,\r\n  settingTable: new r.Pointer(r.uint32, new r.Array(Setting, 'nSettings'), { type: 'parent' }),\r\n  featureFlags: new r.Bitfield(r.uint8, [\r\n    null, null, null, null, null, null,\r\n    'hasDefault', 'exclusive'\r\n  ]),\r\n  defaultSetting: r.uint8,\r\n  nameIndex: r.int16,\r\n  name: t => t.parent.parent.name.records.fontFeatures[t.nameIndex]\r\n});\r\n\r\nexport default new r.Struct({\r\n  version: r.fixed32,\r\n  featureNameCount: r.uint16,\r\n  reserved1: new r.Reserved(r.uint16),\r\n  reserved2: new r.Reserved(r.uint32),\r\n  featureNames: new r.Array(FeatureName, 'featureNameCount')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet Axis = new r.Struct({\r\n  axisTag: new r.String(4),\r\n  minValue: r.fixed32,\r\n  defaultValue: r.fixed32,\r\n  maxValue: r.fixed32,\r\n  flags: r.uint16,\r\n  nameID: r.uint16,\r\n  name: t => t.parent.parent.name.records.fontFeatures[t.nameID]\r\n});\r\n\r\nlet Instance = new r.Struct({\r\n  nameID: r.uint16,\r\n  name: t => t.parent.parent.name.records.fontFeatures[t.nameID],\r\n  flags: r.uint16,\r\n  coord: new r.Array(r.fixed32, t => t.parent.axisCount),\r\n  postscriptNameID: new r.Optional(r.uint16, t => t.parent.instanceSize - t._currentOffset > 0)\r\n});\r\n\r\nexport default new r.Struct({\r\n  version: r.fixed32,\r\n  offsetToData: r.uint16,\r\n  countSizePairs: r.uint16,\r\n  axisCount: r.uint16,\r\n  axisSize: r.uint16,\r\n  instanceCount: r.uint16,\r\n  instanceSize: r.uint16,\r\n  axis: new r.Array(Axis, 'axisCount'),\r\n  instance: new r.Array(Instance, 'instanceCount')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nlet shortFrac = new r.Fixed(16, 'BE', 14);\r\nclass Offset {\r\n  static decode(stream, parent) {\r\n    // In short format, offsets are multiplied by 2.\r\n    // This doesn't seem to be documented by Apple, but it\r\n    // is implemented this way in Freetype.\r\n    return parent.flags\r\n      ? stream.readUInt32BE()\r\n      : stream.readUInt16BE() * 2;\r\n  }\r\n}\r\n\r\nlet gvar = new r.Struct({\r\n  version: r.uint16,\r\n  reserved: new r.Reserved(r.uint16),\r\n  axisCount: r.uint16,\r\n  globalCoordCount: r.uint16,\r\n  globalCoords: new r.Pointer(r.uint32, new r.Array(new r.Array(shortFrac, 'axisCount'), 'globalCoordCount')),\r\n  glyphCount: r.uint16,\r\n  flags: r.uint16,\r\n  offsetToData: r.uint32,\r\n  offsets: new r.Array(new r.Pointer(Offset, 'void', { relativeTo: ctx => ctx.offsetToData, allowNull: false }), t => t.glyphCount + 1)\r\n});\r\n\r\nexport default gvar;\r\n","import r from '@foliojs-fork/restructure';\r\nimport { LookupTable, StateTable1 } from './aat';\r\n\r\nlet ClassTable = new r.Struct({\r\n  length: r.uint16,\r\n  coverage: r.uint16,\r\n  subFeatureFlags: r.uint32,\r\n  stateTable: new StateTable1\r\n});\r\n\r\nlet WidthDeltaRecord = new r.Struct({\r\n  justClass: r.uint32,\r\n  beforeGrowLimit: r.fixed32,\r\n  beforeShrinkLimit: r.fixed32,\r\n  afterGrowLimit: r.fixed32,\r\n  afterShrinkLimit: r.fixed32,\r\n  growFlags: r.uint16,\r\n  shrinkFlags: r.uint16\r\n});\r\n\r\nlet WidthDeltaCluster = new r.Array(WidthDeltaRecord, r.uint32);\r\n\r\nlet ActionData = new r.VersionedStruct('actionType', {\r\n  0: { // Decomposition action\r\n    lowerLimit: r.fixed32,\r\n    upperLimit: r.fixed32,\r\n    order: r.uint16,\r\n    glyphs: new r.Array(r.uint16, r.uint16)\r\n  },\r\n\r\n  1: { // Unconditional add glyph action\r\n    addGlyph: r.uint16\r\n  },\r\n\r\n  2: { // Conditional add glyph action\r\n    substThreshold: r.fixed32,\r\n    addGlyph: r.uint16,\r\n    substGlyph: r.uint16\r\n  },\r\n\r\n  3: {}, // Stretch glyph action (no data, not supported by CoreText)\r\n\r\n  4: { // Ductile glyph action (not supported by CoreText)\r\n    variationAxis: r.uint32,\r\n    minimumLimit: r.fixed32,\r\n    noStretchValue: r.fixed32,\r\n    maximumLimit: r.fixed32\r\n  },\r\n\r\n  5: { // Repeated add glyph action\r\n    flags: r.uint16,\r\n    glyph: r.uint16\r\n  }\r\n});\r\n\r\nlet Action = new r.Struct({\r\n  actionClass: r.uint16,\r\n  actionType: r.uint16,\r\n  actionLength: r.uint32,\r\n  actionData: ActionData,\r\n  padding: new r.Reserved(r.uint8, t => t.actionLength - t._currentOffset)\r\n});\r\n\r\nlet PostcompensationAction = new r.Array(Action, r.uint32);\r\nlet PostCompensationTable = new r.Struct({\r\n  lookupTable: new LookupTable(new r.Pointer(r.uint16, PostcompensationAction))\r\n});\r\n\r\nlet JustificationTable = new r.Struct({\r\n  classTable: new r.Pointer(r.uint16, ClassTable, { type: 'parent' }),\r\n  wdcOffset: r.uint16,\r\n  postCompensationTable: new r.Pointer(r.uint16, PostCompensationTable, { type: 'parent' }),\r\n  widthDeltaClusters: new LookupTable(new r.Pointer(r.uint16, WidthDeltaCluster, { type: 'parent', relativeTo: ctx => ctx.wdcOffset }))\r\n});\r\n\r\nexport default new r.Struct({\r\n  version: r.uint32,\r\n  format: r.uint16,\r\n  horizontal: new r.Pointer(r.uint16, JustificationTable),\r\n  vertical: new r.Pointer(r.uint16, JustificationTable)\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\nimport { UnboundedArray, LookupTable, StateTable } from './aat';\r\n\r\nlet LigatureData = {\r\n  action: r.uint16\r\n};\r\n\r\nlet ContextualData = {\r\n  markIndex: r.uint16,\r\n  currentIndex: r.uint16\r\n};\r\n\r\nlet InsertionData = {\r\n  currentInsertIndex: r.uint16,\r\n  markedInsertIndex: r.uint16\r\n};\r\n\r\nlet SubstitutionTable = new r.Struct({\r\n  items: new UnboundedArray(new r.Pointer(r.uint32, new LookupTable))\r\n});\r\n\r\nlet SubtableData = new r.VersionedStruct('type', {\r\n  0: { // Indic Rearrangement Subtable\r\n    stateTable: new StateTable\r\n  },\r\n\r\n  1: { // Contextual Glyph Substitution Subtable\r\n    stateTable: new StateTable(ContextualData),\r\n    substitutionTable: new r.Pointer(r.uint32, SubstitutionTable)\r\n  },\r\n\r\n  2: { // Ligature subtable\r\n    stateTable: new StateTable(LigatureData),\r\n    ligatureActions: new r.Pointer(r.uint32, new UnboundedArray(r.uint32)),\r\n    components: new r.Pointer(r.uint32, new UnboundedArray(r.uint16)),\r\n    ligatureList: new r.Pointer(r.uint32, new UnboundedArray(r.uint16))\r\n  },\r\n\r\n  4: { // Non-contextual Glyph Substitution Subtable\r\n    lookupTable: new LookupTable\r\n  },\r\n\r\n  5: { // Glyph Insertion Subtable\r\n    stateTable: new StateTable(InsertionData),\r\n    insertionActions: new r.Pointer(r.uint32, new UnboundedArray(r.uint16))\r\n  }\r\n});\r\n\r\nlet Subtable = new r.Struct({\r\n  length: r.uint32,\r\n  coverage: r.uint24,\r\n  type: r.uint8,\r\n  subFeatureFlags: r.uint32,\r\n  table: SubtableData,\r\n  padding: new r.Reserved(r.uint8, t => t.length - t._currentOffset)\r\n});\r\n\r\nlet FeatureEntry = new r.Struct({\r\n  featureType:    r.uint16,\r\n  featureSetting: r.uint16,\r\n  enableFlags:    r.uint32,\r\n  disableFlags:   r.uint32\r\n});\r\n\r\nlet MorxChain = new r.Struct({\r\n  defaultFlags:     r.uint32,\r\n  chainLength:      r.uint32,\r\n  nFeatureEntries:  r.uint32,\r\n  nSubtables:       r.uint32,\r\n  features:         new r.Array(FeatureEntry, 'nFeatureEntries'),\r\n  subtables:        new r.Array(Subtable, 'nSubtables')\r\n});\r\n\r\nexport default new r.Struct({\r\n  version:  r.uint16,\r\n  unused:   new r.Reserved(r.uint16),\r\n  nChains:  r.uint32,\r\n  chains:   new r.Array(MorxChain, 'nChains')\r\n});\r\n","import r from '@foliojs-fork/restructure';\r\nimport { LookupTable } from './aat';\r\n\r\nlet OpticalBounds = new r.Struct({\r\n  left: r.int16,\r\n  top: r.int16,\r\n  right: r.int16,\r\n  bottom: r.int16\r\n});\r\n\r\nexport default new r.Struct({\r\n  version: r.fixed32,\r\n  format: r.uint16,\r\n  lookupTable: new LookupTable(OpticalBounds)\r\n});\r\n","let tables = {};\r\nexport default tables;\r\n\r\n// Required Tables\r\nimport cmap from './cmap';\r\nimport head from './head';\r\nimport hhea from './hhea';\r\nimport hmtx from './hmtx';\r\nimport maxp from './maxp';\r\nimport name from './name';\r\nimport OS2 from './OS2';\r\nimport post from './post';\r\n\r\ntables.cmap = cmap;\r\ntables.head = head;\r\ntables.hhea = hhea;\r\ntables.hmtx = hmtx;\r\ntables.maxp = maxp;\r\ntables.name = name;\r\ntables['OS/2'] = OS2;\r\ntables.post = post;\r\n\r\n\r\n// TrueType Outlines\r\nimport cvt from './cvt';\r\nimport fpgm from './fpgm';\r\nimport loca from './loca';\r\nimport prep from './prep';\r\nimport glyf from './glyf';\r\n\r\ntables.fpgm = fpgm;\r\ntables.loca = loca;\r\ntables.prep = prep;\r\ntables['cvt '] = cvt;\r\ntables.glyf = glyf;\r\n\r\n\r\n// PostScript Outlines\r\nimport CFFFont from '../cff/CFFFont';\r\nimport VORG from './VORG';\r\n\r\ntables['CFF '] = CFFFont;\r\ntables['CFF2'] = CFFFont;\r\ntables.VORG = VORG;\r\n\r\n\r\n// Bitmap Glyphs\r\nimport EBLC from './EBLC';\r\nimport sbix from './sbix';\r\nimport COLR from './COLR';\r\nimport CPAL from './CPAL';\r\n\r\ntables.EBLC = EBLC;\r\ntables.CBLC = tables.EBLC;\r\ntables.sbix = sbix;\r\ntables.COLR = COLR;\r\ntables.CPAL = CPAL;\r\n\r\n\r\n// Advanced OpenType Tables\r\nimport BASE from './BASE';\r\nimport GDEF from './GDEF';\r\nimport GPOS from './GPOS';\r\nimport GSUB from './GSUB';\r\nimport JSTF from './JSTF';\r\n\r\ntables.BASE = BASE;\r\ntables.GDEF = GDEF;\r\ntables.GPOS = GPOS;\r\ntables.GSUB = GSUB;\r\ntables.JSTF = JSTF;\r\n\r\n// OpenType variations tables\r\nimport HVAR from './HVAR';\r\n\r\ntables.HVAR = HVAR;\r\n\r\n// Other OpenType Tables\r\nimport DSIG from './DSIG';\r\nimport gasp from './gasp';\r\nimport hdmx from './hdmx';\r\nimport kern from './kern';\r\nimport LTSH from './LTSH';\r\nimport PCLT from './PCLT';\r\nimport VDMX from './VDMX';\r\nimport vhea from './vhea';\r\nimport vmtx from './vmtx';\r\n\r\ntables.DSIG = DSIG;\r\ntables.gasp = gasp;\r\ntables.hdmx = hdmx;\r\ntables.kern = kern;\r\ntables.LTSH = LTSH;\r\ntables.PCLT = PCLT;\r\ntables.VDMX = VDMX;\r\ntables.vhea = vhea;\r\ntables.vmtx = vmtx;\r\n\r\n\r\n// Apple Advanced Typography Tables\r\nimport avar from './avar';\r\nimport bsln from './bsln';\r\nimport feat from './feat';\r\nimport fvar from './fvar';\r\nimport gvar from './gvar';\r\nimport just from './just';\r\nimport morx from './morx';\r\nimport opbd from './opbd';\r\n\r\ntables.avar = avar;\r\ntables.bsln = bsln;\r\ntables.feat = feat;\r\ntables.fvar = fvar;\r\ntables.gvar = gvar;\r\ntables.just = just;\r\ntables.morx = morx;\r\ntables.opbd = opbd;\r\n","import r from '@foliojs-fork/restructure';\r\nimport Tables from './';\r\n\r\nlet TableEntry = new r.Struct({\r\n  tag:        new r.String(4),\r\n  checkSum:   r.uint32,\r\n  offset:     new r.Pointer(r.uint32, 'void', { type: 'global' }),\r\n  length:     r.uint32\r\n});\r\n\r\nlet Directory = new r.Struct({\r\n  tag:            new r.String(4),\r\n  numTables:      r.uint16,\r\n  searchRange:    r.uint16,\r\n  entrySelector:  r.uint16,\r\n  rangeShift:     r.uint16,\r\n  tables:         new r.Array(TableEntry, 'numTables')\r\n});\r\n\r\nDirectory.process = function() {\r\n  let tables = {};\r\n  for (let table of this.tables) {\r\n    tables[table.tag] = table;\r\n  }\r\n\r\n  this.tables = tables;\r\n};\r\n\r\nDirectory.preEncode = function(stream) {\r\n  let tables = [];\r\n  for (let tag in this.tables) {\r\n    let table = this.tables[tag];\r\n    if (table) {\r\n      tables.push({\r\n        tag: tag,\r\n        checkSum: 0,\r\n        offset: new r.VoidPointer(Tables[tag], table),\r\n        length: Tables[tag].size(table)\r\n      });\r\n    }\r\n  }\r\n\r\n  this.tag = 'true';\r\n  this.numTables = tables.length;\r\n  this.tables = tables;\r\n\r\n  let maxExponentFor2 = Math.floor((Math.log(this.numTables) / Math.LN2));\r\n  let maxPowerOf2 = Math.pow(2, maxExponentFor2);\r\n\r\n  this.searchRange =  maxPowerOf2 * 16;\r\n  this.entrySelector = Math.log(maxPowerOf2) / Math.LN2;\r\n  this.rangeShift = this.numTables * 16 - this.searchRange;\r\n};\r\n\r\nexport default Directory;\r\n","export function binarySearch(arr, cmp) {\r\n  let min = 0;\r\n  let max = arr.length - 1;\r\n  while (min <= max) {\r\n    let mid = (min + max) >> 1;\r\n    let res = cmp(arr[mid]);\r\n\r\n    if (res < 0) {\r\n      max = mid - 1;\r\n    } else if (res > 0) {\r\n      min = mid + 1;\r\n    } else {\r\n      return mid;\r\n    }\r\n  }\r\n\r\n  return -1;\r\n}\r\n\r\nexport function range(index, end) {\r\n  let range = [];\r\n  while (index < end) {\r\n    range.push(index++);\r\n  }\r\n  return range;\r\n}\r\n","import {binarySearch} from './utils';\r\nimport {getEncoding} from './encodings';\r\nimport {cache} from './decorators';\r\nimport {range} from './utils';\r\n\r\n// iconv-lite is an optional dependency.\r\ntry {\r\n  var iconv = require('iconv-lite');\r\n} catch (err) {}\r\n\r\nexport default class CmapProcessor {\r\n  constructor(cmapTable) {\r\n    // Attempt to find a Unicode cmap first\r\n    this.encoding = null;\r\n    this.cmap = this.findSubtable(cmapTable, [\r\n      // 32-bit subtables\r\n      [3, 10],\r\n      [0, 6],\r\n      [0, 4],\r\n\r\n      // 16-bit subtables\r\n      [3, 1],\r\n      [0, 3],\r\n      [0, 2],\r\n      [0, 1],\r\n      [0, 0]\r\n    ]);\r\n\r\n    // If not unicode cmap was found, and iconv-lite is installed,\r\n    // take the first table with a supported encoding.\r\n    if (!this.cmap && iconv) {\r\n      for (let cmap of cmapTable.tables) {\r\n        let encoding = getEncoding(cmap.platformID, cmap.encodingID, cmap.table.language - 1);\r\n        if (iconv.encodingExists(encoding)) {\r\n          this.cmap = cmap.table;\r\n          this.encoding = encoding;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!this.cmap) {\r\n      throw new Error(\"Could not find a supported cmap table\");\r\n    }\r\n\r\n    this.uvs = this.findSubtable(cmapTable, [[0, 5]]);\r\n    if (this.uvs && this.uvs.version !== 14) {\r\n      this.uvs = null;\r\n    }\r\n  }\r\n\r\n  findSubtable(cmapTable, pairs) {\r\n    for (let [platformID, encodingID] of pairs) {\r\n      for (let cmap of cmapTable.tables) {\r\n        if (cmap.platformID === platformID && cmap.encodingID === encodingID) {\r\n          return cmap.table;\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  lookup(codepoint, variationSelector) {\r\n    // If there is no Unicode cmap in this font, we need to re-encode\r\n    // the codepoint in the encoding that the cmap supports.\r\n    if (this.encoding) {\r\n      let buf = iconv.encode(String.fromCodePoint(codepoint), this.encoding);\r\n      codepoint = 0;\r\n      for (let i = 0; i < buf.length; i++) {\r\n        codepoint = (codepoint << 8) | buf[i];\r\n      }\r\n\r\n    // Otherwise, try to get a Unicode variation selector for this codepoint if one is provided.\r\n    } else if (variationSelector) {\r\n      let gid = this.getVariationSelector(codepoint, variationSelector);\r\n      if (gid) {\r\n        return gid;\r\n      }\r\n    }\r\n\r\n    let cmap = this.cmap;\r\n    switch (cmap.version) {\r\n      case 0:\r\n        return cmap.codeMap.get(codepoint) || 0;\r\n\r\n      case 4: {\r\n        let min = 0;\r\n        let max = cmap.segCount - 1;\r\n        while (min <= max) {\r\n          let mid = (min + max) >> 1;\r\n\r\n          if (codepoint < cmap.startCode.get(mid)) {\r\n            max = mid - 1;\r\n          } else if (codepoint > cmap.endCode.get(mid)) {\r\n            min = mid + 1;\r\n          } else {\r\n            let rangeOffset = cmap.idRangeOffset.get(mid);\r\n            let gid;\r\n\r\n            if (rangeOffset === 0) {\r\n              gid = codepoint + cmap.idDelta.get(mid);\r\n            } else {\r\n              let index = rangeOffset / 2 + (codepoint - cmap.startCode.get(mid)) - (cmap.segCount - mid);\r\n              gid = cmap.glyphIndexArray.get(index) || 0;\r\n              if (gid !== 0) {\r\n                gid += cmap.idDelta.get(mid);\r\n              }\r\n            }\r\n\r\n            return gid & 0xffff;\r\n          }\r\n        }\r\n\r\n        return 0;\r\n      }\r\n\r\n      case 8:\r\n        throw new Error('TODO: cmap format 8');\r\n\r\n      case 6:\r\n      case 10:\r\n        return cmap.glyphIndices.get(codepoint - cmap.firstCode) || 0;\r\n\r\n      case 12:\r\n      case 13: {\r\n        let min = 0;\r\n        let max = cmap.nGroups - 1;\r\n        while (min <= max) {\r\n          let mid = (min + max) >> 1;\r\n          let group = cmap.groups.get(mid);\r\n\r\n          if (codepoint < group.startCharCode) {\r\n            max = mid - 1;\r\n          } else if (codepoint > group.endCharCode) {\r\n            min = mid + 1;\r\n          } else {\r\n            if (cmap.version === 12) {\r\n              return group.glyphID + (codepoint - group.startCharCode);\r\n            } else {\r\n              return group.glyphID;\r\n            }\r\n          }\r\n        }\r\n\r\n        return 0;\r\n      }\r\n\r\n      case 14:\r\n        throw new Error('TODO: cmap format 14');\r\n\r\n      default:\r\n        throw new Error(`Unknown cmap format ${cmap.version}`);\r\n    }\r\n  }\r\n\r\n  getVariationSelector(codepoint, variationSelector) {\r\n    if (!this.uvs) {\r\n      return 0;\r\n    }\r\n\r\n    let selectors = this.uvs.varSelectors.toArray();\r\n    let i = binarySearch(selectors, x => variationSelector - x.varSelector);\r\n    let sel = selectors[i];\r\n\r\n    if (i !== -1 && sel.defaultUVS) {\r\n      i = binarySearch(sel.defaultUVS, x =>\r\n        codepoint < x.startUnicodeValue ? -1 : codepoint > x.startUnicodeValue + x.additionalCount ? +1 : 0\r\n      );\r\n    }\r\n\r\n    if (i !== -1 && sel.nonDefaultUVS) {\r\n      i = binarySearch(sel.nonDefaultUVS, x => codepoint - x.unicodeValue);\r\n      if (i !== -1) {\r\n        return sel.nonDefaultUVS[i].glyphID;\r\n      }\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  @cache\r\n  getCharacterSet() {\r\n    let cmap = this.cmap;\r\n    switch (cmap.version) {\r\n      case 0:\r\n        return range(0, cmap.codeMap.length);\r\n\r\n      case 4: {\r\n        let res = [];\r\n        let endCodes = cmap.endCode.toArray();\r\n        for (let i = 0; i < endCodes.length; i++) {\r\n          let tail = endCodes[i] + 1;\r\n          let start = cmap.startCode.get(i);\r\n          res.push(...range(start, tail));\r\n        }\r\n\r\n        return res;\r\n      }\r\n\r\n      case 8:\r\n        throw new Error('TODO: cmap format 8');\r\n\r\n      case 6:\r\n      case 10:\r\n        return range(cmap.firstCode, cmap.firstCode + cmap.glyphIndices.length);\r\n\r\n      case 12:\r\n      case 13: {\r\n        let res = [];\r\n        for (let group of cmap.groups.toArray()) {\r\n          res.push(...range(group.startCharCode, group.endCharCode + 1));\r\n        }\r\n\r\n        return res;\r\n      }\r\n\r\n      case 14:\r\n        throw new Error('TODO: cmap format 14');\r\n\r\n      default:\r\n        throw new Error(`Unknown cmap format ${cmap.version}`);\r\n    }\r\n  }\r\n\r\n  @cache\r\n  codePointsForGlyph(gid) {\r\n    let cmap = this.cmap;\r\n    switch (cmap.version) {\r\n      case 0: {\r\n        let res = [];\r\n        for (let i = 0; i < 256; i++) {\r\n          if (cmap.codeMap.get(i) === gid) {\r\n            res.push(i);\r\n          }\r\n        }\r\n\r\n        return res;\r\n      }\r\n\r\n      case 4: {\r\n        let res = [];\r\n        for (let i = 0; i < cmap.segCount; i++) {\r\n          let end = cmap.endCode.get(i);\r\n          let start = cmap.startCode.get(i);\r\n          let rangeOffset = cmap.idRangeOffset.get(i);\r\n          let delta = cmap.idDelta.get(i);\r\n\r\n          for (var c = start; c <= end; c++) {\r\n            let g = 0;\r\n            if (rangeOffset === 0) {\r\n              g = c + delta;\r\n            } else {\r\n              let index = rangeOffset / 2 + (c - start) - (cmap.segCount - i);\r\n              g = cmap.glyphIndexArray.get(index) || 0;\r\n              if (g !== 0) {\r\n                g += delta;\r\n              }\r\n            }\r\n\r\n            if (g === gid) {\r\n              res.push(c);\r\n            }\r\n          }\r\n        }\r\n\r\n        return res;\r\n      }\r\n\r\n      case 12: {\r\n        let res = [];\r\n        for (let group of cmap.groups.toArray()) {\r\n          if (gid >= group.glyphID && gid <= group.glyphID + (group.endCharCode - group.startCharCode)) {\r\n            res.push(group.startCharCode + (gid - group.glyphID));\r\n          }\r\n        }\r\n\r\n        return res;\r\n      }\r\n\r\n      case 13: {\r\n        let res = [];\r\n        for (let group of cmap.groups.toArray()) {\r\n          if (gid === group.glyphID) {\r\n            res.push(...range(group.startCharCode, group.endCharCode + 1));\r\n          }\r\n        }\r\n\r\n        return res;\r\n      }\r\n\r\n      default:\r\n        throw new Error(`Unknown cmap format ${cmap.version}`);\r\n    }\r\n  }\r\n}\r\n","import {binarySearch} from '../utils';\r\n\r\nexport default class KernProcessor {\r\n  constructor(font) {\r\n    this.kern = font.kern;\r\n  }\r\n\r\n  process(glyphs, positions) {\r\n    for (let glyphIndex = 0; glyphIndex < glyphs.length - 1; glyphIndex++) {\r\n      let left = glyphs[glyphIndex].id;\r\n      let right = glyphs[glyphIndex + 1].id;\r\n      positions[glyphIndex].xAdvance += this.getKerning(left, right);\r\n    }\r\n  }\r\n\r\n  getKerning(left, right) {\r\n    let res = 0;\r\n\r\n    for (let table of this.kern.tables) {\r\n      if (table.coverage.crossStream) {\r\n        continue;\r\n      }\r\n\r\n      switch (table.version) {\r\n        case 0:\r\n          if (!table.coverage.horizontal) {\r\n            continue;\r\n          }\r\n\r\n          break;\r\n        case 1:\r\n          if (table.coverage.vertical || table.coverage.variation) {\r\n            continue;\r\n          }\r\n\r\n          break;\r\n        default:\r\n          throw new Error(`Unsupported kerning table version ${table.version}`);\r\n      }\r\n\r\n      let val = 0;\r\n      let s = table.subtable;\r\n      switch (table.format) {\r\n        case 0:\r\n          let pairIdx = binarySearch(s.pairs, function (pair) {\r\n            return (left - pair.left) || (right - pair.right);\r\n          });\r\n\r\n          if (pairIdx >= 0) {\r\n            val = s.pairs[pairIdx].value;\r\n          }\r\n\r\n          break;\r\n\r\n        case 2:\r\n          let leftOffset = 0, rightOffset = 0;\r\n          if (left >= s.leftTable.firstGlyph && left < s.leftTable.firstGlyph + s.leftTable.nGlyphs) {\r\n            leftOffset = s.leftTable.offsets[left - s.leftTable.firstGlyph];\r\n          } else {\r\n            leftOffset = s.array.off;\r\n          }\r\n\r\n          if (right >= s.rightTable.firstGlyph && right < s.rightTable.firstGlyph + s.rightTable.nGlyphs) {\r\n            rightOffset = s.rightTable.offsets[right - s.rightTable.firstGlyph];\r\n          }\r\n\r\n          let index = (leftOffset + rightOffset - s.array.off) / 2;\r\n          val = s.array.values.get(index);\r\n          break;\r\n\r\n        case 3:\r\n          if (left >= s.glyphCount || right >= s.glyphCount) {\r\n            return 0;\r\n          }\r\n\r\n          val = s.kernValue[s.kernIndex[s.leftClass[left] * s.rightClassCount + s.rightClass[right]]];\r\n          break;\r\n\r\n        default:\r\n          throw new Error(`Unsupported kerning sub-table format ${table.format}`);\r\n      }\r\n\r\n      // Microsoft supports the override flag, which resets the result\r\n      // Otherwise, the sum of the results from all subtables is returned\r\n      if (table.coverage.override) {\r\n        res = val;\r\n      } else {\r\n        res += val;\r\n      }\r\n    }\r\n\r\n    return res;\r\n  }\r\n}\r\n","import unicode from 'unicode-properties';\r\n\r\n/**\r\n * This class is used when GPOS does not define 'mark' or 'mkmk' features\r\n * for positioning marks relative to base glyphs. It uses the unicode\r\n * combining class property to position marks.\r\n *\r\n * Based on code from Harfbuzz, thanks!\r\n * https://github.com/behdad/harfbuzz/blob/master/src/hb-ot-shape-fallback.cc\r\n */\r\nexport default class UnicodeLayoutEngine {\r\n  constructor(font) {\r\n    this.font = font;\r\n  }\r\n\r\n  positionGlyphs(glyphs, positions) {\r\n    // find each base + mark cluster, and position the marks relative to the base\r\n    let clusterStart = 0;\r\n    let clusterEnd = 0;\r\n    for (let index = 0; index < glyphs.length; index++) {\r\n      let glyph = glyphs[index];\r\n      if (glyph.isMark) { // TODO: handle ligatures\r\n        clusterEnd = index;\r\n      } else {\r\n        if (clusterStart !== clusterEnd) {\r\n          this.positionCluster(glyphs, positions, clusterStart, clusterEnd);\r\n        }\r\n\r\n        clusterStart = clusterEnd = index;\r\n      }\r\n    }\r\n\r\n    if (clusterStart !== clusterEnd) {\r\n      this.positionCluster(glyphs, positions, clusterStart, clusterEnd);\r\n    }\r\n\r\n    return positions;\r\n  }\r\n\r\n  positionCluster(glyphs, positions, clusterStart, clusterEnd) {\r\n    let base = glyphs[clusterStart];\r\n    let baseBox = base.cbox.copy();\r\n\r\n    // adjust bounding box for ligature glyphs\r\n    if (base.codePoints.length > 1) {\r\n      // LTR. TODO: RTL support.\r\n      baseBox.minX += ((base.codePoints.length - 1) * baseBox.width) / base.codePoints.length;\r\n    }\r\n\r\n    let xOffset = -positions[clusterStart].xAdvance;\r\n    let yOffset = 0;\r\n    let yGap = this.font.unitsPerEm / 16;\r\n\r\n    // position each of the mark glyphs relative to the base glyph\r\n    for (let index = clusterStart + 1; index <= clusterEnd; index++) {\r\n      let mark = glyphs[index];\r\n      let markBox = mark.cbox;\r\n      let position = positions[index];\r\n\r\n      let combiningClass = this.getCombiningClass(mark.codePoints[0]);\r\n\r\n      if (combiningClass !== 'Not_Reordered') {\r\n        position.xOffset = position.yOffset = 0;\r\n\r\n        // x positioning\r\n        switch (combiningClass) {\r\n          case 'Double_Above':\r\n          case 'Double_Below':\r\n            // LTR. TODO: RTL support.\r\n            position.xOffset += baseBox.minX - markBox.width / 2 - markBox.minX;\r\n            break;\r\n\r\n          case 'Attached_Below_Left':\r\n          case 'Below_Left':\r\n          case 'Above_Left':\r\n            // left align\r\n            position.xOffset += baseBox.minX - markBox.minX;\r\n            break;\r\n\r\n          case 'Attached_Above_Right':\r\n          case 'Below_Right':\r\n          case 'Above_Right':\r\n            // right align\r\n            position.xOffset += baseBox.maxX - markBox.width - markBox.minX;\r\n            break;\r\n\r\n          default: // Attached_Below, Attached_Above, Below, Above, other\r\n            // center align\r\n            position.xOffset += baseBox.minX + (baseBox.width - markBox.width) / 2 - markBox.minX;\r\n        }\r\n\r\n        // y positioning\r\n        switch (combiningClass) {\r\n          case 'Double_Below':\r\n          case 'Below_Left':\r\n          case 'Below':\r\n          case 'Below_Right':\r\n          case 'Attached_Below_Left':\r\n          case 'Attached_Below':\r\n            // add a small gap between the glyphs if they are not attached\r\n            if (combiningClass === 'Attached_Below_Left' || combiningClass === 'Attached_Below') {\r\n              baseBox.minY += yGap;\r\n            }\r\n\r\n            position.yOffset = -baseBox.minY - markBox.maxY;\r\n            baseBox.minY += markBox.height;\r\n            break;\r\n\r\n          case 'Double_Above':\r\n          case 'Above_Left':\r\n          case 'Above':\r\n          case 'Above_Right':\r\n          case 'Attached_Above':\r\n          case 'Attached_Above_Right':\r\n            // add a small gap between the glyphs if they are not attached\r\n            if (combiningClass === 'Attached_Above' || combiningClass === 'Attached_Above_Right') {\r\n              baseBox.maxY += yGap;\r\n            }\r\n\r\n            position.yOffset = baseBox.maxY - markBox.minY;\r\n            baseBox.maxY += markBox.height;\r\n            break;\r\n        }\r\n\r\n        position.xAdvance = position.yAdvance = 0;\r\n        position.xOffset += xOffset;\r\n        position.yOffset += yOffset;\r\n\r\n      } else {\r\n        xOffset -= position.xAdvance;\r\n        yOffset -= position.yAdvance;\r\n      }\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  getCombiningClass(codePoint) {\r\n    let combiningClass = unicode.getCombiningClass(codePoint);\r\n\r\n    // Thai / Lao need some per-character work\r\n    if ((codePoint & ~0xff) === 0x0e00) {\r\n      if (combiningClass === 'Not_Reordered') {\r\n        switch (codePoint) {\r\n          case 0x0e31:\r\n          case 0x0e34:\r\n          case 0x0e35:\r\n          case 0x0e36:\r\n          case 0x0e37:\r\n          case 0x0e47:\r\n          case 0x0e4c:\r\n          case 0x0e3d:\r\n          case 0x0e4e:\r\n            return 'Above_Right';\r\n\r\n          case 0x0eb1:\r\n          case 0x0eb4:\r\n          case 0x0eb5:\r\n          case 0x0eb6:\r\n          case 0x0eb7:\r\n          case 0x0ebb:\r\n          case 0x0ecc:\r\n          case 0x0ecd:\r\n            return 'Above';\r\n\r\n          case 0x0ebc:\r\n            return 'Below';\r\n        }\r\n      } else if (codePoint === 0x0e3a) { // virama\r\n        return 'Below_Right';\r\n      }\r\n    }\r\n\r\n    switch (combiningClass) {\r\n      // Hebrew\r\n\r\n      case 'CCC10': // sheva\r\n      case 'CCC11': // hataf segol\r\n      case 'CCC12': // hataf patah\r\n      case 'CCC13': // hataf qamats\r\n      case 'CCC14': // hiriq\r\n      case 'CCC15': // tsere\r\n      case 'CCC16': // segol\r\n      case 'CCC17': // patah\r\n      case 'CCC18': // qamats\r\n      case 'CCC20': // qubuts\r\n      case 'CCC22': // meteg\r\n        return 'Below';\r\n\r\n      case 'CCC23': // rafe\r\n        return 'Attached_Above';\r\n\r\n      case 'CCC24': // shin dot\r\n        return 'Above_Right';\r\n\r\n      case 'CCC25': // sin dot\r\n      case 'CCC19': // holam\r\n        return 'Above_Left';\r\n\r\n      case 'CCC26': // point varika\r\n        return 'Above';\r\n\r\n      case 'CCC21': // dagesh\r\n        break;\r\n\r\n      // Arabic and Syriac\r\n\r\n      case 'CCC27': // fathatan\r\n      case 'CCC28': // dammatan\r\n      case 'CCC30': // fatha\r\n      case 'CCC31': // damma\r\n      case 'CCC33': // shadda\r\n      case 'CCC34': // sukun\r\n      case 'CCC35': // superscript alef\r\n      case 'CCC36': // superscript alaph\r\n        return 'Above';\r\n\r\n      case 'CCC29': // kasratan\r\n      case 'CCC32': // kasra\r\n        return 'Below';\r\n\r\n      // Thai\r\n\r\n      case 'CCC103': // sara u / sara uu\r\n        return 'Below_Right';\r\n\r\n      case 'CCC107': // mai\r\n        return 'Above_Right';\r\n\r\n      // Lao\r\n\r\n      case 'CCC118': // sign u / sign uu\r\n        return 'Below';\r\n\r\n      case 'CCC122': // mai\r\n        return 'Above';\r\n\r\n      // Tibetan\r\n\r\n      case 'CCC129': // sign aa\r\n      case 'CCC132': // sign u\r\n        return 'Below';\r\n\r\n      case 'CCC130': // sign i\r\n        return 'Above';\r\n    }\r\n\r\n    return combiningClass;\r\n  }\r\n}\r\n","/**\r\n * Represents a glyph bounding box\r\n */\r\nexport default class BBox {\r\n  constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {\r\n    /**\r\n     * The minimum X position in the bounding box\r\n     * @type {number}\r\n     */\r\n    this.minX = minX;\r\n\r\n    /**\r\n     * The minimum Y position in the bounding box\r\n     * @type {number}\r\n     */\r\n    this.minY = minY;\r\n\r\n    /**\r\n     * The maxmimum X position in the bounding box\r\n     * @type {number}\r\n     */\r\n    this.maxX = maxX;\r\n\r\n    /**\r\n     * The maxmimum Y position in the bounding box\r\n     * @type {number}\r\n     */\r\n    this.maxY = maxY;\r\n  }\r\n\r\n  /**\r\n   * The width of the bounding box\r\n   * @type {number}\r\n   */\r\n  get width() {\r\n    return this.maxX - this.minX;\r\n  }\r\n\r\n  /**\r\n   * The height of the bounding box\r\n   * @type {number}\r\n   */\r\n  get height() {\r\n    return this.maxY - this.minY;\r\n  }\r\n\r\n  addPoint(x, y) {\r\n    if (Math.abs(x) !== Infinity) {\r\n      if (x < this.minX) {\r\n        this.minX = x;\r\n      }\r\n\r\n      if (x > this.maxX) {\r\n        this.maxX = x;\r\n      }\r\n    }\r\n\r\n    if (Math.abs(y) !== Infinity) {\r\n      if (y < this.minY) {\r\n        this.minY = y;\r\n      }\r\n\r\n      if (y > this.maxY) {\r\n        this.maxY = y;\r\n      }\r\n    }\r\n  }\r\n\r\n  copy() {\r\n    return new BBox(this.minX, this.minY, this.maxX, this.maxY);\r\n  }\r\n}\r\n","import unicode from 'unicode-properties';\r\n\r\n// This maps the Unicode Script property to an OpenType script tag\r\n// Data from http://www.microsoft.com/typography/otspec/scripttags.htm\r\n// and http://www.unicode.org/Public/UNIDATA/PropertyValueAliases.txt.\r\nconst UNICODE_SCRIPTS = {\r\n  Caucasian_Albanian: 'aghb',\r\n  Arabic: 'arab',\r\n  Imperial_Aramaic: 'armi',\r\n  Armenian: 'armn',\r\n  Avestan: 'avst',\r\n  Balinese: 'bali',\r\n  Bamum: 'bamu',\r\n  Bassa_Vah: 'bass',\r\n  Batak: 'batk',\r\n  Bengali: ['bng2', 'beng'],\r\n  Bopomofo: 'bopo',\r\n  Brahmi: 'brah',\r\n  Braille: 'brai',\r\n  Buginese: 'bugi',\r\n  Buhid: 'buhd',\r\n  Chakma: 'cakm',\r\n  Canadian_Aboriginal: 'cans',\r\n  Carian: 'cari',\r\n  Cham: 'cham',\r\n  Cherokee: 'cher',\r\n  Coptic: 'copt',\r\n  Cypriot: 'cprt',\r\n  Cyrillic: 'cyrl',\r\n  Devanagari: ['dev2', 'deva'],\r\n  Deseret: 'dsrt',\r\n  Duployan: 'dupl',\r\n  Egyptian_Hieroglyphs: 'egyp',\r\n  Elbasan: 'elba',\r\n  Ethiopic: 'ethi',\r\n  Georgian: 'geor',\r\n  Glagolitic: 'glag',\r\n  Gothic: 'goth',\r\n  Grantha: 'gran',\r\n  Greek: 'grek',\r\n  Gujarati: ['gjr2', 'gujr'],\r\n  Gurmukhi: ['gur2', 'guru'],\r\n  Hangul: 'hang',\r\n  Han: 'hani',\r\n  Hanunoo: 'hano',\r\n  Hebrew: 'hebr',\r\n  Hiragana: 'hira',\r\n  Pahawh_Hmong: 'hmng',\r\n  Katakana_Or_Hiragana: 'hrkt',\r\n  Old_Italic: 'ital',\r\n  Javanese: 'java',\r\n  Kayah_Li: 'kali',\r\n  Katakana: 'kana',\r\n  Kharoshthi: 'khar',\r\n  Khmer: 'khmr',\r\n  Khojki: 'khoj',\r\n  Kannada: ['knd2', 'knda'],\r\n  Kaithi: 'kthi',\r\n  Tai_Tham: 'lana',\r\n  Lao: 'lao ',\r\n  Latin: 'latn',\r\n  Lepcha: 'lepc',\r\n  Limbu: 'limb',\r\n  Linear_A: 'lina',\r\n  Linear_B: 'linb',\r\n  Lisu: 'lisu',\r\n  Lycian: 'lyci',\r\n  Lydian: 'lydi',\r\n  Mahajani: 'mahj',\r\n  Mandaic: 'mand',\r\n  Manichaean: 'mani',\r\n  Mende_Kikakui: 'mend',\r\n  Meroitic_Cursive: 'merc',\r\n  Meroitic_Hieroglyphs: 'mero',\r\n  Malayalam: ['mlm2', 'mlym'],\r\n  Modi: 'modi',\r\n  Mongolian: 'mong',\r\n  Mro: 'mroo',\r\n  Meetei_Mayek: 'mtei',\r\n  Myanmar: ['mym2', 'mymr'],\r\n  Old_North_Arabian: 'narb',\r\n  Nabataean: 'nbat',\r\n  Nko: 'nko ',\r\n  Ogham: 'ogam',\r\n  Ol_Chiki: 'olck',\r\n  Old_Turkic: 'orkh',\r\n  Oriya: ['ory2', 'orya'],\r\n  Osmanya: 'osma',\r\n  Palmyrene: 'palm',\r\n  Pau_Cin_Hau: 'pauc',\r\n  Old_Permic: 'perm',\r\n  Phags_Pa: 'phag',\r\n  Inscriptional_Pahlavi: 'phli',\r\n  Psalter_Pahlavi: 'phlp',\r\n  Phoenician: 'phnx',\r\n  Miao: 'plrd',\r\n  Inscriptional_Parthian: 'prti',\r\n  Rejang: 'rjng',\r\n  Runic: 'runr',\r\n  Samaritan: 'samr',\r\n  Old_South_Arabian: 'sarb',\r\n  Saurashtra: 'saur',\r\n  Shavian: 'shaw',\r\n  Sharada: 'shrd',\r\n  Siddham: 'sidd',\r\n  Khudawadi: 'sind',\r\n  Sinhala: 'sinh',\r\n  Sora_Sompeng: 'sora',\r\n  Sundanese: 'sund',\r\n  Syloti_Nagri: 'sylo',\r\n  Syriac: 'syrc',\r\n  Tagbanwa: 'tagb',\r\n  Takri: 'takr',\r\n  Tai_Le: 'tale',\r\n  New_Tai_Lue: 'talu',\r\n  Tamil: ['tml2', 'taml'],\r\n  Tai_Viet: 'tavt',\r\n  Telugu: ['tel2', 'telu'],\r\n  Tifinagh: 'tfng',\r\n  Tagalog: 'tglg',\r\n  Thaana: 'thaa',\r\n  Thai: 'thai',\r\n  Tibetan: 'tibt',\r\n  Tirhuta: 'tirh',\r\n  Ugaritic: 'ugar',\r\n  Vai: 'vai ',\r\n  Warang_Citi: 'wara',\r\n  Old_Persian: 'xpeo',\r\n  Cuneiform: 'xsux',\r\n  Yi: 'yi  ',\r\n  Inherited: 'zinh',\r\n  Common: 'zyyy',\r\n  Unknown: 'zzzz'\r\n};\r\n\r\nconst OPENTYPE_SCRIPTS = {};\r\nfor (let script in UNICODE_SCRIPTS) {\r\n  let tag = UNICODE_SCRIPTS[script];\r\n  if (Array.isArray(tag)) {\r\n    for (let t of tag) {\r\n      OPENTYPE_SCRIPTS[t] = script;\r\n    }\r\n  } else {\r\n    OPENTYPE_SCRIPTS[tag] = script;\r\n  }\r\n}\r\n\r\nexport function fromUnicode(script) {\r\n  return UNICODE_SCRIPTS[script];\r\n}\r\n\r\nexport function fromOpenType(tag) {\r\n  return OPENTYPE_SCRIPTS[tag];\r\n}\r\n\r\nexport function forString(string) {\r\n  let len = string.length;\r\n  let idx = 0;\r\n  while (idx < len) {\r\n    let code = string.charCodeAt(idx++);\r\n\r\n    // Check if this is a high surrogate\r\n    if (0xd800 <= code && code <= 0xdbff && idx < len) {\r\n      let next = string.charCodeAt(idx);\r\n\r\n      // Check if this is a low surrogate\r\n      if (0xdc00 <= next && next <= 0xdfff) {\r\n        idx++;\r\n        code = ((code & 0x3FF) << 10) + (next & 0x3FF) + 0x10000;\r\n      }\r\n    }\r\n\r\n    let script = unicode.getScript(code);\r\n    if (script !== 'Common' && script !== 'Inherited' && script !== 'Unknown') {\r\n      return UNICODE_SCRIPTS[script];\r\n    }\r\n  }\r\n\r\n  return UNICODE_SCRIPTS.Unknown;\r\n}\r\n\r\nexport function forCodePoints(codePoints) {\r\n  for (let i = 0; i < codePoints.length; i++) {\r\n    let codePoint = codePoints[i];\r\n    let script = unicode.getScript(codePoint);\r\n    if (script !== 'Common' && script !== 'Inherited' && script !== 'Unknown') {\r\n      return UNICODE_SCRIPTS[script];\r\n    }\r\n  }\r\n\r\n  return UNICODE_SCRIPTS.Unknown;\r\n}\r\n\r\n// The scripts in this map are written from right to left\r\nconst RTL = {\r\n  arab: true,   // Arabic\r\n  hebr: true,   // Hebrew\r\n  syrc: true,   // Syriac\r\n  thaa: true,   // Thaana\r\n  cprt: true,   // Cypriot Syllabary\r\n  khar: true,   // Kharosthi\r\n  phnx: true,   // Phoenician\r\n  'nko ': true, // N'Ko\r\n  lydi: true,   // Lydian\r\n  avst: true,   // Avestan\r\n  armi: true,   // Imperial Aramaic\r\n  phli: true,   // Inscriptional Pahlavi\r\n  prti: true,   // Inscriptional Parthian\r\n  sarb: true,   // Old South Arabian\r\n  orkh: true,   // Old Turkic, Orkhon Runic\r\n  samr: true,   // Samaritan\r\n  mand: true,   // Mandaic, Mandaean\r\n  merc: true,   // Meroitic Cursive\r\n  mero: true,   // Meroitic Hieroglyphs\r\n\r\n  // Unicode 7.0 (not listed on http://www.microsoft.com/typography/otspec/scripttags.htm)\r\n  mani: true,   // Manichaean\r\n  mend: true,   // Mende Kikakui\r\n  nbat: true,   // Nabataean\r\n  narb: true,   // Old North Arabian\r\n  palm: true,   // Palmyrene\r\n  phlp: true    // Psalter Pahlavi\r\n};\r\n\r\nexport function direction(script) {\r\n  if (RTL[script]) {\r\n    return 'rtl';\r\n  }\r\n\r\n  return 'ltr';\r\n}\r\n","import BBox from '../glyph/BBox';\r\nimport * as Script from '../layout/Script';\r\n\r\n/**\r\n * Represents a run of Glyph and GlyphPosition objects.\r\n * Returned by the font layout method.\r\n */\r\nexport default class GlyphRun {\r\n  constructor(glyphs, features, script, language, direction) {\r\n    /**\r\n     * An array of Glyph objects in the run\r\n     * @type {Glyph[]}\r\n     */\r\n    this.glyphs = glyphs;\r\n\r\n    /**\r\n     * An array of GlyphPosition objects for each glyph in the run\r\n     * @type {GlyphPosition[]}\r\n     */\r\n    this.positions = null;\r\n\r\n    /**\r\n     * The script that was requested for shaping. This was either passed in or detected automatically.\r\n     * @type {string}\r\n     */\r\n    this.script = script;\r\n\r\n    /**\r\n     * The language requested for shaping, as passed in. If `null`, the default language for the\r\n     * script was used.\r\n     * @type {string}\r\n     */\r\n    this.language = language || null;\r\n\r\n    /**\r\n     * The direction requested for shaping, as passed in (either ltr or rtl).\r\n     * If `null`, the default direction of the script is used.\r\n     * @type {string}\r\n     */\r\n    this.direction = direction || Script.direction(script);\r\n\r\n    /**\r\n     * The features requested during shaping. This is a combination of user\r\n     * specified features and features chosen by the shaper.\r\n     * @type {object}\r\n     */\r\n    this.features = {};\r\n\r\n    // Convert features to an object\r\n    if (Array.isArray(features)) {\r\n      for (let tag of features) {\r\n        this.features[tag] = true;\r\n      }\r\n    } else if (typeof features === 'object') {\r\n      this.features = features;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The total advance width of the run.\r\n   * @type {number}\r\n   */\r\n  get advanceWidth() {\r\n    let width = 0;\r\n    for (let position of this.positions) {\r\n      width += position.xAdvance;\r\n    }\r\n\r\n    return width;\r\n  }\r\n\r\n /**\r\n  * The total advance height of the run.\r\n  * @type {number}\r\n  */\r\n  get advanceHeight() {\r\n    let height = 0;\r\n    for (let position of this.positions) {\r\n      height += position.yAdvance;\r\n    }\r\n\r\n    return height;\r\n  }\r\n\r\n /**\r\n  * The bounding box containing all glyphs in the run.\r\n  * @type {BBox}\r\n  */\r\n  get bbox() {\r\n    let bbox = new BBox;\r\n\r\n    let x = 0;\r\n    let y = 0;\r\n    for (let index = 0; index < this.glyphs.length; index++) {\r\n      let glyph = this.glyphs[index];\r\n      let p = this.positions[index];\r\n      let b = glyph.bbox;\r\n\r\n      bbox.addPoint(b.minX + x + p.xOffset, b.minY + y + p.yOffset);\r\n      bbox.addPoint(b.maxX + x + p.xOffset, b.maxY + y + p.yOffset);\r\n\r\n      x += p.xAdvance;\r\n      y += p.yAdvance;\r\n    }\r\n\r\n    return bbox;\r\n  }\r\n}\r\n","/**\r\n * Represents positioning information for a glyph in a GlyphRun.\r\n */\r\nexport default class GlyphPosition {\r\n  constructor(xAdvance = 0, yAdvance = 0, xOffset = 0, yOffset = 0) {\r\n    /**\r\n     * The amount to move the virtual pen in the X direction after rendering this glyph.\r\n     * @type {number}\r\n     */\r\n    this.xAdvance = xAdvance;\r\n\r\n    /**\r\n     * The amount to move the virtual pen in the Y direction after rendering this glyph.\r\n     * @type {number}\r\n     */\r\n    this.yAdvance = yAdvance;\r\n\r\n    /**\r\n     * The offset from the pen position in the X direction at which to render this glyph.\r\n     * @type {number}\r\n     */\r\n    this.xOffset = xOffset;\r\n\r\n    /**\r\n     * The offset from the pen position in the Y direction at which to render this glyph.\r\n     * @type {number}\r\n     */\r\n    this.yOffset = yOffset;\r\n  }\r\n}\r\n","// see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html\r\n// and /System/Library/Frameworks/CoreText.framework/Versions/A/Headers/SFNTLayoutTypes.h on a Mac\r\nconst features = {\r\n  allTypographicFeatures: {\r\n    code: 0,\r\n    exclusive: false,\r\n    allTypeFeatures: 0\r\n  },\r\n  ligatures: {\r\n    code: 1,\r\n    exclusive: false,\r\n    requiredLigatures: 0,\r\n    commonLigatures: 2,\r\n    rareLigatures: 4,\r\n    // logos: 6\r\n    rebusPictures: 8,\r\n    diphthongLigatures: 10,\r\n    squaredLigatures: 12,\r\n    abbrevSquaredLigatures: 14,\r\n    symbolLigatures: 16,\r\n    contextualLigatures: 18,\r\n    historicalLigatures: 20\r\n  },\r\n  cursiveConnection: {\r\n    code: 2,\r\n    exclusive: true,\r\n    unconnected: 0,\r\n    partiallyConnected: 1,\r\n    cursive: 2\r\n  },\r\n  letterCase: {\r\n    code: 3,\r\n    exclusive: true\r\n  },\r\n    // upperAndLowerCase: 0          # deprecated\r\n    // allCaps: 1                    # deprecated\r\n    // allLowerCase: 2               # deprecated\r\n    // smallCaps: 3                  # deprecated\r\n    // initialCaps: 4                # deprecated\r\n    // initialCapsAndSmallCaps: 5    # deprecated\r\n  verticalSubstitution: {\r\n    code: 4,\r\n    exclusive: false,\r\n    substituteVerticalForms: 0\r\n  },\r\n  linguisticRearrangement: {\r\n    code: 5,\r\n    exclusive: false,\r\n    linguisticRearrangement: 0\r\n  },\r\n  numberSpacing: {\r\n    code: 6,\r\n    exclusive: true,\r\n    monospacedNumbers: 0,\r\n    proportionalNumbers: 1,\r\n    thirdWidthNumbers: 2,\r\n    quarterWidthNumbers: 3\r\n  },\r\n  smartSwash: {\r\n    code: 8,\r\n    exclusive: false,\r\n    wordInitialSwashes: 0,\r\n    wordFinalSwashes: 2,\r\n    // lineInitialSwashes: 4\r\n    // lineFinalSwashes: 6\r\n    nonFinalSwashes: 8\r\n  },\r\n  diacritics: {\r\n    code: 9,\r\n    exclusive: true,\r\n    showDiacritics: 0,\r\n    hideDiacritics: 1,\r\n    decomposeDiacritics: 2\r\n  },\r\n  verticalPosition: {\r\n    code: 10,\r\n    exclusive: true,\r\n    normalPosition: 0,\r\n    superiors: 1,\r\n    inferiors: 2,\r\n    ordinals: 3,\r\n    scientificInferiors: 4\r\n  },\r\n  fractions: {\r\n    code: 11,\r\n    exclusive: true,\r\n    noFractions: 0,\r\n    verticalFractions: 1,\r\n    diagonalFractions: 2\r\n  },\r\n  overlappingCharacters: {\r\n    code: 13,\r\n    exclusive: false,\r\n    preventOverlap: 0\r\n  },\r\n  typographicExtras: {\r\n    code: 14,\r\n    exclusive: false,\r\n    // hyphensToEmDash: 0\r\n    // hyphenToEnDash: 2\r\n    slashedZero: 4\r\n  },\r\n    // formInterrobang: 6\r\n    // smartQuotes: 8\r\n    // periodsToEllipsis: 10\r\n  mathematicalExtras: {\r\n    code: 15,\r\n    exclusive: false,\r\n    // hyphenToMinus: 0\r\n    // asteristoMultiply: 2\r\n    // slashToDivide: 4\r\n    // inequalityLigatures: 6\r\n    // exponents: 8\r\n    mathematicalGreek: 10\r\n  },\r\n  ornamentSets: {\r\n    code: 16,\r\n    exclusive: true,\r\n    noOrnaments: 0,\r\n    dingbats: 1,\r\n    piCharacters: 2,\r\n    fleurons: 3,\r\n    decorativeBorders: 4,\r\n    internationalSymbols: 5,\r\n    mathSymbols: 6\r\n  },\r\n  characterAlternatives: {\r\n    code: 17,\r\n    exclusive: true,\r\n    noAlternates: 0\r\n  },\r\n    // user defined options\r\n  designComplexity: {\r\n    code: 18,\r\n    exclusive: true,\r\n    designLevel1: 0,\r\n    designLevel2: 1,\r\n    designLevel3: 2,\r\n    designLevel4: 3,\r\n    designLevel5: 4\r\n  },\r\n  styleOptions: {\r\n    code: 19,\r\n    exclusive: true,\r\n    noStyleOptions: 0,\r\n    displayText: 1,\r\n    engravedText: 2,\r\n    illuminatedCaps: 3,\r\n    titlingCaps: 4,\r\n    tallCaps: 5\r\n  },\r\n  characterShape: {\r\n    code: 20,\r\n    exclusive: true,\r\n    traditionalCharacters: 0,\r\n    simplifiedCharacters: 1,\r\n    JIS1978Characters: 2,\r\n    JIS1983Characters: 3,\r\n    JIS1990Characters: 4,\r\n    traditionalAltOne: 5,\r\n    traditionalAltTwo: 6,\r\n    traditionalAltThree: 7,\r\n    traditionalAltFour: 8,\r\n    traditionalAltFive: 9,\r\n    expertCharacters: 10,\r\n    JIS2004Characters: 11,\r\n    hojoCharacters: 12,\r\n    NLCCharacters: 13,\r\n    traditionalNamesCharacters: 14\r\n  },\r\n  numberCase: {\r\n    code: 21,\r\n    exclusive: true,\r\n    lowerCaseNumbers: 0,\r\n    upperCaseNumbers: 1\r\n  },\r\n  textSpacing: {\r\n    code: 22,\r\n    exclusive: true,\r\n    proportionalText: 0,\r\n    monospacedText: 1,\r\n    halfWidthText: 2,\r\n    thirdWidthText: 3,\r\n    quarterWidthText: 4,\r\n    altProportionalText: 5,\r\n    altHalfWidthText: 6\r\n  },\r\n  transliteration: {\r\n    code: 23,\r\n    exclusive: true,\r\n    noTransliteration: 0\r\n  },\r\n    // hanjaToHangul: 1\r\n    // hiraganaToKatakana: 2\r\n    // katakanaToHiragana: 3\r\n    // kanaToRomanization: 4\r\n    // romanizationToHiragana: 5\r\n    // romanizationToKatakana: 6\r\n    // hanjaToHangulAltOne: 7\r\n    // hanjaToHangulAltTwo: 8\r\n    // hanjaToHangulAltThree: 9\r\n  annotation: {\r\n    code: 24,\r\n    exclusive: true,\r\n    noAnnotation: 0,\r\n    boxAnnotation: 1,\r\n    roundedBoxAnnotation: 2,\r\n    circleAnnotation: 3,\r\n    invertedCircleAnnotation: 4,\r\n    parenthesisAnnotation: 5,\r\n    periodAnnotation: 6,\r\n    romanNumeralAnnotation: 7,\r\n    diamondAnnotation: 8,\r\n    invertedBoxAnnotation: 9,\r\n    invertedRoundedBoxAnnotation: 10\r\n  },\r\n  kanaSpacing: {\r\n    code: 25,\r\n    exclusive: true,\r\n    fullWidthKana: 0,\r\n    proportionalKana: 1\r\n  },\r\n  ideographicSpacing: {\r\n    code: 26,\r\n    exclusive: true,\r\n    fullWidthIdeographs: 0,\r\n    proportionalIdeographs: 1,\r\n    halfWidthIdeographs: 2\r\n  },\r\n  unicodeDecomposition: {\r\n    code: 27,\r\n    exclusive: false,\r\n    canonicalComposition: 0,\r\n    compatibilityComposition: 2,\r\n    transcodingComposition: 4\r\n  },\r\n  rubyKana: {\r\n    code: 28,\r\n    exclusive: false,\r\n    // noRubyKana: 0     # deprecated - use rubyKanaOff instead\r\n    // rubyKana: 1     # deprecated - use rubyKanaOn instead\r\n    rubyKana: 2\r\n  },\r\n  CJKSymbolAlternatives: {\r\n    code: 29,\r\n    exclusive: true,\r\n    noCJKSymbolAlternatives: 0,\r\n    CJKSymbolAltOne: 1,\r\n    CJKSymbolAltTwo: 2,\r\n    CJKSymbolAltThree: 3,\r\n    CJKSymbolAltFour: 4,\r\n    CJKSymbolAltFive: 5\r\n  },\r\n  ideographicAlternatives: {\r\n    code: 30,\r\n    exclusive: true,\r\n    noIdeographicAlternatives: 0,\r\n    ideographicAltOne: 1,\r\n    ideographicAltTwo: 2,\r\n    ideographicAltThree: 3,\r\n    ideographicAltFour: 4,\r\n    ideographicAltFive: 5\r\n  },\r\n  CJKVerticalRomanPlacement: {\r\n    code: 31,\r\n    exclusive: true,\r\n    CJKVerticalRomanCentered: 0,\r\n    CJKVerticalRomanHBaseline: 1\r\n  },\r\n  italicCJKRoman: {\r\n    code: 32,\r\n    exclusive: false,\r\n    // noCJKItalicRoman: 0     # deprecated - use CJKItalicRomanOff instead\r\n    // CJKItalicRoman: 1     # deprecated - use CJKItalicRomanOn instead\r\n    CJKItalicRoman: 2\r\n  },\r\n  caseSensitiveLayout: {\r\n    code: 33,\r\n    exclusive: false,\r\n    caseSensitiveLayout: 0,\r\n    caseSensitiveSpacing: 2\r\n  },\r\n  alternateKana: {\r\n    code: 34,\r\n    exclusive: false,\r\n    alternateHorizKana: 0,\r\n    alternateVertKana: 2\r\n  },\r\n  stylisticAlternatives: {\r\n    code: 35,\r\n    exclusive: false,\r\n    noStylisticAlternates: 0,\r\n    stylisticAltOne: 2,\r\n    stylisticAltTwo: 4,\r\n    stylisticAltThree: 6,\r\n    stylisticAltFour: 8,\r\n    stylisticAltFive: 10,\r\n    stylisticAltSix: 12,\r\n    stylisticAltSeven: 14,\r\n    stylisticAltEight: 16,\r\n    stylisticAltNine: 18,\r\n    stylisticAltTen: 20,\r\n    stylisticAltEleven: 22,\r\n    stylisticAltTwelve: 24,\r\n    stylisticAltThirteen: 26,\r\n    stylisticAltFourteen: 28,\r\n    stylisticAltFifteen: 30,\r\n    stylisticAltSixteen: 32,\r\n    stylisticAltSeventeen: 34,\r\n    stylisticAltEighteen: 36,\r\n    stylisticAltNineteen: 38,\r\n    stylisticAltTwenty: 40\r\n  },\r\n  contextualAlternates: {\r\n    code: 36,\r\n    exclusive: false,\r\n    contextualAlternates: 0,\r\n    swashAlternates: 2,\r\n    contextualSwashAlternates: 4\r\n  },\r\n  lowerCase: {\r\n    code: 37,\r\n    exclusive: true,\r\n    defaultLowerCase: 0,\r\n    lowerCaseSmallCaps: 1,\r\n    lowerCasePetiteCaps: 2\r\n  },\r\n  upperCase: {\r\n    code: 38,\r\n    exclusive: true,\r\n    defaultUpperCase: 0,\r\n    upperCaseSmallCaps: 1,\r\n    upperCasePetiteCaps: 2\r\n  },\r\n  languageTag: { // indices into ltag table\r\n    code: 39,\r\n    exclusive: true\r\n  },\r\n  CJKRomanSpacing: {\r\n    code: 103,\r\n    exclusive: true,\r\n    halfWidthCJKRoman: 0,\r\n    proportionalCJKRoman: 1,\r\n    defaultCJKRoman: 2,\r\n    fullWidthCJKRoman: 3\r\n  }\r\n};\r\n\r\nconst feature = (name, selector) => [features[name].code, features[name][selector]];\r\n\r\nconst OTMapping = {\r\n  rlig: feature('ligatures', 'requiredLigatures'),\r\n  clig: feature('ligatures', 'contextualLigatures'),\r\n  dlig: feature('ligatures', 'rareLigatures'),\r\n  hlig: feature('ligatures', 'historicalLigatures'),\r\n  liga: feature('ligatures', 'commonLigatures'),\r\n  hist: feature('ligatures', 'historicalLigatures'), // ??\r\n\r\n  smcp: feature('lowerCase', 'lowerCaseSmallCaps'),\r\n  pcap: feature('lowerCase', 'lowerCasePetiteCaps'),\r\n\r\n  frac: feature('fractions', 'diagonalFractions'),\r\n  dnom: feature('fractions', 'diagonalFractions'), // ??\r\n  numr: feature('fractions', 'diagonalFractions'), // ??\r\n  afrc: feature('fractions', 'verticalFractions'),\r\n  // aalt\r\n  // abvf, abvm, abvs, akhn, blwf, blwm, blws, cfar, cjct, cpsp, falt, isol, jalt, ljmo, mset?\r\n  // ltra, ltrm, nukt, pref, pres, pstf, psts, rand, rkrf, rphf, rtla, rtlm, size, tjmo, tnum?\r\n  // unic, vatu, vhal, vjmo, vpal, vrt2\r\n  // dist -> trak table?\r\n  // kern, vkrn -> kern table\r\n  // lfbd + opbd + rtbd -> opbd table?\r\n  // mark, mkmk -> acnt table?\r\n  // locl -> languageTag + ltag table\r\n\r\n  case: feature('caseSensitiveLayout', 'caseSensitiveLayout'), // also caseSensitiveSpacing\r\n  ccmp: feature('unicodeDecomposition', 'canonicalComposition'), // compatibilityComposition?\r\n  cpct: feature('CJKVerticalRomanPlacement', 'CJKVerticalRomanCentered'), // guess..., probably not given below\r\n  valt: feature('CJKVerticalRomanPlacement', 'CJKVerticalRomanCentered'),\r\n  swsh: feature('contextualAlternates', 'swashAlternates'),\r\n  cswh: feature('contextualAlternates', 'contextualSwashAlternates'),\r\n  curs: feature('cursiveConnection', 'cursive'), // ??\r\n  c2pc: feature('upperCase', 'upperCasePetiteCaps'),\r\n  c2sc: feature('upperCase', 'upperCaseSmallCaps'),\r\n\r\n  init: feature('smartSwash', 'wordInitialSwashes'), // ??\r\n  fin2: feature('smartSwash', 'wordFinalSwashes'), // ??\r\n  medi: feature('smartSwash', 'nonFinalSwashes'), // ??\r\n  med2: feature('smartSwash', 'nonFinalSwashes'), // ??\r\n  fin3: feature('smartSwash', 'wordFinalSwashes'), // ??\r\n  fina: feature('smartSwash', 'wordFinalSwashes'), // ??\r\n\r\n  pkna: feature('kanaSpacing', 'proportionalKana'),\r\n  half: feature('textSpacing', 'halfWidthText'), // also HalfWidthCJKRoman, HalfWidthIdeographs?\r\n  halt: feature('textSpacing', 'altHalfWidthText'),\r\n\r\n  hkna: feature('alternateKana', 'alternateHorizKana'),\r\n  vkna: feature('alternateKana', 'alternateVertKana'),\r\n  // hngl: feature 'transliteration', 'hanjaToHangulSelector' # deprecated\r\n\r\n  ital: feature('italicCJKRoman', 'CJKItalicRoman'),\r\n  lnum: feature('numberCase', 'upperCaseNumbers'),\r\n  onum: feature('numberCase', 'lowerCaseNumbers'),\r\n  mgrk: feature('mathematicalExtras', 'mathematicalGreek'),\r\n\r\n  // nalt: not enough info. what type of annotation?\r\n  // ornm: ditto, which ornament style?\r\n\r\n  calt: feature('contextualAlternates', 'contextualAlternates'), // or more?\r\n  vrt2: feature('verticalSubstitution', 'substituteVerticalForms'), // oh... below?\r\n  vert: feature('verticalSubstitution', 'substituteVerticalForms'),\r\n  tnum: feature('numberSpacing', 'monospacedNumbers'),\r\n  pnum: feature('numberSpacing', 'proportionalNumbers'),\r\n  sups: feature('verticalPosition', 'superiors'),\r\n  subs: feature('verticalPosition', 'inferiors'),\r\n  ordn: feature('verticalPosition', 'ordinals'),\r\n  pwid: feature('textSpacing', 'proportionalText'),\r\n  hwid: feature('textSpacing', 'halfWidthText'),\r\n  qwid: feature('textSpacing', 'quarterWidthText'), // also QuarterWidthNumbers?\r\n  twid: feature('textSpacing', 'thirdWidthText'), // also ThirdWidthNumbers?\r\n  fwid: feature('textSpacing', 'proportionalText'), //??\r\n  palt: feature('textSpacing', 'altProportionalText'),\r\n  trad: feature('characterShape', 'traditionalCharacters'),\r\n  smpl: feature('characterShape', 'simplifiedCharacters'),\r\n  jp78: feature('characterShape', 'JIS1978Characters'),\r\n  jp83: feature('characterShape', 'JIS1983Characters'),\r\n  jp90: feature('characterShape', 'JIS1990Characters'),\r\n  jp04: feature('characterShape', 'JIS2004Characters'),\r\n  expt: feature('characterShape', 'expertCharacters'),\r\n  hojo: feature('characterShape', 'hojoCharacters'),\r\n  nlck: feature('characterShape', 'NLCCharacters'),\r\n  tnam: feature('characterShape', 'traditionalNamesCharacters'),\r\n  ruby: feature('rubyKana', 'rubyKana'),\r\n  titl: feature('styleOptions', 'titlingCaps'),\r\n  zero: feature('typographicExtras', 'slashedZero'),\r\n\r\n  ss01: feature('stylisticAlternatives', 'stylisticAltOne'),\r\n  ss02: feature('stylisticAlternatives', 'stylisticAltTwo'),\r\n  ss03: feature('stylisticAlternatives', 'stylisticAltThree'),\r\n  ss04: feature('stylisticAlternatives', 'stylisticAltFour'),\r\n  ss05: feature('stylisticAlternatives', 'stylisticAltFive'),\r\n  ss06: feature('stylisticAlternatives', 'stylisticAltSix'),\r\n  ss07: feature('stylisticAlternatives', 'stylisticAltSeven'),\r\n  ss08: feature('stylisticAlternatives', 'stylisticAltEight'),\r\n  ss09: feature('stylisticAlternatives', 'stylisticAltNine'),\r\n  ss10: feature('stylisticAlternatives', 'stylisticAltTen'),\r\n  ss11: feature('stylisticAlternatives', 'stylisticAltEleven'),\r\n  ss12: feature('stylisticAlternatives', 'stylisticAltTwelve'),\r\n  ss13: feature('stylisticAlternatives', 'stylisticAltThirteen'),\r\n  ss14: feature('stylisticAlternatives', 'stylisticAltFourteen'),\r\n  ss15: feature('stylisticAlternatives', 'stylisticAltFifteen'),\r\n  ss16: feature('stylisticAlternatives', 'stylisticAltSixteen'),\r\n  ss17: feature('stylisticAlternatives', 'stylisticAltSeventeen'),\r\n  ss18: feature('stylisticAlternatives', 'stylisticAltEighteen'),\r\n  ss19: feature('stylisticAlternatives', 'stylisticAltNineteen'),\r\n  ss20: feature('stylisticAlternatives', 'stylisticAltTwenty')\r\n};\r\n\r\n  // salt: feature 'stylisticAlternatives', 'stylisticAltOne' # hmm, which one to choose\r\n\r\n// Add cv01-cv99 features\r\nfor (let i = 1; i <= 99; i++) {\r\n  OTMapping[`cv${`00${i}`.slice(-2)}`] = [features.characterAlternatives.code, i];\r\n}\r\n\r\n// create inverse mapping\r\nlet AATMapping = {};\r\nfor (let ot in OTMapping) {\r\n  let aat = OTMapping[ot];\r\n  if (AATMapping[aat[0]] == null) {\r\n    AATMapping[aat[0]] = {};\r\n  }\r\n\r\n  AATMapping[aat[0]][aat[1]] = ot;\r\n}\r\n\r\n// Maps an array of OpenType features to AAT features\r\n// in the form of {featureType:{featureSetting:true}}\r\nexport function mapOTToAAT(features) {\r\n  let res = {};\r\n  for (let k in features) {\r\n    let r;\r\n    if (r = OTMapping[k]) {\r\n      if (res[r[0]] == null) {\r\n        res[r[0]] = {};\r\n      }\r\n\r\n      res[r[0]][r[1]] = features[k];\r\n    }\r\n  }\r\n\r\n  return res;\r\n}\r\n\r\n// Maps strings in a [featureType, featureSetting]\r\n// to their equivalent number codes\r\nfunction mapFeatureStrings(f) {\r\n  let [type, setting] = f;\r\n  if (isNaN(type)) {\r\n    var typeCode = features[type] && features[type].code;\r\n  } else {\r\n    var typeCode = type;\r\n  }\r\n\r\n  if (isNaN(setting)) {\r\n    var settingCode = features[type] && features[type][setting];\r\n  } else {\r\n    var settingCode = setting;\r\n  }\r\n\r\n  return [typeCode, settingCode];\r\n}\r\n\r\n// Maps AAT features to an array of OpenType features\r\n// Supports both arrays in the form of [[featureType, featureSetting]]\r\n// and objects in the form of {featureType:{featureSetting:true}}\r\n// featureTypes and featureSettings can be either strings or number codes\r\nexport function mapAATToOT(features) {\r\n  let res = {};\r\n  if (Array.isArray(features)) {\r\n    for (let k = 0; k < features.length; k++) {\r\n      let r;\r\n      let f = mapFeatureStrings(features[k]);\r\n      if (r = AATMapping[f[0]] && AATMapping[f[0]][f[1]]) {\r\n        res[r] = true;\r\n      }\r\n    }\r\n\r\n  } else if (typeof features === 'object') {\r\n    for (let type in features) {\r\n      let feature = features[type];\r\n      for (let setting in feature) {\r\n        let r;\r\n        let f = mapFeatureStrings([type, setting]);\r\n        if (feature[setting] && (r = AATMapping[f[0]] && AATMapping[f[0]][f[1]])) {\r\n          res[r] = true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return Object.keys(res);\r\n}\r\n","import {cache} from '../decorators';\r\nimport {range} from '../utils';\r\n\r\nexport default class AATLookupTable {\r\n  constructor(table) {\r\n    this.table = table;\r\n  }\r\n\r\n  lookup(glyph) {\r\n    switch (this.table.version) {\r\n      case 0: // simple array format\r\n        return this.table.values.getItem(glyph);\r\n\r\n      case 2: // segment format\r\n      case 4: {\r\n        let min = 0;\r\n        let max = this.table.binarySearchHeader.nUnits - 1;\r\n\r\n        while (min <= max) {\r\n          var mid = (min + max) >> 1;\r\n          var seg = this.table.segments[mid];\r\n\r\n          // special end of search value\r\n          if (seg.firstGlyph === 0xffff) {\r\n            return null;\r\n          }\r\n\r\n          if (glyph < seg.firstGlyph) {\r\n            max = mid - 1;\r\n          } else if (glyph > seg.lastGlyph) {\r\n            min = mid + 1;\r\n          } else {\r\n            if (this.table.version === 2) {\r\n              return seg.value;\r\n            } else {\r\n              return seg.values[glyph - seg.firstGlyph];\r\n            }\r\n          }\r\n        }\r\n\r\n        return null;\r\n      }\r\n\r\n      case 6: { // lookup single\r\n        let min = 0;\r\n        let max = this.table.binarySearchHeader.nUnits - 1;\r\n\r\n        while (min <= max) {\r\n          var mid = (min + max) >> 1;\r\n          var seg = this.table.segments[mid];\r\n\r\n          // special end of search value\r\n          if (seg.glyph === 0xffff) {\r\n            return null;\r\n          }\r\n\r\n          if (glyph < seg.glyph) {\r\n            max = mid - 1;\r\n          } else if (glyph > seg.glyph) {\r\n            min = mid + 1;\r\n          } else {\r\n            return seg.value;\r\n          }\r\n        }\r\n\r\n        return null;\r\n      }\r\n\r\n      case 8: // lookup trimmed\r\n        return this.table.values[glyph - this.table.firstGlyph];\r\n\r\n      default:\r\n        throw new Error(`Unknown lookup table format: ${this.table.version}`);\r\n    }\r\n  }\r\n\r\n  @cache\r\n  glyphsForValue(classValue) {\r\n    let res = [];\r\n\r\n    switch (this.table.version) {\r\n      case 2: // segment format\r\n      case 4: {\r\n        for (let segment of this.table.segments) {\r\n          if ((this.table.version === 2 && segment.value === classValue)) {\r\n            res.push(...range(segment.firstGlyph, segment.lastGlyph + 1));\r\n          } else {\r\n            for (let index = 0; index < segment.values.length; index++) {\r\n              if (segment.values[index] === classValue) {\r\n                res.push(segment.firstGlyph + index);\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        break;\r\n      }\r\n\r\n      case 6: { // lookup single\r\n        for (let segment of this.table.segments) {\r\n          if (segment.value === classValue) {\r\n            res.push(segment.glyph);\r\n          }\r\n        }\r\n\r\n        break;\r\n      }\r\n\r\n      case 8: { // lookup trimmed\r\n        for (let i = 0; i < this.table.values.length; i++) {\r\n          if (this.table.values[i] === classValue) {\r\n            res.push(this.table.firstGlyph + i);\r\n          }\r\n        }\r\n\r\n        break;\r\n      }\r\n\r\n      default:\r\n        throw new Error(`Unknown lookup table format: ${this.table.version}`);\r\n    }\r\n\r\n    return res;\r\n  }\r\n}\r\n","import AATLookupTable from './AATLookupTable';\r\n\r\nconst START_OF_TEXT_STATE = 0;\r\nconst START_OF_LINE_STATE = 1;\r\n\r\nconst END_OF_TEXT_CLASS = 0;\r\nconst OUT_OF_BOUNDS_CLASS = 1;\r\nconst DELETED_GLYPH_CLASS = 2;\r\nconst END_OF_LINE_CLASS = 3;\r\n\r\nconst DONT_ADVANCE = 0x4000;\r\n\r\nexport default class AATStateMachine {\r\n  constructor(stateTable) {\r\n    this.stateTable = stateTable;\r\n    this.lookupTable = new AATLookupTable(stateTable.classTable);\r\n  }\r\n\r\n  process(glyphs, reverse, processEntry) {\r\n    let currentState = START_OF_TEXT_STATE; // START_OF_LINE_STATE is used for kashida glyph insertions sometimes I think?\r\n    let index = reverse ? glyphs.length - 1 : 0;\r\n    let dir = reverse ? -1 : 1;\r\n\r\n    while ((dir === 1 && index <= glyphs.length) || (dir === -1 && index >= -1)) {\r\n      let glyph = null;\r\n      let classCode = OUT_OF_BOUNDS_CLASS;\r\n      let shouldAdvance = true;\r\n\r\n      if (index === glyphs.length || index === -1) {\r\n        classCode = END_OF_TEXT_CLASS;\r\n      } else {\r\n        glyph = glyphs[index];\r\n        if (glyph.id === 0xffff) { // deleted glyph\r\n          classCode = DELETED_GLYPH_CLASS;\r\n        } else {\r\n          classCode = this.lookupTable.lookup(glyph.id);\r\n          if (classCode == null) {\r\n            classCode = OUT_OF_BOUNDS_CLASS;\r\n          }\r\n        }\r\n      }\r\n\r\n      let row = this.stateTable.stateArray.getItem(currentState);\r\n      let entryIndex = row[classCode];\r\n      let entry = this.stateTable.entryTable.getItem(entryIndex);\r\n\r\n      if (classCode !== END_OF_TEXT_CLASS && classCode !==  DELETED_GLYPH_CLASS) {\r\n        processEntry(glyph, entry, index);\r\n        shouldAdvance = !(entry.flags & DONT_ADVANCE);\r\n      }\r\n\r\n      currentState = entry.newState;\r\n      if (shouldAdvance) {\r\n        index += dir;\r\n      }\r\n    }\r\n\r\n    return glyphs;\r\n  }\r\n\r\n  /**\r\n   * Performs a depth-first traversal of the glyph strings\r\n   * represented by the state machine.\r\n   */\r\n  traverse(opts, state = 0, visited = new Set) {\r\n    if (visited.has(state)) {\r\n      return;\r\n    }\r\n\r\n    visited.add(state);\r\n\r\n    let {nClasses, stateArray, entryTable} = this.stateTable;\r\n    let row = stateArray.getItem(state);\r\n\r\n    // Skip predefined classes\r\n    for (let classCode = 4; classCode < nClasses; classCode++) {\r\n      let entryIndex = row[classCode];\r\n      let entry = entryTable.getItem(entryIndex);\r\n\r\n      // Try all glyphs in the class\r\n      for (let glyph of this.lookupTable.glyphsForValue(classCode)) {\r\n        if (opts.enter) {\r\n          opts.enter(glyph, entry);\r\n        }\r\n\r\n        if (entry.newState !== 0) {\r\n          this.traverse(opts, entry.newState, visited);\r\n        }\r\n\r\n        if (opts.exit) {\r\n          opts.exit(glyph, entry);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import AATStateMachine from './AATStateMachine';\r\nimport AATLookupTable from './AATLookupTable';\r\nimport {cache} from '../decorators';\r\n\r\n// indic replacement flags\r\nconst MARK_FIRST = 0x8000;\r\nconst MARK_LAST  = 0x2000;\r\nconst VERB       = 0x000F;\r\n\r\n// contextual substitution and glyph insertion flag\r\nconst SET_MARK = 0x8000;\r\n\r\n// ligature entry flags\r\nconst SET_COMPONENT  = 0x8000;\r\nconst PERFORM_ACTION = 0x2000;\r\n\r\n// ligature action masks\r\nconst LAST_MASK   = 0x80000000;\r\nconst STORE_MASK  = 0x40000000;\r\nconst OFFSET_MASK = 0x3FFFFFFF;\r\n\r\nconst VERTICAL_ONLY           = 0x800000;\r\nconst REVERSE_DIRECTION       = 0x400000;\r\nconst HORIZONTAL_AND_VERTICAL = 0x200000;\r\n\r\n// glyph insertion flags\r\nconst CURRENT_IS_KASHIDA_LIKE = 0x2000;\r\nconst MARKED_IS_KASHIDA_LIKE  = 0x1000;\r\nconst CURRENT_INSERT_BEFORE   = 0x0800;\r\nconst MARKED_INSERT_BEFORE    = 0x0400;\r\nconst CURRENT_INSERT_COUNT    = 0x03E0;\r\nconst MARKED_INSERT_COUNT     = 0x001F;\r\n\r\nexport default class AATMorxProcessor {\r\n  constructor(font) {\r\n    this.processIndicRearragement = this.processIndicRearragement.bind(this);\r\n    this.processContextualSubstitution = this.processContextualSubstitution.bind(this);\r\n    this.processLigature = this.processLigature.bind(this);\r\n    this.processNoncontextualSubstitutions = this.processNoncontextualSubstitutions.bind(this);\r\n    this.processGlyphInsertion = this.processGlyphInsertion.bind(this);\r\n    this.font = font;\r\n    this.morx = font.morx;\r\n    this.inputCache = null;\r\n  }\r\n\r\n  // Processes an array of glyphs and applies the specified features\r\n  // Features should be in the form of {featureType:{featureSetting:boolean}}\r\n  process(glyphs, features = {}) {\r\n    for (let chain of this.morx.chains) {\r\n      let flags = chain.defaultFlags;\r\n\r\n      // enable/disable the requested features\r\n      for (let feature of chain.features) {\r\n        let f;\r\n        if (f = features[feature.featureType]) {\r\n          if (f[feature.featureSetting]) {\r\n            flags &= feature.disableFlags;\r\n            flags |= feature.enableFlags;\r\n          } else if (f[feature.featureSetting] === false) {\r\n            flags |= ~feature.disableFlags;\r\n            flags &= ~feature.enableFlags;\r\n          }\r\n        }\r\n      }\r\n\r\n      for (let subtable of chain.subtables) {\r\n        if (subtable.subFeatureFlags & flags) {\r\n          this.processSubtable(subtable, glyphs);\r\n        }\r\n      }\r\n    }\r\n\r\n    // remove deleted glyphs\r\n    let index = glyphs.length - 1;\r\n    while (index >= 0) {\r\n      if (glyphs[index].id === 0xffff) {\r\n        glyphs.splice(index, 1);\r\n      }\r\n\r\n      index--;\r\n    }\r\n\r\n    return glyphs;\r\n  }\r\n\r\n  processSubtable(subtable, glyphs) {\r\n    this.subtable = subtable;\r\n    this.glyphs = glyphs;\r\n    if (this.subtable.type === 4) {\r\n      this.processNoncontextualSubstitutions(this.subtable, this.glyphs);\r\n      return;\r\n    }\r\n\r\n    this.ligatureStack = [];\r\n    this.markedGlyph = null;\r\n    this.firstGlyph = null;\r\n    this.lastGlyph = null;\r\n    this.markedIndex = null;\r\n\r\n    let stateMachine = this.getStateMachine(subtable);\r\n    let process = this.getProcessor();\r\n\r\n    let reverse = !!(this.subtable.coverage & REVERSE_DIRECTION);\r\n    return stateMachine.process(this.glyphs, reverse, process);\r\n  }\r\n\r\n  @cache\r\n  getStateMachine(subtable) {\r\n    return new AATStateMachine(subtable.table.stateTable);\r\n  }\r\n\r\n  getProcessor() {\r\n    switch (this.subtable.type) {\r\n      case 0:\r\n        return this.processIndicRearragement;\r\n      case 1:\r\n        return this.processContextualSubstitution;\r\n      case 2:\r\n        return this.processLigature;\r\n      case 4:\r\n        return this.processNoncontextualSubstitutions;\r\n      case 5:\r\n        return this.processGlyphInsertion;\r\n      default:\r\n        throw new Error(`Invalid morx subtable type: ${this.subtable.type}`);\r\n    }\r\n  }\r\n\r\n  processIndicRearragement(glyph, entry, index) {\r\n    if (entry.flags & MARK_FIRST) {\r\n      this.firstGlyph = index;\r\n    }\r\n\r\n    if (entry.flags & MARK_LAST) {\r\n      this.lastGlyph = index;\r\n    }\r\n\r\n    reorderGlyphs(this.glyphs, entry.flags & VERB, this.firstGlyph, this.lastGlyph);\r\n  }\r\n\r\n  processContextualSubstitution(glyph, entry, index) {\r\n    let subsitutions = this.subtable.table.substitutionTable.items;\r\n    if (entry.markIndex !== 0xffff) {\r\n      let lookup = subsitutions.getItem(entry.markIndex);\r\n      let lookupTable = new AATLookupTable(lookup);\r\n      glyph = this.glyphs[this.markedGlyph];\r\n      var gid = lookupTable.lookup(glyph.id);\r\n      if (gid) {\r\n        this.glyphs[this.markedGlyph] = this.font.getGlyph(gid, glyph.codePoints);\r\n      }\r\n    }\r\n\r\n    if (entry.currentIndex !== 0xffff) {\r\n      let lookup = subsitutions.getItem(entry.currentIndex);\r\n      let lookupTable = new AATLookupTable(lookup);\r\n      glyph = this.glyphs[index];\r\n      var gid = lookupTable.lookup(glyph.id);\r\n      if (gid) {\r\n        this.glyphs[index] = this.font.getGlyph(gid, glyph.codePoints);\r\n      }\r\n    }\r\n\r\n    if (entry.flags & SET_MARK) {\r\n      this.markedGlyph = index;\r\n    }\r\n  }\r\n\r\n  processLigature(glyph, entry, index) {\r\n    if (entry.flags & SET_COMPONENT) {\r\n      this.ligatureStack.push(index);\r\n    }\r\n\r\n    if (entry.flags & PERFORM_ACTION) {\r\n      let actions = this.subtable.table.ligatureActions;\r\n      let components = this.subtable.table.components;\r\n      let ligatureList = this.subtable.table.ligatureList;\r\n\r\n      let actionIndex = entry.action;\r\n      let last = false;\r\n      let ligatureIndex = 0;\r\n      let codePoints = [];\r\n      let ligatureGlyphs = [];\r\n\r\n      while (!last) {\r\n        let componentGlyph = this.ligatureStack.pop();\r\n        codePoints.unshift(...this.glyphs[componentGlyph].codePoints);\r\n\r\n        let action = actions.getItem(actionIndex++);\r\n        last = !!(action & LAST_MASK);\r\n        let store = !!(action & STORE_MASK);\r\n        let offset = (action & OFFSET_MASK) << 2 >> 2; // sign extend 30 to 32 bits\r\n        offset += this.glyphs[componentGlyph].id;\r\n\r\n        let component = components.getItem(offset);\r\n        ligatureIndex += component;\r\n\r\n        if (last || store) {\r\n          let ligatureEntry = ligatureList.getItem(ligatureIndex);\r\n          this.glyphs[componentGlyph] = this.font.getGlyph(ligatureEntry, codePoints);\r\n          ligatureGlyphs.push(componentGlyph);\r\n          ligatureIndex = 0;\r\n          codePoints = [];\r\n        } else {\r\n          this.glyphs[componentGlyph] = this.font.getGlyph(0xffff);\r\n        }\r\n      }\r\n\r\n      // Put ligature glyph indexes back on the stack\r\n      this.ligatureStack.push(...ligatureGlyphs);\r\n    }\r\n  }\r\n\r\n  processNoncontextualSubstitutions(subtable, glyphs, index) {\r\n    let lookupTable = new AATLookupTable(subtable.table.lookupTable);\r\n\r\n    for (index = 0; index < glyphs.length; index++) {\r\n      let glyph = glyphs[index];\r\n      if (glyph.id !== 0xffff) {\r\n        let gid = lookupTable.lookup(glyph.id);\r\n        if (gid) { // 0 means do nothing\r\n          glyphs[index] = this.font.getGlyph(gid, glyph.codePoints);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  _insertGlyphs(glyphIndex, insertionActionIndex, count, isBefore) {\r\n    let insertions = [];\r\n    while (count--) {\r\n      let gid = this.subtable.table.insertionActions.getItem(insertionActionIndex++);\r\n      insertions.push(this.font.getGlyph(gid));\r\n    }\r\n\r\n    if (!isBefore) {\r\n      glyphIndex++;\r\n    }\r\n\r\n    this.glyphs.splice(glyphIndex, 0, ...insertions);\r\n  }\r\n\r\n  processGlyphInsertion(glyph, entry, index) {\r\n    if (entry.flags & SET_MARK) {\r\n      this.markedIndex = index;\r\n    }\r\n\r\n    if (entry.markedInsertIndex !== 0xffff) {\r\n      let count = (entry.flags & MARKED_INSERT_COUNT) >>> 5;\r\n      let isBefore = !!(entry.flags & MARKED_INSERT_BEFORE);\r\n      this._insertGlyphs(this.markedIndex, entry.markedInsertIndex, count, isBefore);\r\n    }\r\n\r\n    if (entry.currentInsertIndex !== 0xffff) {\r\n      let count = (entry.flags & CURRENT_INSERT_COUNT) >>> 5;\r\n      let isBefore = !!(entry.flags & CURRENT_INSERT_BEFORE);\r\n      this._insertGlyphs(index, entry.currentInsertIndex, count, isBefore);\r\n    }\r\n  }\r\n\r\n  getSupportedFeatures() {\r\n    let features = [];\r\n    for (let chain of this.morx.chains) {\r\n      for (let feature of chain.features) {\r\n        features.push([feature.featureType, feature.featureSetting]);\r\n      }\r\n    }\r\n\r\n    return features;\r\n  }\r\n\r\n  generateInputs(gid) {\r\n    if (!this.inputCache) {\r\n      this.generateInputCache();\r\n    }\r\n\r\n    return this.inputCache[gid] || [];\r\n  }\r\n\r\n  generateInputCache() {\r\n    this.inputCache = {};\r\n\r\n    for (let chain of this.morx.chains) {\r\n      let flags = chain.defaultFlags;\r\n\r\n      for (let subtable of chain.subtables) {\r\n        if (subtable.subFeatureFlags & flags) {\r\n          this.generateInputsForSubtable(subtable);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  generateInputsForSubtable(subtable) {\r\n    // Currently, only supporting ligature subtables.\r\n    if (subtable.type !== 2) {\r\n      return;\r\n    }\r\n\r\n    let reverse = !!(subtable.coverage & REVERSE_DIRECTION);\r\n    if (reverse) {\r\n      throw new Error('Reverse subtable, not supported.');\r\n    }\r\n\r\n    this.subtable = subtable;\r\n    this.ligatureStack = [];\r\n\r\n    let stateMachine = this.getStateMachine(subtable);\r\n    let process = this.getProcessor();\r\n\r\n    let input = [];\r\n    let stack = [];\r\n    this.glyphs = [];\r\n\r\n    stateMachine.traverse({\r\n      enter: (glyph, entry) => {\r\n        let glyphs = this.glyphs;\r\n        stack.push({\r\n          glyphs: glyphs.slice(),\r\n          ligatureStack: this.ligatureStack.slice()\r\n        });\r\n\r\n        // Add glyph to input and glyphs to process.\r\n        let g = this.font.getGlyph(glyph);\r\n        input.push(g);\r\n        glyphs.push(input[input.length - 1]);\r\n\r\n        // Process ligature substitution\r\n        process(glyphs[glyphs.length - 1], entry, glyphs.length - 1);\r\n\r\n        // Add input to result if only one matching (non-deleted) glyph remains.\r\n        let count = 0;\r\n        let found = 0;\r\n        for (let i = 0; i < glyphs.length && count <= 1; i++) {\r\n          if (glyphs[i].id !== 0xffff) {\r\n            count++;\r\n            found = glyphs[i].id;\r\n          }\r\n        }\r\n\r\n        if (count === 1) {\r\n          let result = input.map(g => g.id);\r\n          let cache = this.inputCache[found];\r\n          if (cache) {\r\n            cache.push(result);\r\n          } else {\r\n            this.inputCache[found] = [result];\r\n          }\r\n        }\r\n      },\r\n\r\n      exit: () => {\r\n        ({glyphs: this.glyphs, ligatureStack: this.ligatureStack} = stack.pop());\r\n        input.pop();\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// swaps the glyphs in rangeA with those in rangeB\r\n// reverse the glyphs inside those ranges if specified\r\n// ranges are in [offset, length] format\r\nfunction swap(glyphs, rangeA, rangeB, reverseA = false, reverseB = false) {\r\n  let end = glyphs.splice(rangeB[0] - (rangeB[1] - 1), rangeB[1]);\r\n  if (reverseB) {\r\n    end.reverse();\r\n  }\r\n\r\n  let start = glyphs.splice(rangeA[0], rangeA[1], ...end);\r\n  if (reverseA) {\r\n    start.reverse();\r\n  }\r\n\r\n  glyphs.splice(rangeB[0] - (rangeA[1] - 1), 0, ...start);\r\n  return glyphs;\r\n}\r\n\r\nfunction reorderGlyphs(glyphs, verb, firstGlyph, lastGlyph) {\r\n  let length = lastGlyph - firstGlyph + 1;\r\n  switch (verb) {\r\n    case 0: // no change\r\n      return glyphs;\r\n\r\n    case 1: // Ax => xA\r\n      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 0]);\r\n\r\n    case 2: // xD => Dx\r\n      return swap(glyphs, [firstGlyph, 0], [lastGlyph, 1]);\r\n\r\n    case 3: // AxD => DxA\r\n      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 1]);\r\n\r\n    case 4: // ABx => xAB\r\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 0]);\r\n\r\n    case 5: // ABx => xBA\r\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 0], true, false);\r\n\r\n    case 6: // xCD => CDx\r\n      return swap(glyphs, [firstGlyph, 0], [lastGlyph, 2]);\r\n\r\n    case 7: // xCD => DCx\r\n      return swap(glyphs, [firstGlyph, 0], [lastGlyph, 2], false, true);\r\n\r\n    case 8: // AxCD => CDxA\r\n      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 2]);\r\n\r\n    case 9: // AxCD => DCxA\r\n      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 2], false, true);\r\n\r\n    case 10: // ABxD => DxAB\r\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 1]);\r\n\r\n    case 11: // ABxD => DxBA\r\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 1], true, false);\r\n\r\n    case 12: // ABxCD => CDxAB\r\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2]);\r\n\r\n    case 13: // ABxCD => CDxBA\r\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], true, false);\r\n\r\n    case 14: // ABxCD => DCxAB\r\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], false, true);\r\n\r\n    case 15: // ABxCD => DCxBA\r\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], true, true);\r\n\r\n    default:\r\n      throw new Error(`Unknown verb: ${verb}`);\r\n  }\r\n}\r\n","import * as AATFeatureMap from './AATFeatureMap';\r\nimport * as Script from '../layout/Script';\r\nimport AATMorxProcessor from './AATMorxProcessor';\r\n\r\nexport default class AATLayoutEngine {\r\n  constructor(font) {\r\n    this.font = font;\r\n    this.morxProcessor = new AATMorxProcessor(font);\r\n    this.fallbackPosition = false;\r\n  }\r\n\r\n  substitute(glyphRun) {\r\n    // AAT expects the glyphs to be in visual order prior to morx processing,\r\n    // so reverse the glyphs if the script is right-to-left.\r\n    if (glyphRun.direction === 'rtl') {\r\n      glyphRun.glyphs.reverse();\r\n    }\r\n\r\n    this.morxProcessor.process(glyphRun.glyphs, AATFeatureMap.mapOTToAAT(glyphRun.features));\r\n  }\r\n\r\n  getAvailableFeatures(script, language) {\r\n    return AATFeatureMap.mapAATToOT(this.morxProcessor.getSupportedFeatures());\r\n  }\r\n\r\n  stringsForGlyph(gid) {\r\n    let glyphStrings = this.morxProcessor.generateInputs(gid);\r\n    let result = new Set;\r\n\r\n    for (let glyphs of glyphStrings) {\r\n      this._addStrings(glyphs, 0, result, '');\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  _addStrings(glyphs, index, strings, string) {\r\n    let codePoints = this.font._cmapProcessor.codePointsForGlyph(glyphs[index]);\r\n\r\n    for (let codePoint of codePoints) {\r\n      let s = string + String.fromCodePoint(codePoint);\r\n      if (index < glyphs.length - 1) {\r\n        this._addStrings(glyphs, index + 1, strings, s);\r\n      } else {\r\n        strings.add(s);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import * as Script from '../layout/Script';\r\n\r\n/**\r\n * ShapingPlans are used by the OpenType shapers to store which\r\n * features should by applied, and in what order to apply them.\r\n * The features are applied in groups called stages. A feature\r\n * can be applied globally to all glyphs, or locally to only\r\n * specific glyphs.\r\n *\r\n * @private\r\n */\r\nexport default class ShapingPlan {\r\n  constructor(font, script, direction) {\r\n    this.font = font;\r\n    this.script = script;\r\n    this.direction = direction;\r\n    this.stages = [];\r\n    this.globalFeatures = {};\r\n    this.allFeatures = {};\r\n  }\r\n\r\n  /**\r\n   * Adds the given features to the last stage.\r\n   * Ignores features that have already been applied.\r\n   */\r\n  _addFeatures(features, global) {\r\n    let stageIndex = this.stages.length - 1;\r\n    let stage = this.stages[stageIndex];\r\n    for (let feature of features) {\r\n      if (this.allFeatures[feature] == null) {\r\n        stage.push(feature);\r\n        this.allFeatures[feature] = stageIndex;\r\n\r\n        if (global) {\r\n          this.globalFeatures[feature] = true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add features to the last stage\r\n   */\r\n  add(arg, global = true) {\r\n    if (this.stages.length === 0) {\r\n      this.stages.push([]);\r\n    }\r\n\r\n    if (typeof arg === 'string') {\r\n      arg = [arg];\r\n    }\r\n\r\n    if (Array.isArray(arg)) {\r\n      this._addFeatures(arg, global);\r\n    } else if (typeof arg === 'object') {\r\n      this._addFeatures(arg.global || [], true);\r\n      this._addFeatures(arg.local || [], false);\r\n    } else {\r\n      throw new Error(\"Unsupported argument to ShapingPlan#add\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a new stage\r\n   */\r\n  addStage(arg, global) {\r\n    if (typeof arg === 'function') {\r\n      this.stages.push(arg, []);\r\n    } else {\r\n      this.stages.push([]);\r\n      this.add(arg, global);\r\n    }\r\n  }\r\n\r\n  setFeatureOverrides(features) {\r\n    if (Array.isArray(features)) {\r\n      this.add(features);\r\n    } else if (typeof features === 'object') {\r\n      for (let tag in features) {\r\n        if (features[tag]) {\r\n          this.add(tag);\r\n        } else if (this.allFeatures[tag] != null) {\r\n          let stage = this.stages[this.allFeatures[tag]];\r\n          stage.splice(stage.indexOf(tag), 1);\r\n          delete this.allFeatures[tag];\r\n          delete this.globalFeatures[tag];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Assigns the global features to the given glyphs\r\n   */\r\n  assignGlobalFeatures(glyphs) {\r\n    for (let glyph of glyphs) {\r\n      for (let feature in this.globalFeatures) {\r\n        glyph.features[feature] = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Executes the planned stages using the given OTProcessor\r\n   */\r\n  process(processor, glyphs, positions) {\r\n    for (let stage of this.stages) {\r\n      if (typeof stage === 'function') {\r\n        if (!positions) {\r\n          stage(this.font, glyphs, this);\r\n        }\r\n\r\n      } else if (stage.length > 0) {\r\n        processor.applyFeatures(stage, glyphs, positions);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import unicode from 'unicode-properties';\r\n\r\nconst VARIATION_FEATURES = ['rvrn'];\r\nconst COMMON_FEATURES = ['ccmp', 'locl', 'rlig', 'mark', 'mkmk'];\r\nconst FRACTIONAL_FEATURES = ['frac', 'numr', 'dnom'];\r\nconst HORIZONTAL_FEATURES = ['calt', 'clig', 'liga', 'rclt', 'curs', 'kern'];\r\nconst VERTICAL_FEATURES = ['vert'];\r\nconst DIRECTIONAL_FEATURES = {\r\n  ltr: ['ltra', 'ltrm'],\r\n  rtl: ['rtla', 'rtlm']\r\n};\r\n\r\nexport default class DefaultShaper {\r\n  static zeroMarkWidths = 'AFTER_GPOS';\r\n  static plan(plan, glyphs, features) {\r\n    // Plan the features we want to apply\r\n    this.planPreprocessing(plan);\r\n    this.planFeatures(plan);\r\n    this.planPostprocessing(plan, features);\r\n\r\n    // Assign the global features to all the glyphs\r\n    plan.assignGlobalFeatures(glyphs);\r\n\r\n    // Assign local features to glyphs\r\n    this.assignFeatures(plan, glyphs);\r\n  }\r\n\r\n  static planPreprocessing(plan) {\r\n    plan.add({\r\n      global: [...VARIATION_FEATURES, ...DIRECTIONAL_FEATURES[plan.direction]],\r\n      local: FRACTIONAL_FEATURES\r\n    });\r\n  }\r\n\r\n  static planFeatures(plan) {\r\n    // Do nothing by default. Let subclasses override this.\r\n  }\r\n\r\n  static planPostprocessing(plan, userFeatures) {\r\n    plan.add([...COMMON_FEATURES, ...HORIZONTAL_FEATURES]);\r\n    plan.setFeatureOverrides(userFeatures);\r\n  }\r\n\r\n  static assignFeatures(plan, glyphs) {\r\n    // Enable contextual fractions\r\n    for (let i = 0; i < glyphs.length; i++) {\r\n      let glyph = glyphs[i];\r\n      if (glyph.codePoints[0] === 0x2044) { // fraction slash\r\n        let start = i;\r\n        let end = i + 1;\r\n\r\n        // Apply numerator\r\n        while (start > 0 && unicode.isDigit(glyphs[start - 1].codePoints[0])) {\r\n          glyphs[start - 1].features.numr = true;\r\n          glyphs[start - 1].features.frac = true;\r\n          start--;\r\n        }\r\n\r\n        // Apply denominator\r\n        while (end < glyphs.length && unicode.isDigit(glyphs[end].codePoints[0])) {\r\n          glyphs[end].features.dnom = true;\r\n          glyphs[end].features.frac = true;\r\n          end++;\r\n        }\r\n\r\n        // Apply fraction slash\r\n        glyph.features.frac = true;\r\n        i = end - 1;\r\n      }\r\n    }\r\n  }\r\n}\r\n","import DefaultShaper from './DefaultShaper';\r\nimport unicode from 'unicode-properties';\r\nimport UnicodeTrie from 'unicode-trie';\r\n\r\nconst trie = new UnicodeTrie(require('fs').readFileSync(__dirname + '/data.trie'));\r\nconst FEATURES = ['isol', 'fina', 'fin2', 'fin3', 'medi', 'med2', 'init'];\r\n\r\nconst ShapingClasses = {\r\n  Non_Joining: 0,\r\n  Left_Joining: 1,\r\n  Right_Joining: 2,\r\n  Dual_Joining: 3,\r\n  Join_Causing: 3,\r\n  ALAPH: 4,\r\n  'DALATH RISH': 5,\r\n  Transparent: 6\r\n};\r\n\r\nconst ISOL = 'isol';\r\nconst FINA = 'fina';\r\nconst FIN2 = 'fin2';\r\nconst FIN3 = 'fin3';\r\nconst MEDI = 'medi';\r\nconst MED2 = 'med2';\r\nconst INIT = 'init';\r\nconst NONE = null;\r\n\r\n// Each entry is [prevAction, curAction, nextState]\r\nconst STATE_TABLE = [\r\n  //   Non_Joining,        Left_Joining,       Right_Joining,     Dual_Joining,           ALAPH,            DALATH RISH\r\n  // State 0: prev was U,  not willing to join.\r\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ NONE, ISOL, 1 ],  [ NONE, ISOL, 2 ],  [ NONE, ISOL, 1 ],  [ NONE, ISOL, 6 ] ],\r\n\r\n  // State 1: prev was R or ISOL/ALAPH,  not willing to join.\r\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ NONE, ISOL, 1 ],  [ NONE, ISOL, 2 ],  [ NONE, FIN2, 5 ],  [ NONE, ISOL, 6 ] ],\r\n\r\n  // State 2: prev was D/L in ISOL form,  willing to join.\r\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ INIT, FINA, 1 ],  [ INIT, FINA, 3 ],  [ INIT, FINA, 4 ],  [ INIT, FINA, 6 ] ],\r\n\r\n  // State 3: prev was D in FINA form,  willing to join.\r\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ MEDI, FINA, 1 ],  [ MEDI, FINA, 3 ],  [ MEDI, FINA, 4 ],  [ MEDI, FINA, 6 ] ],\r\n\r\n  // State 4: prev was FINA ALAPH,  not willing to join.\r\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ MED2, ISOL, 1 ],  [ MED2, ISOL, 2 ],  [ MED2, FIN2, 5 ],  [ MED2, ISOL, 6 ] ],\r\n\r\n  // State 5: prev was FIN2/FIN3 ALAPH,  not willing to join.\r\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ ISOL, ISOL, 1 ],  [ ISOL, ISOL, 2 ],  [ ISOL, FIN2, 5 ],  [ ISOL, ISOL, 6 ] ],\r\n\r\n  // State 6: prev was DALATH/RISH,  not willing to join.\r\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ NONE, ISOL, 1 ],  [ NONE, ISOL, 2 ],  [ NONE, FIN3, 5 ],  [ NONE, ISOL, 6 ] ]\r\n];\r\n\r\n/**\r\n * This is a shaper for Arabic, and other cursive scripts.\r\n * It uses data from ArabicShaping.txt in the Unicode database,\r\n * compiled to a UnicodeTrie by generate-data.coffee.\r\n *\r\n * The shaping state machine was ported from Harfbuzz.\r\n * https://github.com/behdad/harfbuzz/blob/master/src/hb-ot-shape-complex-arabic.cc\r\n */\r\nexport default class ArabicShaper extends DefaultShaper {\r\n  static planFeatures(plan) {\r\n    plan.add(['ccmp', 'locl']);\r\n    for (let i = 0; i < FEATURES.length; i++) {\r\n      let feature = FEATURES[i];\r\n      plan.addStage(feature, false);\r\n    }\r\n\r\n    plan.addStage('mset');\r\n  }\r\n\r\n  static assignFeatures(plan, glyphs) {\r\n    super.assignFeatures(plan, glyphs);\r\n\r\n    let prev = -1;\r\n    let state = 0;\r\n    let actions = [];\r\n\r\n    // Apply the state machine to map glyphs to features\r\n    for (let i = 0; i < glyphs.length; i++) {\r\n      let curAction, prevAction;\r\n      var glyph = glyphs[i];\r\n      let type = getShapingClass(glyph.codePoints[0]);\r\n      if (type === ShapingClasses.Transparent) {\r\n        actions[i] = NONE;\r\n        continue;\r\n      }\r\n\r\n      [prevAction, curAction, state] = STATE_TABLE[state][type];\r\n\r\n      if (prevAction !== NONE && prev !== -1) {\r\n        actions[prev] = prevAction;\r\n      }\r\n\r\n      actions[i] = curAction;\r\n      prev = i;\r\n    }\r\n\r\n    // Apply the chosen features to their respective glyphs\r\n    for (let index = 0; index < glyphs.length; index++) {\r\n      let feature;\r\n      var glyph = glyphs[index];\r\n      if (feature = actions[index]) {\r\n        glyph.features[feature] = true;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction getShapingClass(codePoint) {\r\n  let res = trie.get(codePoint);\r\n  if (res) {\r\n    return res - 1;\r\n  }\r\n\r\n  let category = unicode.getCategory(codePoint);\r\n  if (category === 'Mn' || category === 'Me' || category === 'Cf') {\r\n    return ShapingClasses.Transparent;\r\n  }\r\n\r\n  return ShapingClasses.Non_Joining;\r\n}\r\n","export default class GlyphIterator {\r\n  constructor(glyphs, options) {\r\n    this.glyphs = glyphs;\r\n    this.reset(options);\r\n  }\r\n\r\n  reset(options = {}, index = 0) {\r\n    this.options = options;\r\n    this.flags = options.flags || {};\r\n    this.markAttachmentType = options.markAttachmentType || 0;\r\n    this.index = index;\r\n  }\r\n\r\n  get cur() {\r\n    return this.glyphs[this.index] || null;\r\n  }\r\n\r\n  shouldIgnore(glyph) {\r\n    return (this.flags.ignoreMarks && glyph.isMark) ||\r\n           (this.flags.ignoreBaseGlyphs && glyph.isBase) ||\r\n           (this.flags.ignoreLigatures && glyph.isLigature) ||\r\n           (this.markAttachmentType && glyph.isMark && glyph.markAttachmentType !== this.markAttachmentType);\r\n  }\r\n\r\n  move(dir) {\r\n    this.index += dir;\r\n    while (0 <= this.index && this.index < this.glyphs.length && this.shouldIgnore(this.glyphs[this.index])) {\r\n      this.index += dir;\r\n    }\r\n\r\n    if (0 > this.index || this.index >= this.glyphs.length) {\r\n      return null;\r\n    }\r\n\r\n    return this.glyphs[this.index];\r\n  }\r\n\r\n  next() {\r\n    return this.move(+1);\r\n  }\r\n\r\n  prev() {\r\n    return this.move(-1);\r\n  }\r\n\r\n  peek(count = 1) {\r\n    let idx = this.index;\r\n    let res = this.increment(count);\r\n    this.index = idx;\r\n    return res;\r\n  }\r\n\r\n  peekIndex(count = 1) {\r\n    let idx = this.index;\r\n    this.increment(count);\r\n    let res = this.index;\r\n    this.index = idx;\r\n    return res;\r\n  }\r\n\r\n  increment(count = 1) {\r\n    let dir = count < 0 ? -1 : 1;\r\n    count = Math.abs(count);\r\n    while (count--) {\r\n      this.move(dir);\r\n    }\r\n\r\n    return this.glyphs[this.index];\r\n  }\r\n}\r\n","import GlyphIterator from './GlyphIterator';\r\nimport * as Script from '../layout/Script';\r\n\r\nconst DEFAULT_SCRIPTS = ['DFLT', 'dflt', 'latn'];\r\n\r\nexport default class OTProcessor {\r\n  constructor(font, table) {\r\n    this.font = font;\r\n    this.table = table;\r\n\r\n    this.script = null;\r\n    this.scriptTag = null;\r\n\r\n    this.language = null;\r\n    this.languageTag = null;\r\n\r\n    this.features = {};\r\n    this.lookups = {};\r\n\r\n    // Setup variation substitutions\r\n    this.variationsIndex = font._variationProcessor\r\n      ? this.findVariationsIndex(font._variationProcessor.normalizedCoords)\r\n      : -1;\r\n\r\n    // initialize to default script + language\r\n    this.selectScript();\r\n\r\n    // current context (set by applyFeatures)\r\n    this.glyphs = [];\r\n    this.positions = []; // only used by GPOS\r\n    this.ligatureID = 1;\r\n    this.currentFeature = null;\r\n  }\r\n\r\n  findScript(script) {\r\n    if (this.table.scriptList == null) {\r\n      return null;\r\n    }\r\n\r\n    if (!Array.isArray(script)) {\r\n      script = [ script ];\r\n    }\r\n\r\n    for (let s of script) {\r\n      for (let entry of this.table.scriptList) {\r\n        if (entry.tag === s) {\r\n          return entry;\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  selectScript(script, language, direction) {\r\n    let changed = false;\r\n    let entry;\r\n    if (!this.script || script !== this.scriptTag) {\r\n      entry = this.findScript(script);\r\n      if (!entry) {\r\n        entry = this.findScript(DEFAULT_SCRIPTS);\r\n      }\r\n\r\n      if (!entry) {\r\n        return this.scriptTag;\r\n      }\r\n\r\n      this.scriptTag = entry.tag;\r\n      this.script = entry.script;\r\n      this.language = null;\r\n      this.languageTag = null;\r\n      changed = true;\r\n    }\r\n\r\n    if (!direction || direction !== this.direction) {\r\n      this.direction = direction || Script.direction(script);\r\n    }\r\n\r\n    if (language && language.length < 4) {\r\n      language += ' '.repeat(4 - language.length);\r\n    }\r\n\r\n    if (!language || language !== this.languageTag) {\r\n      this.language = null;\r\n\r\n      for (let lang of this.script.langSysRecords) {\r\n        if (lang.tag === language) {\r\n          this.language = lang.langSys;\r\n          this.languageTag = lang.tag;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (!this.language) {\r\n        this.language = this.script.defaultLangSys;\r\n        this.languageTag = null;\r\n      }\r\n\r\n      changed = true;\r\n    }\r\n\r\n    // Build a feature lookup table\r\n    if (changed) {\r\n      this.features = {};\r\n      if (this.language) {\r\n        for (let featureIndex of this.language.featureIndexes) {\r\n          let record = this.table.featureList[featureIndex];\r\n          let substituteFeature = this.substituteFeatureForVariations(featureIndex);\r\n          this.features[record.tag] = substituteFeature || record.feature;\r\n        }\r\n      }\r\n    }\r\n\r\n    return this.scriptTag;\r\n  }\r\n\r\n  lookupsForFeatures(userFeatures = [], exclude) {\r\n    let lookups = [];\r\n    for (let tag of userFeatures) {\r\n      let feature = this.features[tag];\r\n      if (!feature) {\r\n        continue;\r\n      }\r\n\r\n      for (let lookupIndex of feature.lookupListIndexes) {\r\n        if (exclude && exclude.indexOf(lookupIndex) !== -1) {\r\n          continue;\r\n        }\r\n\r\n        lookups.push({\r\n          feature: tag,\r\n          index: lookupIndex,\r\n          lookup: this.table.lookupList.get(lookupIndex)\r\n        });\r\n      }\r\n    }\r\n\r\n    lookups.sort((a, b) => a.index - b.index);\r\n    return lookups;\r\n  }\r\n\r\n  substituteFeatureForVariations(featureIndex) {\r\n    if (this.variationsIndex === -1) {\r\n      return null;\r\n    }\r\n\r\n    let record = this.table.featureVariations.featureVariationRecords[this.variationsIndex];\r\n    let substitutions = record.featureTableSubstitution.substitutions;\r\n    for (let substitution of substitutions) {\r\n      if (substitution.featureIndex === featureIndex) {\r\n        return substitution.alternateFeatureTable;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  findVariationsIndex(coords) {\r\n    let variations = this.table.featureVariations;\r\n    if (!variations) {\r\n      return -1;\r\n    }\r\n\r\n    let records = variations.featureVariationRecords;\r\n    for (let i = 0; i < records.length; i++) {\r\n      let conditions = records[i].conditionSet.conditionTable;\r\n      if (this.variationConditionsMatch(conditions, coords)) {\r\n        return i;\r\n      }\r\n    }\r\n\r\n    return -1;\r\n  }\r\n\r\n  variationConditionsMatch(conditions, coords) {\r\n    return conditions.every(condition => {\r\n      let coord = condition.axisIndex < coords.length ? coords[condition.axisIndex] : 0;\r\n      return condition.filterRangeMinValue <= coord && coord <= condition.filterRangeMaxValue;\r\n    });\r\n  }\r\n\r\n  applyFeatures(userFeatures, glyphs, advances) {\r\n    let lookups = this.lookupsForFeatures(userFeatures);\r\n    this.applyLookups(lookups, glyphs, advances);\r\n  }\r\n\r\n  applyLookups(lookups, glyphs, positions) {\r\n    this.glyphs = glyphs;\r\n    this.positions = positions;\r\n    this.glyphIterator = new GlyphIterator(glyphs);\r\n\r\n    for (let {feature, lookup} of lookups) {\r\n      this.currentFeature = feature;\r\n      this.glyphIterator.reset(lookup.flags);\r\n\r\n      while (this.glyphIterator.index < glyphs.length) {\r\n        if (!(feature in this.glyphIterator.cur.features)) {\r\n          this.glyphIterator.next();\r\n          continue;\r\n        }\r\n\r\n        for (let table of lookup.subTables) {\r\n          let res = this.applyLookup(lookup.lookupType, table);\r\n          if (res) {\r\n            break;\r\n          }\r\n        }\r\n\r\n        this.glyphIterator.next();\r\n      }\r\n    }\r\n  }\r\n\r\n  applyLookup(lookup, table) {\r\n    throw new Error(\"applyLookup must be implemented by subclasses\");\r\n  }\r\n\r\n  applyLookupList(lookupRecords) {\r\n    let options = this.glyphIterator.options;\r\n    let glyphIndex = this.glyphIterator.index;\r\n\r\n    for (let lookupRecord of lookupRecords) {\r\n      // Reset flags and find glyph index for this lookup record\r\n      this.glyphIterator.reset(options, glyphIndex);\r\n      this.glyphIterator.increment(lookupRecord.sequenceIndex);\r\n\r\n      // Get the lookup and setup flags for subtables\r\n      let lookup = this.table.lookupList.get(lookupRecord.lookupListIndex);\r\n      this.glyphIterator.reset(lookup.flags, this.glyphIterator.index);\r\n\r\n      // Apply lookup subtables until one matches\r\n      for (let table of lookup.subTables) {\r\n        if (this.applyLookup(lookup.lookupType, table)) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    this.glyphIterator.reset(options, glyphIndex);\r\n    return true;\r\n  }\r\n\r\n  coverageIndex(coverage, glyph) {\r\n    if (glyph == null) {\r\n      glyph = this.glyphIterator.cur.id;\r\n    }\r\n\r\n    switch (coverage.version) {\r\n      case 1:\r\n        return coverage.glyphs.indexOf(glyph);\r\n\r\n      case 2:\r\n        for (let range of coverage.rangeRecords) {\r\n          if (range.start <= glyph && glyph <= range.end) {\r\n            return range.startCoverageIndex + glyph - range.start;\r\n          }\r\n        }\r\n\r\n        break;\r\n    }\r\n\r\n    return -1;\r\n  }\r\n\r\n  match(sequenceIndex, sequence, fn, matched) {\r\n    let pos = this.glyphIterator.index;\r\n    let glyph = this.glyphIterator.increment(sequenceIndex);\r\n    let idx = 0;\r\n\r\n    while (idx < sequence.length && glyph && fn(sequence[idx], glyph)) {\r\n      if (matched) {\r\n        matched.push(this.glyphIterator.index);\r\n      }\r\n\r\n      idx++;\r\n      glyph = this.glyphIterator.next();\r\n    }\r\n\r\n    this.glyphIterator.index = pos;\r\n    if (idx < sequence.length) {\r\n      return false;\r\n    }\r\n\r\n    return matched || true;\r\n  }\r\n\r\n  sequenceMatches(sequenceIndex, sequence) {\r\n    return this.match(sequenceIndex, sequence, (component, glyph) => component === glyph.id);\r\n  }\r\n\r\n  sequenceMatchIndices(sequenceIndex, sequence) {\r\n    return this.match(sequenceIndex, sequence, (component, glyph) => {\r\n      // If the current feature doesn't apply to this glyph,\r\n      if (!(this.currentFeature in glyph.features)) {\r\n        return false;\r\n      }\r\n\r\n      return component === glyph.id;\r\n    }, []);\r\n  }\r\n\r\n  coverageSequenceMatches(sequenceIndex, sequence) {\r\n    return this.match(sequenceIndex, sequence, (coverage, glyph) =>\r\n      this.coverageIndex(coverage, glyph.id) >= 0\r\n    );\r\n  }\r\n\r\n  getClassID(glyph, classDef) {\r\n    switch (classDef.version) {\r\n      case 1: // Class array\r\n        let i = glyph - classDef.startGlyph;\r\n        if (i >= 0 && i < classDef.classValueArray.length) {\r\n          return classDef.classValueArray[i];\r\n        }\r\n\r\n        break;\r\n\r\n      case 2:\r\n        for (let range of classDef.classRangeRecord) {\r\n          if (range.start <= glyph && glyph <= range.end) {\r\n            return range.class;\r\n          }\r\n        }\r\n\r\n        break;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  classSequenceMatches(sequenceIndex, sequence, classDef) {\r\n    return this.match(sequenceIndex, sequence, (classID, glyph) =>\r\n      classID === this.getClassID(glyph.id, classDef)\r\n    );\r\n  }\r\n\r\n  applyContext(table) {\r\n    switch (table.version) {\r\n      case 1:\r\n        let index = this.coverageIndex(table.coverage);\r\n        if (index === -1) {\r\n          return false;\r\n        }\r\n\r\n        let set = table.ruleSets[index];\r\n        for (let rule of set) {\r\n          if (this.sequenceMatches(1, rule.input)) {\r\n            return this.applyLookupList(rule.lookupRecords);\r\n          }\r\n        }\r\n\r\n        break;\r\n\r\n      case 2:\r\n        if (this.coverageIndex(table.coverage) === -1) {\r\n          return false;\r\n        }\r\n\r\n        index = this.getClassID(this.glyphIterator.cur.id, table.classDef);\r\n        if (index === -1) {\r\n          return false;\r\n        }\r\n\r\n        set = table.classSet[index];\r\n        for (let rule of set) {\r\n          if (this.classSequenceMatches(1, rule.classes, table.classDef)) {\r\n            return this.applyLookupList(rule.lookupRecords);\r\n          }\r\n        }\r\n\r\n        break;\r\n\r\n      case 3:\r\n        if (this.coverageSequenceMatches(0, table.coverages)) {\r\n          return this.applyLookupList(table.lookupRecords);\r\n        }\r\n\r\n        break;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  applyChainingContext(table) {\r\n    switch (table.version) {\r\n      case 1:\r\n        let index = this.coverageIndex(table.coverage);\r\n        if (index === -1) {\r\n          return false;\r\n        }\r\n\r\n        let set = table.chainRuleSets[index];\r\n        for (let rule of set) {\r\n          if (this.sequenceMatches(-rule.backtrack.length, rule.backtrack)\r\n              && this.sequenceMatches(1, rule.input)\r\n              && this.sequenceMatches(1 + rule.input.length, rule.lookahead)) {\r\n            return this.applyLookupList(rule.lookupRecords);\r\n          }\r\n        }\r\n\r\n        break;\r\n\r\n      case 2:\r\n        if (this.coverageIndex(table.coverage) === -1) {\r\n          return false;\r\n        }\r\n\r\n        index = this.getClassID(this.glyphIterator.cur.id, table.inputClassDef);\r\n        let rules = table.chainClassSet[index];\r\n        if (!rules) {\r\n          return false;\r\n        }\r\n\r\n        for (let rule of rules) {\r\n          if (this.classSequenceMatches(-rule.backtrack.length, rule.backtrack, table.backtrackClassDef) &&\r\n              this.classSequenceMatches(1, rule.input, table.inputClassDef) &&\r\n              this.classSequenceMatches(1 + rule.input.length, rule.lookahead, table.lookaheadClassDef)) {\r\n            return this.applyLookupList(rule.lookupRecords);\r\n          }\r\n        }\r\n\r\n        break;\r\n\r\n      case 3:\r\n        if (this.coverageSequenceMatches(-table.backtrackGlyphCount, table.backtrackCoverage) &&\r\n            this.coverageSequenceMatches(0, table.inputCoverage) &&\r\n            this.coverageSequenceMatches(table.inputGlyphCount, table.lookaheadCoverage)) {\r\n          return this.applyLookupList(table.lookupRecords);\r\n        }\r\n\r\n        break;\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n","import unicode from 'unicode-properties';\r\nimport OTProcessor from './OTProcessor';\r\n\r\nexport default class GlyphInfo {\r\n  constructor(font, id, codePoints = [], features) {\r\n    this._font = font;\r\n    this.codePoints = codePoints;\r\n    this.id = id;\r\n\r\n    this.features = {};\r\n    if (Array.isArray(features)) {\r\n      for (let i = 0; i < features.length; i++) {\r\n        let feature = features[i];\r\n        this.features[feature] = true;\r\n      }\r\n    } else if (typeof features === 'object') {\r\n      Object.assign(this.features, features);\r\n    }\r\n\r\n    this.ligatureID = null;\r\n    this.ligatureComponent = null;\r\n    this.isLigated = false;\r\n    this.cursiveAttachment = null;\r\n    this.markAttachment = null;\r\n    this.shaperInfo = null;\r\n    this.substituted = false;\r\n    this.isMultiplied = false;\r\n  }\r\n\r\n  get id() {\r\n    return this._id;\r\n  }\r\n\r\n  set id(id) {\r\n    this._id = id;\r\n    this.substituted = true;\r\n\r\n    let GDEF = this._font.GDEF;\r\n    if (GDEF && GDEF.glyphClassDef) {\r\n      // TODO: clean this up\r\n      let classID = OTProcessor.prototype.getClassID(id, GDEF.glyphClassDef);\r\n      this.isBase = classID === 1;\r\n      this.isLigature = classID === 2;\r\n      this.isMark = classID === 3;\r\n      this.markAttachmentType = GDEF.markAttachClassDef ? OTProcessor.prototype.getClassID(id, GDEF.markAttachClassDef) : 0;\r\n    } else {\r\n      this.isMark = this.codePoints.length > 0 && this.codePoints.every(unicode.isMark);\r\n      this.isBase = !this.isMark;\r\n      this.isLigature = this.codePoints.length > 1;\r\n      this.markAttachmentType = 0;\r\n    }\r\n  }\r\n\r\n  copy() {\r\n    return new GlyphInfo(this._font, this.id, this.codePoints, this.features);\r\n  }\r\n}\r\n","import DefaultShaper from './DefaultShaper';\r\nimport GlyphInfo from '../GlyphInfo';\r\n\r\n/**\r\n * This is a shaper for the Hangul script, used by the Korean language.\r\n * It does the following:\r\n *   - decompose if unsupported by the font:\r\n *     <LV>   -> <L,V>\r\n *     <LVT>  -> <L,V,T>\r\n *     <LV,T> -> <L,V,T>\r\n *\r\n *   - compose if supported by the font:\r\n *     <L,V>   -> <LV>\r\n *     <L,V,T> -> <LVT>\r\n *     <LV,T>  -> <LVT>\r\n *\r\n *   - reorder tone marks (S is any valid syllable):\r\n *     <S, M> -> <M, S>\r\n *\r\n *   - apply ljmo, vjmo, and tjmo OpenType features to decomposed Jamo sequences.\r\n *\r\n * This logic is based on the following documents:\r\n *   - http://www.microsoft.com/typography/OpenTypeDev/hangul/intro.htm\r\n *   - http://ktug.org/~nomos/harfbuzz-hangul/hangulshaper.pdf\r\n */\r\nexport default class HangulShaper extends DefaultShaper {\r\n  static zeroMarkWidths = 'NONE';\r\n  static planFeatures(plan) {\r\n    plan.add(['ljmo', 'vjmo', 'tjmo'], false);\r\n  }\r\n\r\n  static assignFeatures(plan, glyphs) {\r\n    let state = 0;\r\n    let i = 0;\r\n    while (i < glyphs.length) {\r\n      let action;\r\n      let glyph = glyphs[i];\r\n      let code = glyph.codePoints[0];\r\n      let type = getType(code);\r\n\r\n      [ action, state ] = STATE_TABLE[state][type];\r\n\r\n      switch (action) {\r\n        case DECOMPOSE:\r\n          // Decompose the composed syllable if it is not supported by the font.\r\n          if (!plan.font.hasGlyphForCodePoint(code)) {\r\n            i = decompose(glyphs, i, plan.font);\r\n          }\r\n          break;\r\n\r\n        case COMPOSE:\r\n          // Found a decomposed syllable. Try to compose if supported by the font.\r\n          i = compose(glyphs, i, plan.font);\r\n          break;\r\n\r\n        case TONE_MARK:\r\n          // Got a valid syllable, followed by a tone mark. Move the tone mark to the beginning of the syllable.\r\n          reorderToneMark(glyphs, i, plan.font);\r\n          break;\r\n\r\n        case INVALID:\r\n          // Tone mark has no valid syllable to attach to, so insert a dotted circle\r\n          i = insertDottedCircle(glyphs, i, plan.font);\r\n          break;\r\n      }\r\n\r\n      i++;\r\n    }\r\n  }\r\n}\r\n\r\nconst HANGUL_BASE  = 0xac00;\r\nconst HANGUL_END   = 0xd7a4;\r\nconst HANGUL_COUNT = HANGUL_END - HANGUL_BASE + 1;\r\nconst L_BASE  = 0x1100; // lead\r\nconst V_BASE  = 0x1161; // vowel\r\nconst T_BASE  = 0x11a7; // trail\r\nconst L_COUNT = 19;\r\nconst V_COUNT = 21;\r\nconst T_COUNT = 28;\r\nconst L_END   = L_BASE + L_COUNT - 1;\r\nconst V_END   = V_BASE + V_COUNT - 1;\r\nconst T_END   = T_BASE + T_COUNT - 1;\r\nconst DOTTED_CIRCLE = 0x25cc;\r\n\r\nconst isL    = code => 0x1100 <= code && code <= 0x115f || 0xa960 <= code && code <= 0xa97c;\r\nconst isV    = code => 0x1160 <= code && code <= 0x11a7 || 0xd7b0 <= code && code <= 0xd7c6;\r\nconst isT    = code => 0x11a8 <= code && code <= 0x11ff || 0xd7cb <= code && code <= 0xd7fb;\r\nconst isTone = code => 0x302e <= code && code <= 0x302f;\r\nconst isLVT  = code => HANGUL_BASE <= code && code <= HANGUL_END;\r\nconst isLV   = code => (code - HANGUL_BASE) < HANGUL_COUNT && (code - HANGUL_BASE) % T_COUNT === 0;\r\nconst isCombiningL = code => L_BASE <= code && code <= L_END;\r\nconst isCombiningV = code => V_BASE <= code && code <= V_END;\r\nconst isCombiningT = code => T_BASE + 1 && 1 <= code && code <= T_END;\r\n\r\n// Character categories\r\nconst X   = 0; // Other character\r\nconst L   = 1; // Leading consonant\r\nconst V   = 2; // Medial vowel\r\nconst T   = 3; // Trailing consonant\r\nconst LV  = 4; // Composed <LV> syllable\r\nconst LVT = 5; // Composed <LVT> syllable\r\nconst M   = 6; // Tone mark\r\n\r\n// This function classifies a character using the above categories.\r\nfunction getType(code) {\r\n  if (isL(code))    { return L; }\r\n  if (isV(code))    { return V; }\r\n  if (isT(code))    { return T; }\r\n  if (isLV(code))   { return LV; }\r\n  if (isLVT(code))  { return LVT; }\r\n  if (isTone(code)) { return M; }\r\n  return X;\r\n}\r\n\r\n// State machine actions\r\nconst NO_ACTION = 0;\r\nconst DECOMPOSE = 1;\r\nconst COMPOSE   = 2;\r\nconst TONE_MARK = 4;\r\nconst INVALID   = 5;\r\n\r\n// Build a state machine that accepts valid syllables, and applies actions along the way.\r\n// The logic this is implementing is documented at the top of the file.\r\nconst STATE_TABLE = [\r\n  //       X                 L                 V                T                  LV                LVT               M\r\n  // State 0: start state\r\n  [ [ NO_ACTION, 0 ], [ NO_ACTION, 1 ], [ NO_ACTION, 0 ], [ NO_ACTION, 0 ], [ DECOMPOSE, 2 ], [ DECOMPOSE, 3 ], [  INVALID, 0  ] ],\r\n\r\n  // State 1: <L>\r\n  [ [ NO_ACTION, 0 ], [ NO_ACTION, 1 ], [  COMPOSE, 2  ], [ NO_ACTION, 0 ], [ DECOMPOSE, 2 ], [ DECOMPOSE, 3 ], [  INVALID, 0  ] ],\r\n\r\n  // State 2: <L,V> or <LV>\r\n  [ [ NO_ACTION, 0 ], [ NO_ACTION, 1 ], [ NO_ACTION, 0 ], [  COMPOSE, 3  ], [ DECOMPOSE, 2 ], [ DECOMPOSE, 3 ], [ TONE_MARK, 0 ] ],\r\n\r\n  // State 3: <L,V,T> or <LVT>\r\n  [ [ NO_ACTION, 0 ], [ NO_ACTION, 1 ], [ NO_ACTION, 0 ], [ NO_ACTION, 0 ], [ DECOMPOSE, 2 ], [ DECOMPOSE, 3 ], [ TONE_MARK, 0 ] ]\r\n];\r\n\r\nfunction getGlyph(font, code, features) {\r\n  return new GlyphInfo(font, font.glyphForCodePoint(code).id, [code], features);\r\n}\r\n\r\nfunction decompose(glyphs, i, font) {\r\n  let glyph = glyphs[i];\r\n  let code = glyph.codePoints[0];\r\n\r\n  let s = code - HANGUL_BASE;\r\n  let t = T_BASE + s % T_COUNT;\r\n  s = s / T_COUNT | 0;\r\n  let l = L_BASE + s / V_COUNT | 0;\r\n  let v = V_BASE + s % V_COUNT;\r\n\r\n  // Don't decompose if all of the components are not available\r\n  if (!font.hasGlyphForCodePoint(l) ||\r\n      !font.hasGlyphForCodePoint(v) ||\r\n      (t !== T_BASE && !font.hasGlyphForCodePoint(t))) {\r\n    return i;\r\n  }\r\n\r\n  // Replace the current glyph with decomposed L, V, and T glyphs,\r\n  // and apply the proper OpenType features to each component.\r\n  let ljmo = getGlyph(font, l, glyph.features);\r\n  ljmo.features.ljmo = true;\r\n\r\n  let vjmo = getGlyph(font, v, glyph.features);\r\n  vjmo.features.vjmo = true;\r\n\r\n  let insert = [ ljmo, vjmo ];\r\n\r\n  if (t > T_BASE) {\r\n    let tjmo = getGlyph(font, t, glyph.features);\r\n    tjmo.features.tjmo = true;\r\n    insert.push(tjmo);\r\n  }\r\n\r\n  glyphs.splice(i, 1, ...insert);\r\n  return i + insert.length - 1;\r\n}\r\n\r\nfunction compose(glyphs, i, font) {\r\n  let glyph = glyphs[i];\r\n  let code = glyphs[i].codePoints[0];\r\n  let type = getType(code);\r\n\r\n  let prev = glyphs[i - 1].codePoints[0];\r\n  let prevType = getType(prev);\r\n\r\n  // Figure out what type of syllable we're dealing with\r\n  let lv, ljmo, vjmo, tjmo;\r\n  if (prevType === LV && type === T) {\r\n    // <LV,T>\r\n    lv = prev;\r\n    tjmo = glyph;\r\n  } else {\r\n    if (type === V) {\r\n      // <L,V>\r\n      ljmo = glyphs[i - 1];\r\n      vjmo = glyph;\r\n    } else {\r\n      // <L,V,T>\r\n      ljmo = glyphs[i - 2];\r\n      vjmo = glyphs[i - 1];\r\n      tjmo = glyph;\r\n    }\r\n\r\n    let l = ljmo.codePoints[0];\r\n    let v = vjmo.codePoints[0];\r\n\r\n    // Make sure L and V are combining characters\r\n    if (isCombiningL(l) && isCombiningV(v)) {\r\n      lv = HANGUL_BASE + ((l - L_BASE) * V_COUNT + (v - V_BASE)) * T_COUNT;\r\n    }\r\n  }\r\n\r\n  let t = (tjmo && tjmo.codePoints[0]) || T_BASE;\r\n  if ((lv != null) && (t === T_BASE || isCombiningT(t))) {\r\n    let s = lv + (t - T_BASE);\r\n\r\n    // Replace with a composed glyph if supported by the font,\r\n    // otherwise apply the proper OpenType features to each component.\r\n    if (font.hasGlyphForCodePoint(s)) {\r\n      let del = prevType === V ? 3 : 2;\r\n      glyphs.splice(i - del + 1, del, getGlyph(font, s, glyph.features));\r\n      return i - del + 1;\r\n    }\r\n  }\r\n\r\n  // Didn't compose (either a non-combining component or unsupported by font).\r\n  if (ljmo) { ljmo.features.ljmo = true; }\r\n  if (vjmo) { vjmo.features.vjmo = true; }\r\n  if (tjmo) { tjmo.features.tjmo = true; }\r\n\r\n  if (prevType === LV) {\r\n    // Sequence was originally <L,V>, which got combined earlier.\r\n    // Either the T was non-combining, or the LVT glyph wasn't supported.\r\n    // Decompose the glyph again and apply OT features.\r\n    decompose(glyphs, i - 1, font);\r\n    return i + 1;\r\n  }\r\n\r\n  return i;\r\n}\r\n\r\nfunction getLength(code) {\r\n  switch (getType(code)) {\r\n    case LV:\r\n    case LVT:\r\n      return 1;\r\n    case V:\r\n      return 2;\r\n    case T:\r\n      return 3;\r\n  }\r\n}\r\n\r\nfunction reorderToneMark(glyphs, i, font) {\r\n  let glyph = glyphs[i];\r\n  let code = glyphs[i].codePoints[0];\r\n\r\n  // Move tone mark to the beginning of the previous syllable, unless it is zero width\r\n  if (font.glyphForCodePoint(code).advanceWidth === 0) { return; }\r\n\r\n  let prev = glyphs[i - 1].codePoints[0];\r\n  let len = getLength(prev);\r\n\r\n  glyphs.splice(i, 1);\r\n  return glyphs.splice(i - len, 0, glyph);\r\n}\r\n\r\nfunction insertDottedCircle(glyphs, i, font) {\r\n  let glyph = glyphs[i];\r\n  let code = glyphs[i].codePoints[0];\r\n\r\n  if (font.hasGlyphForCodePoint(DOTTED_CIRCLE)) {\r\n    let dottedCircle = getGlyph(font, DOTTED_CIRCLE, glyph.features);\r\n\r\n    // If the tone mark is zero width, insert the dotted circle before, otherwise after\r\n    let idx = font.glyphForCodePoint(code).advanceWidth === 0 ? i : i + 1;\r\n    glyphs.splice(idx, 0, dottedCircle);\r\n    i++;\r\n  }\r\n\r\n  return i;\r\n}\r\n","// Cateories used in the OpenType spec:\r\n// https://www.microsoft.com/typography/otfntdev/devanot/shaping.aspx\r\nexport const CATEGORIES = {\r\n  X: 1 << 0,\r\n  C: 1 << 1,\r\n  V: 1 << 2,\r\n  N: 1 << 3,\r\n  H: 1 << 4,\r\n  ZWNJ: 1 << 5,\r\n  ZWJ: 1 << 6,\r\n  M: 1 << 7,\r\n  SM: 1 << 8,\r\n  VD: 1 << 9,\r\n  A: 1 << 10,\r\n  Placeholder: 1 << 11,\r\n  Dotted_Circle: 1 << 12,\r\n  RS: 1 << 13,    // Register Shifter, used in Khmer OT spec.\r\n  Coeng: 1 << 14, // Khmer-style Virama.\r\n  Repha: 1 << 15, // Atomically-encoded logical or visual repha.\r\n  Ra: 1 << 16,\r\n  CM: 1 << 17,    // Consonant-Medial.\r\n  Symbol: 1 << 18 // Avagraha, etc that take marks (SM,A,VD).\r\n};\r\n\r\n// Visual positions in a syllable from left to right.\r\nexport const POSITIONS = {\r\n  Start: 1 << 0,\r\n\r\n  Ra_To_Become_Reph: 1 << 1,\r\n  Pre_M: 1 << 2,\r\n  Pre_C: 1 << 3,\r\n\r\n  Base_C: 1 << 4,\r\n  After_Main: 1 << 5,\r\n\r\n  Above_C: 1 << 6,\r\n\r\n  Before_Sub: 1 << 7,\r\n  Below_C: 1 << 8,\r\n  After_Sub: 1 << 9,\r\n\r\n  Before_Post: 1 << 10,\r\n  Post_C: 1 << 11,\r\n  After_Post: 1 << 12,\r\n\r\n  Final_C: 1 << 13,\r\n  SMVD: 1 << 14,\r\n\r\n  End: 1 << 15\r\n};\r\n\r\nexport const CONSONANT_FLAGS = CATEGORIES.C | CATEGORIES.Ra | CATEGORIES.CM | CATEGORIES.V | CATEGORIES.Placeholder | CATEGORIES.Dotted_Circle;\r\nexport const JOINER_FLAGS = CATEGORIES.ZWJ | CATEGORIES.ZWNJ;\r\nexport const HALANT_OR_COENG_FLAGS = CATEGORIES.H | CATEGORIES.Coeng;\r\n\r\nexport const INDIC_CONFIGS = {\r\n  Default: {\r\n    hasOldSpec: false,\r\n    virama: 0,\r\n    basePos: 'Last',\r\n    rephPos: POSITIONS.Before_Post,\r\n    rephMode: 'Implicit',\r\n    blwfMode: 'Pre_And_Post'\r\n  },\r\n\r\n  Devanagari: {\r\n    hasOldSpec: true,\r\n    virama: 0x094D,\r\n    basePos: 'Last',\r\n    rephPos: POSITIONS.Before_Post,\r\n    rephMode: 'Implicit',\r\n    blwfMode: 'Pre_And_Post'\r\n  },\r\n\r\n  Bengali: {\r\n    hasOldSpec: true,\r\n    virama: 0x09CD,\r\n    basePos: 'Last',\r\n    rephPos: POSITIONS.After_Sub,\r\n    rephMode: 'Implicit',\r\n    blwfMode: 'Pre_And_Post'\r\n  },\r\n\r\n  Gurmukhi: {\r\n    hasOldSpec: true,\r\n    virama: 0x0A4D,\r\n    basePos: 'Last',\r\n    rephPos: POSITIONS.Before_Sub,\r\n    rephMode: 'Implicit',\r\n    blwfMode: 'Pre_And_Post'\r\n  },\r\n\r\n  Gujarati: {\r\n    hasOldSpec: true,\r\n    virama: 0x0ACD,\r\n    basePos: 'Last',\r\n    rephPos: POSITIONS.Before_Post,\r\n    rephMode: 'Implicit',\r\n    blwfMode: 'Pre_And_Post'\r\n  },\r\n\r\n  Oriya: {\r\n    hasOldSpec: true,\r\n    virama: 0x0B4D,\r\n    basePos: 'Last',\r\n    rephPos: POSITIONS.After_Main,\r\n    rephMode: 'Implicit',\r\n    blwfMode: 'Pre_And_Post'\r\n  },\r\n\r\n  Tamil: {\r\n    hasOldSpec: true,\r\n    virama: 0x0BCD,\r\n    basePos: 'Last',\r\n    rephPos: POSITIONS.After_Post,\r\n    rephMode: 'Implicit',\r\n    blwfMode: 'Pre_And_Post'\r\n  },\r\n\r\n  Telugu: {\r\n    hasOldSpec: true,\r\n    virama: 0x0C4D,\r\n    basePos: 'Last',\r\n    rephPos: POSITIONS.After_Post,\r\n    rephMode: 'Explicit',\r\n    blwfMode: 'Post_Only'\r\n  },\r\n\r\n  Kannada: {\r\n    hasOldSpec: true,\r\n    virama: 0x0CCD,\r\n    basePos: 'Last',\r\n    rephPos: POSITIONS.After_Post,\r\n    rephMode: 'Implicit',\r\n    blwfMode: 'Post_Only'\r\n  },\r\n\r\n  Malayalam: {\r\n    hasOldSpec: true,\r\n    virama: 0x0D4D,\r\n    basePos: 'Last',\r\n    rephPos: POSITIONS.After_Main,\r\n    rephMode: 'Log_Repha',\r\n    blwfMode: 'Pre_And_Post'\r\n  },\r\n\r\n  // Handled by UniversalShaper\r\n  // Sinhala: {\r\n  //   hasOldSpec: false,\r\n  //   virama: 0x0DCA,\r\n  //   basePos: 'Last_Sinhala',\r\n  //   rephPos: POSITIONS.After_Main,\r\n  //   rephMode: 'Explicit',\r\n  //   blwfMode: 'Pre_And_Post'\r\n  // },\r\n\r\n  Khmer: {\r\n    hasOldSpec: false,\r\n    virama: 0x17D2,\r\n    basePos: 'First',\r\n    rephPos: POSITIONS.Ra_To_Become_Reph,\r\n    rephMode: 'Vis_Repha',\r\n    blwfMode: 'Pre_And_Post'\r\n  }\r\n};\r\n\r\n// Additional decompositions that aren't in Unicode\r\nexport const INDIC_DECOMPOSITIONS = {\r\n  // Khmer\r\n  0x17BE: [0x17C1, 0x17BE],\r\n  0x17BF: [0x17C1, 0x17BF],\r\n  0x17C0: [0x17C1, 0x17C0],\r\n  0x17C4: [0x17C1, 0x17C4],\r\n  0x17C5: [0x17C1, 0x17C5]\r\n};\r\n","import DefaultShaper from './DefaultShaper';\r\nimport StateMachine from 'dfa';\r\nimport UnicodeTrie from 'unicode-trie';\r\nimport unicode from 'unicode-properties';\r\nimport * as Script from '../../layout/Script';\r\nimport GlyphInfo from '../GlyphInfo';\r\nimport indicMachine from './indic.json';\r\nimport useData from './use.json';\r\nimport {\r\n  CATEGORIES,\r\n  POSITIONS,\r\n  CONSONANT_FLAGS,\r\n  JOINER_FLAGS,\r\n  HALANT_OR_COENG_FLAGS, INDIC_CONFIGS,\r\n  INDIC_DECOMPOSITIONS\r\n} from './indic-data';\r\n\r\nconst {decompositions} = useData;\r\nconst trie = new UnicodeTrie(require('fs').readFileSync(__dirname + '/indic.trie'));\r\nconst stateMachine = new StateMachine(indicMachine);\r\n\r\n/**\r\n * The IndicShaper supports indic scripts e.g. Devanagari, Kannada, etc.\r\n * Based on code from Harfbuzz: https://github.com/behdad/harfbuzz/blob/master/src/hb-ot-shape-complex-indic.cc\r\n */\r\nexport default class IndicShaper extends DefaultShaper {\r\n  static zeroMarkWidths = 'NONE';\r\n  static planFeatures(plan) {\r\n    plan.addStage(setupSyllables);\r\n\r\n    plan.addStage(['locl', 'ccmp']);\r\n\r\n    plan.addStage(initialReordering);\r\n\r\n    plan.addStage('nukt');\r\n    plan.addStage('akhn');\r\n    plan.addStage('rphf', false);\r\n    plan.addStage('rkrf');\r\n    plan.addStage('pref', false);\r\n    plan.addStage('blwf', false);\r\n    plan.addStage('abvf', false);\r\n    plan.addStage('half', false);\r\n    plan.addStage('pstf', false);\r\n    plan.addStage('vatu');\r\n    plan.addStage('cjct');\r\n    plan.addStage('cfar', false);\r\n\r\n    plan.addStage(finalReordering);\r\n\r\n    plan.addStage({\r\n      local: ['init'],\r\n      global: ['pres', 'abvs', 'blws', 'psts', 'haln', 'dist', 'abvm', 'blwm', 'calt', 'clig']\r\n    });\r\n\r\n    // Setup the indic config for the selected script\r\n    plan.unicodeScript = Script.fromOpenType(plan.script);\r\n    plan.indicConfig = INDIC_CONFIGS[plan.unicodeScript] || INDIC_CONFIGS.Default;\r\n    plan.isOldSpec = plan.indicConfig.hasOldSpec && plan.script[plan.script.length - 1] !== '2';\r\n\r\n    // TODO: turn off kern (Khmer) and liga features.\r\n  }\r\n\r\n  static assignFeatures(plan, glyphs) {\r\n    // Decompose split matras\r\n    // TODO: do this in a more general unicode normalizer\r\n    for (let i = glyphs.length - 1; i >= 0; i--) {\r\n      let codepoint = glyphs[i].codePoints[0];\r\n      let d = INDIC_DECOMPOSITIONS[codepoint] || decompositions[codepoint];\r\n      if (d) {\r\n        let decomposed = d.map(c => {\r\n          let g = plan.font.glyphForCodePoint(c);\r\n          return new GlyphInfo(plan.font, g.id, [c], glyphs[i].features);\r\n        });\r\n\r\n        glyphs.splice(i, 1, ...decomposed);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction indicCategory(glyph) {\r\n  return trie.get(glyph.codePoints[0]) >> 8;\r\n}\r\n\r\nfunction indicPosition(glyph) {\r\n  return 1 << (trie.get(glyph.codePoints[0]) & 0xff);\r\n}\r\n\r\nclass IndicInfo {\r\n  constructor(category, position, syllableType, syllable) {\r\n    this.category = category;\r\n    this.position = position;\r\n    this.syllableType = syllableType;\r\n    this.syllable = syllable;\r\n  }\r\n}\r\n\r\nfunction setupSyllables(font, glyphs) {\r\n  let syllable = 0;\r\n  let last = 0;\r\n  for (let [start, end, tags] of stateMachine.match(glyphs.map(indicCategory))) {\r\n    if (start > last) {\r\n      ++syllable;\r\n      for (let i = last; i < start; i++) {\r\n        glyphs[i].shaperInfo = new IndicInfo(CATEGORIES.X, POSITIONS.End, 'non_indic_cluster', syllable);\r\n      }\r\n    }\r\n\r\n    ++syllable;\r\n\r\n    // Create shaper info\r\n    for (let i = start; i <= end; i++) {\r\n      glyphs[i].shaperInfo = new IndicInfo(\r\n        1 << indicCategory(glyphs[i]),\r\n        indicPosition(glyphs[i]),\r\n        tags[0],\r\n        syllable\r\n      );\r\n    }\r\n\r\n    last = end + 1;\r\n  }\r\n\r\n  if (last < glyphs.length) {\r\n    ++syllable;\r\n    for (let i = last; i < glyphs.length; i++) {\r\n      glyphs[i].shaperInfo = new IndicInfo(CATEGORIES.X, POSITIONS.End, 'non_indic_cluster', syllable);\r\n    }\r\n  }\r\n}\r\n\r\nfunction isConsonant(glyph) {\r\n  return glyph.shaperInfo.category & CONSONANT_FLAGS;\r\n}\r\n\r\nfunction isJoiner(glyph) {\r\n  return glyph.shaperInfo.category & JOINER_FLAGS;\r\n}\r\n\r\nfunction isHalantOrCoeng(glyph) {\r\n  return glyph.shaperInfo.category & HALANT_OR_COENG_FLAGS;\r\n}\r\n\r\nfunction wouldSubstitute(glyphs, feature) {\r\n  for (let glyph of glyphs) {\r\n    glyph.features = {[feature]: true};\r\n  }\r\n\r\n  let GSUB = glyphs[0]._font._layoutEngine.engine.GSUBProcessor;\r\n  GSUB.applyFeatures([feature], glyphs);\r\n\r\n  return glyphs.length === 1;\r\n}\r\n\r\nfunction consonantPosition(font, consonant, virama) {\r\n  let glyphs = [virama, consonant, virama];\r\n  if (wouldSubstitute(glyphs.slice(0, 2), 'blwf') || wouldSubstitute(glyphs.slice(1, 3), 'blwf')) {\r\n    return POSITIONS.Below_C;\r\n  } else if (wouldSubstitute(glyphs.slice(0, 2), 'pstf') || wouldSubstitute(glyphs.slice(1, 3), 'pstf')) {\r\n    return POSITIONS.Post_C;\r\n  } else if (wouldSubstitute(glyphs.slice(0, 2), 'pref') || wouldSubstitute(glyphs.slice(1, 3), 'pref')) {\r\n    return POSITIONS.Post_C;\r\n  }\r\n\r\n  return POSITIONS.Base_C;\r\n}\r\n\r\nfunction initialReordering(font, glyphs, plan) {\r\n  let indicConfig = plan.indicConfig;\r\n  let features = font._layoutEngine.engine.GSUBProcessor.features;\r\n\r\n  let dottedCircle = font.glyphForCodePoint(0x25cc).id;\r\n  let virama = font.glyphForCodePoint(indicConfig.virama).id;\r\n  if (virama) {\r\n    let info = new GlyphInfo(font, virama, [indicConfig.virama]);\r\n    for (let i = 0; i < glyphs.length; i++) {\r\n      if (glyphs[i].shaperInfo.position === POSITIONS.Base_C) {\r\n        glyphs[i].shaperInfo.position = consonantPosition(font, glyphs[i].copy(), info);\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let start = 0, end = nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable(glyphs, start)) {\r\n    let {category, syllableType} = glyphs[start].shaperInfo;\r\n\r\n    if (syllableType === 'symbol_cluster' || syllableType === 'non_indic_cluster') {\r\n      continue;\r\n    }\r\n\r\n    if (syllableType === 'broken_cluster' && dottedCircle) {\r\n      let g = new GlyphInfo(font, dottedCircle, [0x25cc]);\r\n      g.shaperInfo = new IndicInfo(\r\n        1 << indicCategory(g),\r\n        indicPosition(g),\r\n        glyphs[start].shaperInfo.syllableType,\r\n        glyphs[start].shaperInfo.syllable\r\n      );\r\n\r\n      // Insert after possible Repha.\r\n      let i = start;\r\n      while (i < end && glyphs[i].shaperInfo.category === CATEGORIES.Repha) {\r\n        i++;\r\n      }\r\n\r\n      glyphs.splice(i++, 0, g);\r\n      end++;\r\n    }\r\n\r\n    // 1. Find base consonant:\r\n    //\r\n    // The shaping engine finds the base consonant of the syllable, using the\r\n    // following algorithm: starting from the end of the syllable, move backwards\r\n    // until a consonant is found that does not have a below-base or post-base\r\n    // form (post-base forms have to follow below-base forms), or that is not a\r\n    // pre-base reordering Ra, or arrive at the first consonant. The consonant\r\n    // stopped at will be the base.\r\n\r\n    let base = end;\r\n    let limit = start;\r\n    let hasReph = false;\r\n\r\n    // If the syllable starts with Ra + Halant (in a script that has Reph)\r\n    // and has more than one consonant, Ra is excluded from candidates for\r\n    // base consonants.\r\n    if (indicConfig.rephPos !== POSITIONS.Ra_To_Become_Reph &&\r\n      features.rphf &&\r\n      start + 3 <= end && (\r\n        (indicConfig.rephMode === 'Implicit' && !isJoiner(glyphs[start + 2])) ||\r\n        (indicConfig.rephMode === 'Explicit' && glyphs[start + 2].shaperInfo.category === CATEGORIES.ZWJ)\r\n      )\r\n    ) {\r\n      // See if it matches the 'rphf' feature.\r\n      let g = [glyphs[start].copy(), glyphs[start + 1].copy(), glyphs[start + 2].copy()];\r\n      if (wouldSubstitute(g.slice(0, 2), 'rphf') || (indicConfig.rephMode === 'Explicit' && wouldSubstitute(g, 'rphf'))) {\r\n        limit += 2;\r\n        while (limit < end && isJoiner(glyphs[limit])) {\r\n          limit++;\r\n        }\r\n        base = start;\r\n        hasReph = true;\r\n      }\r\n    } else if (indicConfig.rephMode === 'Log_Repha' && glyphs[start].shaperInfo.category === CATEGORIES.Repha) {\r\n      limit++;\r\n      while (limit < end && isJoiner(glyphs[limit])) {\r\n        limit++;\r\n      }\r\n      base = start;\r\n      hasReph = true;\r\n    }\r\n\r\n    switch (indicConfig.basePos) {\r\n      case 'Last': {\r\n        // starting from the end of the syllable, move backwards\r\n        let i = end;\r\n        let seenBelow = false;\r\n\r\n        do {\r\n          let info = glyphs[--i].shaperInfo;\r\n\r\n          // until a consonant is found\r\n          if (isConsonant(glyphs[i])) {\r\n            // that does not have a below-base or post-base form\r\n            // (post-base forms have to follow below-base forms),\r\n            if (info.position !== POSITIONS.Below_C && (info.position !== POSITIONS.Post_C || seenBelow)) {\r\n              base = i;\r\n              break;\r\n            }\r\n\r\n            // or that is not a pre-base reordering Ra,\r\n            //\r\n            // IMPLEMENTATION NOTES:\r\n            //\r\n            // Our pre-base reordering Ra's are marked POS_POST_C, so will be skipped\r\n            // by the logic above already.\r\n            //\r\n\r\n            // or arrive at the first consonant. The consonant stopped at will\r\n            // be the base.\r\n            if (info.position === POSITIONS.Below_C) {\r\n              seenBelow = true;\r\n            }\r\n\r\n            base = i;\r\n          } else if (start < i && info.category === CATEGORIES.ZWJ && glyphs[i - 1].shaperInfo.category === CATEGORIES.H) {\r\n            // A ZWJ after a Halant stops the base search, and requests an explicit\r\n            // half form.\r\n            // A ZWJ before a Halant, requests a subjoined form instead, and hence\r\n            // search continues.  This is particularly important for Bengali\r\n            // sequence Ra,H,Ya that should form Ya-Phalaa by subjoining Ya.\r\n            break;\r\n          }\r\n        } while (i > limit);\r\n        break;\r\n      }\r\n\r\n      case 'First': {\r\n        // The first consonant is always the base.\r\n        base = start;\r\n\r\n        // Mark all subsequent consonants as below.\r\n        for (let i = base + 1; i < end; i++) {\r\n          if (isConsonant(glyphs[i])) {\r\n            glyphs[i].shaperInfo.position = POSITIONS.Below_C;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // If the syllable starts with Ra + Halant (in a script that has Reph)\r\n    // and has more than one consonant, Ra is excluded from candidates for\r\n    // base consonants.\r\n    //\r\n    //  Only do this for unforced Reph. (ie. not for Ra,H,ZWJ)\r\n    if (hasReph && base === start && limit - base <= 2) {\r\n      hasReph = false;\r\n    }\r\n\r\n    // 2. Decompose and reorder Matras:\r\n    //\r\n    // Each matra and any syllable modifier sign in the cluster are moved to the\r\n    // appropriate position relative to the consonant(s) in the cluster. The\r\n    // shaping engine decomposes two- or three-part matras into their constituent\r\n    // parts before any repositioning. Matra characters are classified by which\r\n    // consonant in a conjunct they have affinity for and are reordered to the\r\n    // following positions:\r\n    //\r\n    //   o Before first half form in the syllable\r\n    //   o After subjoined consonants\r\n    //   o After post-form consonant\r\n    //   o After main consonant (for above marks)\r\n    //\r\n    // IMPLEMENTATION NOTES:\r\n    //\r\n    // The normalize() routine has already decomposed matras for us, so we don't\r\n    // need to worry about that.\r\n\r\n    // 3.  Reorder marks to canonical order:\r\n    //\r\n    // Adjacent nukta and halant or nukta and vedic sign are always repositioned\r\n    // if necessary, so that the nukta is first.\r\n    //\r\n    // IMPLEMENTATION NOTES:\r\n    //\r\n    // We don't need to do this: the normalize() routine already did this for us.\r\n\r\n    // Reorder characters\r\n\r\n    for (let i = start; i < base; i++) {\r\n      let info = glyphs[i].shaperInfo;\r\n      info.position = Math.min(POSITIONS.Pre_C, info.position);\r\n    }\r\n\r\n    if (base < end) {\r\n      glyphs[base].shaperInfo.position = POSITIONS.Base_C;\r\n    }\r\n\r\n    // Mark final consonants.  A final consonant is one appearing after a matra,\r\n    // like in Khmer.\r\n    for (let i = base + 1; i < end; i++) {\r\n      if (glyphs[i].shaperInfo.category === CATEGORIES.M) {\r\n        for (let j = i + 1; j < end; j++) {\r\n          if (isConsonant(glyphs[j])) {\r\n            glyphs[j].shaperInfo.position = POSITIONS.Final_C;\r\n            break;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Handle beginning Ra\r\n    if (hasReph) {\r\n      glyphs[start].shaperInfo.position = POSITIONS.Ra_To_Become_Reph;\r\n    }\r\n\r\n    // For old-style Indic script tags, move the first post-base Halant after\r\n    // last consonant.\r\n    //\r\n    // Reports suggest that in some scripts Uniscribe does this only if there\r\n    // is *not* a Halant after last consonant already (eg. Kannada), while it\r\n    // does it unconditionally in other scripts (eg. Malayalam).  We don't\r\n    // currently know about other scripts, so we single out Malayalam for now.\r\n    //\r\n    // Kannada test case:\r\n    // U+0C9A,U+0CCD,U+0C9A,U+0CCD\r\n    // With some versions of Lohit Kannada.\r\n    // https://bugs.freedesktop.org/show_bug.cgi?id=59118\r\n    //\r\n    // Malayalam test case:\r\n    // U+0D38,U+0D4D,U+0D31,U+0D4D,U+0D31,U+0D4D\r\n    // With lohit-ttf-20121122/Lohit-Malayalam.ttf\r\n    if (plan.isOldSpec) {\r\n      let disallowDoubleHalants = plan.unicodeScript !== 'Malayalam';\r\n      for (let i = base + 1; i < end; i++) {\r\n        if (glyphs[i].shaperInfo.category === CATEGORIES.H) {\r\n          let j;\r\n          for (j = end - 1; j > i; j--) {\r\n            if (isConsonant(glyphs[j]) || (disallowDoubleHalants && glyphs[j].shaperInfo.category === CATEGORIES.H)) {\r\n              break;\r\n            }\r\n          }\r\n\r\n          if (glyphs[j].shaperInfo.category !== CATEGORIES.H && j > i) {\r\n            // Move Halant to after last consonant.\r\n            let t = glyphs[i];\r\n            glyphs.splice(i, 0, ...glyphs.splice(i + 1, j - i));\r\n            glyphs[j] = t;\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Attach misc marks to previous char to move with them.\r\n    let lastPos = POSITIONS.Start;\r\n    for (let i = start; i < end; i++) {\r\n      let info = glyphs[i].shaperInfo;\r\n      if (info.category & (JOINER_FLAGS | CATEGORIES.N | CATEGORIES.RS | CATEGORIES.CM | HALANT_OR_COENG_FLAGS & info.category)) {\r\n        info.position = lastPos;\r\n        if (info.category === CATEGORIES.H && info.position === POSITIONS.Pre_M) {\r\n          // Uniscribe doesn't move the Halant with Left Matra.\r\n          // TEST: U+092B,U+093F,U+094DE\r\n          // We follow.  This is important for the Sinhala\r\n          // U+0DDA split matra since it decomposes to U+0DD9,U+0DCA\r\n          // where U+0DD9 is a left matra and U+0DCA is the virama.\r\n          // We don't want to move the virama with the left matra.\r\n          // TEST: U+0D9A,U+0DDA\r\n          for (let j = i; j > start; j--) {\r\n            if (glyphs[j - 1].shaperInfo.position !== POSITIONS.Pre_M) {\r\n              info.position = glyphs[j - 1].shaperInfo.position;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      } else if (info.position !== POSITIONS.SMVD) {\r\n        lastPos = info.position;\r\n      }\r\n    }\r\n\r\n    // For post-base consonants let them own anything before them\r\n    // since the last consonant or matra.\r\n    let last = base;\r\n    for (let i = base + 1; i < end; i++) {\r\n      if (isConsonant(glyphs[i])) {\r\n        for (let j = last + 1; j < i; j++) {\r\n          if (glyphs[j].shaperInfo.position < POSITIONS.SMVD) {\r\n            glyphs[j].shaperInfo.position = glyphs[i].shaperInfo.position;\r\n          }\r\n        }\r\n        last = i;\r\n      } else if (glyphs[i].shaperInfo.category === CATEGORIES.M) {\r\n        last = i;\r\n      }\r\n    }\r\n\r\n    let arr = glyphs.slice(start, end);\r\n    arr.sort((a, b) => a.shaperInfo.position - b.shaperInfo.position);\r\n    glyphs.splice(start, arr.length, ...arr);\r\n\r\n    // Find base again\r\n    for (let i = start; i < end; i++) {\r\n      if (glyphs[i].shaperInfo.position === POSITIONS.Base_C) {\r\n        base = i;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Setup features now\r\n\r\n    // Reph\r\n    for (let i = start; i < end && glyphs[i].shaperInfo.position === POSITIONS.Ra_To_Become_Reph; i++) {\r\n      glyphs[i].features.rphf = true;\r\n    }\r\n\r\n    // Pre-base\r\n    let blwf = !plan.isOldSpec && indicConfig.blwfMode === 'Pre_And_Post';\r\n    for (let i = start; i < base; i++) {\r\n      glyphs[i].features.half = true;\r\n      if (blwf) {\r\n        glyphs[i].features.blwf = true;\r\n      }\r\n    }\r\n\r\n    // Post-base\r\n    for (let i = base + 1; i < end; i++) {\r\n      glyphs[i].features.abvf = true;\r\n      glyphs[i].features.pstf = true;\r\n      glyphs[i].features.blwf = true;\r\n    }\r\n\r\n    if (plan.isOldSpec && plan.unicodeScript === 'Devanagari') {\r\n      // Old-spec eye-lash Ra needs special handling.  From the\r\n      // spec:\r\n      //\r\n      // \"The feature 'below-base form' is applied to consonants\r\n      // having below-base forms and following the base consonant.\r\n      // The exception is vattu, which may appear below half forms\r\n      // as well as below the base glyph. The feature 'below-base\r\n      // form' will be applied to all such occurrences of Ra as well.\"\r\n      //\r\n      // Test case: U+0924,U+094D,U+0930,U+094d,U+0915\r\n      // with Sanskrit 2003 font.\r\n      //\r\n      // However, note that Ra,Halant,ZWJ is the correct way to\r\n      // request eyelash form of Ra, so we wouldbn't inhibit it\r\n      // in that sequence.\r\n      //\r\n      // Test case: U+0924,U+094D,U+0930,U+094d,U+200D,U+0915\r\n      for (let i = start; i + 1 < base; i++) {\r\n        if (glyphs[i].shaperInfo.category === CATEGORIES.Ra &&\r\n          glyphs[i + 1].shaperInfo.category === CATEGORIES.H &&\r\n          (i + 1 === base || glyphs[i + 2].shaperInfo.category === CATEGORIES.ZWJ)\r\n        ) {\r\n          glyphs[i].features.blwf = true;\r\n          glyphs[i + 1].features.blwf = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    let prefLen = 2;\r\n    if (features.pref && base + prefLen < end) {\r\n      // Find a Halant,Ra sequence and mark it for pre-base reordering processing.\r\n      for (let i = base + 1; i + prefLen - 1 < end; i++) {\r\n        let g = [glyphs[i].copy(), glyphs[i + 1].copy()];\r\n        if (wouldSubstitute(g, 'pref')) {\r\n          for (let j = 0; j < prefLen; j++) {\r\n            glyphs[i++].features.pref = true;\r\n          }\r\n\r\n          // Mark the subsequent stuff with 'cfar'.  Used in Khmer.\r\n          // Read the feature spec.\r\n          // This allows distinguishing the following cases with MS Khmer fonts:\r\n          // U+1784,U+17D2,U+179A,U+17D2,U+1782\r\n          // U+1784,U+17D2,U+1782,U+17D2,U+179A\r\n          if (features.cfar) {\r\n            for (; i < end; i++) {\r\n              glyphs[i].features.cfar = true;\r\n            }\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Apply ZWJ/ZWNJ effects\r\n    for (let i = start + 1; i < end; i++) {\r\n      if (isJoiner(glyphs[i])) {\r\n        let nonJoiner = glyphs[i].shaperInfo.category === CATEGORIES.ZWNJ;\r\n        let j = i;\r\n\r\n        do {\r\n          j--;\r\n\r\n          // ZWJ/ZWNJ should disable CJCT.  They do that by simply\r\n          // being there, since we don't skip them for the CJCT\r\n          // feature (ie. F_MANUAL_ZWJ)\r\n\r\n          // A ZWNJ disables HALF.\r\n          if (nonJoiner) {\r\n            delete glyphs[j].features.half;\r\n          }\r\n        } while (j > start && !isConsonant(glyphs[j]));\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction finalReordering(font, glyphs, plan) {\r\n  let indicConfig = plan.indicConfig;\r\n  let features = font._layoutEngine.engine.GSUBProcessor.features;\r\n\r\n  for (let start = 0, end = nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable(glyphs, start)) {\r\n    // 4. Final reordering:\r\n    //\r\n    // After the localized forms and basic shaping forms GSUB features have been\r\n    // applied (see below), the shaping engine performs some final glyph\r\n    // reordering before applying all the remaining font features to the entire\r\n    // cluster.\r\n\r\n    let tryPref = !!features.pref;\r\n\r\n    // Find base again\r\n    let base = start;\r\n    for (; base < end; base++) {\r\n      if (glyphs[base].shaperInfo.position >= POSITIONS.Base_C) {\r\n        if (tryPref && base + 1 < end) {\r\n          for (let i = base + 1; i < end; i++) {\r\n            if (glyphs[i].features.pref) {\r\n              if (!(glyphs[i].substituted && glyphs[i].isLigated && !glyphs[i].isMultiplied)) {\r\n                // Ok, this was a 'pref' candidate but didn't form any.\r\n                // Base is around here...\r\n                base = i;\r\n                while (base < end && isHalantOrCoeng(glyphs[base])) {\r\n                  base++;\r\n                }\r\n                glyphs[base].shaperInfo.position = POSITIONS.BASE_C;\r\n                tryPref = false;\r\n              }\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        // For Malayalam, skip over unformed below- (but NOT post-) forms.\r\n        if (plan.unicodeScript === 'Malayalam') {\r\n          for (let i = base + 1; i < end; i++) {\r\n            while (i < end && isJoiner(glyphs[i])) {\r\n              i++;\r\n            }\r\n\r\n            if (i === end || !isHalantOrCoeng(glyphs[i])) {\r\n              break;\r\n            }\r\n\r\n            i++; // Skip halant.\r\n            while (i < end && isJoiner(glyphs[i])) {\r\n              i++;\r\n            }\r\n\r\n            if (i < end && isConsonant(glyphs[i]) && glyphs[i].shaperInfo.position === POSITIONS.Below_C) {\r\n              base = i;\r\n              glyphs[base].shaperInfo.position = POSITIONS.Base_C;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (start < base && glyphs[base].shaperInfo.position > POSITIONS.Base_C) {\r\n          base--;\r\n        }\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (base === end && start < base && glyphs[base - 1].shaperInfo.category === CATEGORIES.ZWJ) {\r\n      base--;\r\n    }\r\n\r\n    if (base < end) {\r\n      while (start < base && glyphs[base].shaperInfo.category & (CATEGORIES.N | HALANT_OR_COENG_FLAGS)) {\r\n        base--;\r\n      }\r\n    }\r\n\r\n    // o Reorder matras:\r\n    //\r\n    // If a pre-base matra character had been reordered before applying basic\r\n    // features, the glyph can be moved closer to the main consonant based on\r\n    // whether half-forms had been formed. Actual position for the matra is\r\n    // defined as “after last standalone halant glyph, after initial matra\r\n    // position and before the main consonant”. If ZWJ or ZWNJ follow this\r\n    // halant, position is moved after it.\r\n    //\r\n\r\n    if (start + 1 < end && start < base) { // Otherwise there can't be any pre-base matra characters.\r\n      // If we lost track of base, alas, position before last thingy.\r\n      let newPos = base === end ? base - 2 : base - 1;\r\n\r\n      // Malayalam / Tamil do not have \"half\" forms or explicit virama forms.\r\n      // The glyphs formed by 'half' are Chillus or ligated explicit viramas.\r\n      // We want to position matra after them.\r\n      if (plan.unicodeScript !== 'Malayalam' && plan.unicodeScript !== 'Tamil') {\r\n        while (newPos > start && !(glyphs[newPos].shaperInfo.category & (CATEGORIES.M | HALANT_OR_COENG_FLAGS))) {\r\n          newPos--;\r\n        }\r\n\r\n        // If we found no Halant we are done.\r\n        // Otherwise only proceed if the Halant does\r\n        // not belong to the Matra itself!\r\n        if (isHalantOrCoeng(glyphs[newPos]) && glyphs[newPos].shaperInfo.position !== POSITIONS.Pre_M) {\r\n          // If ZWJ or ZWNJ follow this halant, position is moved after it.\r\n          if (newPos + 1 < end && isJoiner(glyphs[newPos + 1])) {\r\n            newPos++;\r\n          }\r\n        } else {\r\n          newPos = start; // No move.\r\n        }\r\n      }\r\n\r\n      if (start < newPos && glyphs[newPos].shaperInfo.position !== POSITIONS.Pre_M) {\r\n        // Now go see if there's actually any matras...\r\n        for (let i = newPos; i > start; i--) {\r\n          if (glyphs[i - 1].shaperInfo.position === POSITIONS.Pre_M) {\r\n            let oldPos = i - 1;\r\n            if (oldPos < base && base <= newPos) { // Shouldn't actually happen.\r\n              base--;\r\n            }\r\n\r\n            let tmp = glyphs[oldPos];\r\n            glyphs.splice(oldPos, 0, ...glyphs.splice(oldPos + 1, newPos - oldPos));\r\n            glyphs[newPos] = tmp;\r\n\r\n            newPos--;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // o Reorder reph:\r\n    //\r\n    // Reph’s original position is always at the beginning of the syllable,\r\n    // (i.e. it is not reordered at the character reordering stage). However,\r\n    // it will be reordered according to the basic-forms shaping results.\r\n    // Possible positions for reph, depending on the script, are; after main,\r\n    // before post-base consonant forms, and after post-base consonant forms.\r\n\r\n    // Two cases:\r\n    //\r\n    // - If repha is encoded as a sequence of characters (Ra,H or Ra,H,ZWJ), then\r\n    //   we should only move it if the sequence ligated to the repha form.\r\n    //\r\n    // - If repha is encoded separately and in the logical position, we should only\r\n    //   move it if it did NOT ligate.  If it ligated, it's probably the font trying\r\n    //   to make it work without the reordering.\r\n    if (start + 1 < end &&\r\n      glyphs[start].shaperInfo.position === POSITIONS.Ra_To_Become_Reph &&\r\n      (glyphs[start].shaperInfo.category === CATEGORIES.Repha) !== (glyphs[start].isLigated && !glyphs[start].isMultiplied)\r\n    ) {\r\n      let newRephPos;\r\n      let rephPos = indicConfig.rephPos;\r\n      let found = false;\r\n\r\n      // 1. If reph should be positioned after post-base consonant forms,\r\n      //    proceed to step 5.\r\n      if (rephPos !== POSITIONS.After_Post) {\r\n        //  2. If the reph repositioning class is not after post-base: target\r\n        //     position is after the first explicit halant glyph between the\r\n        //     first post-reph consonant and last main consonant. If ZWJ or ZWNJ\r\n        //     are following this halant, position is moved after it. If such\r\n        //     position is found, this is the target position. Otherwise,\r\n        //     proceed to the next step.\r\n        //\r\n        //     Note: in old-implementation fonts, where classifications were\r\n        //     fixed in shaping engine, there was no case where reph position\r\n        //     will be found on this step.\r\n        newRephPos = start + 1;\r\n        while (newRephPos < base && !isHalantOrCoeng(glyphs[newRephPos])) {\r\n          newRephPos++;\r\n        }\r\n\r\n        if (newRephPos < base && isHalantOrCoeng(glyphs[newRephPos])) {\r\n          // ->If ZWJ or ZWNJ are following this halant, position is moved after it.\r\n          if (newRephPos + 1 < base && isJoiner(glyphs[newRephPos + 1])) {\r\n            newRephPos++;\r\n          }\r\n\r\n          found = true;\r\n        }\r\n\r\n        // 3. If reph should be repositioned after the main consonant: find the\r\n        //    first consonant not ligated with main, or find the first\r\n        //    consonant that is not a potential pre-base reordering Ra.\r\n        if (!found && rephPos === POSITIONS.After_Main) {\r\n          newRephPos = base;\r\n          while (newRephPos + 1 < end && glyphs[newRephPos + 1].shaperInfo.position <= POSITIONS.After_Main) {\r\n            newRephPos++;\r\n          }\r\n\r\n          found = newRephPos < end;\r\n        }\r\n\r\n        // 4. If reph should be positioned before post-base consonant, find\r\n        //    first post-base classified consonant not ligated with main. If no\r\n        //    consonant is found, the target position should be before the\r\n        //    first matra, syllable modifier sign or vedic sign.\r\n        //\r\n        // This is our take on what step 4 is trying to say (and failing, BADLY).\r\n        if (!found && rephPos === POSITIONS.After_Sub) {\r\n          newRephPos = base;\r\n          while (newRephPos + 1 < end && !(glyphs[newRephPos + 1].shaperInfo.position & (POSITIONS.Post_C | POSITIONS.After_Post | POSITIONS.SMVD))) {\r\n            newRephPos++;\r\n          }\r\n\r\n          found = newRephPos < end;\r\n        }\r\n      }\r\n\r\n      //  5. If no consonant is found in steps 3 or 4, move reph to a position\r\n      //     immediately before the first post-base matra, syllable modifier\r\n      //     sign or vedic sign that has a reordering class after the intended\r\n      //     reph position. For example, if the reordering position for reph\r\n      //     is post-main, it will skip above-base matras that also have a\r\n      //     post-main position.\r\n      if (!found) {\r\n        // Copied from step 2.\r\n        newRephPos = start + 1;\r\n        while (newRephPos < base && !isHalantOrCoeng(glyphs[newRephPos])) {\r\n          newRephPos++;\r\n        }\r\n\r\n        if (newRephPos < base && isHalantOrCoeng(glyphs[newRephPos])) {\r\n          // ->If ZWJ or ZWNJ are following this halant, position is moved after it.\r\n          if (newRephPos + 1 < base && isJoiner(glyphs[newRephPos + 1])) {\r\n            newRephPos++;\r\n          }\r\n\r\n          found = true;\r\n        }\r\n      }\r\n\r\n      // 6. Otherwise, reorder reph to the end of the syllable.\r\n      if (!found) {\r\n        newRephPos = end - 1;\r\n        while (newRephPos > start && glyphs[newRephPos].shaperInfo.position === POSITIONS.SMVD) {\r\n          newRephPos--;\r\n        }\r\n\r\n        // If the Reph is to be ending up after a Matra,Halant sequence,\r\n        // position it before that Halant so it can interact with the Matra.\r\n        // However, if it's a plain Consonant,Halant we shouldn't do that.\r\n        // Uniscribe doesn't do this.\r\n        // TEST: U+0930,U+094D,U+0915,U+094B,U+094D\r\n        if (isHalantOrCoeng(glyphs[newRephPos])) {\r\n          for (let i = base + 1; i < newRephPos; i++) {\r\n            if (glyphs[i].shaperInfo.category === CATEGORIES.M) {\r\n              newRephPos--;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      let reph = glyphs[start];\r\n      glyphs.splice(start, 0, ...glyphs.splice(start + 1, newRephPos - start));\r\n      glyphs[newRephPos] = reph;\r\n\r\n      if (start < base && base <= newRephPos) {\r\n        base--;\r\n      }\r\n    }\r\n\r\n    // o Reorder pre-base reordering consonants:\r\n    //\r\n    // If a pre-base reordering consonant is found, reorder it according to\r\n    // the following rules:\r\n    if (tryPref && base + 1 < end) {\r\n      for (let i = base + 1; i < end; i++) {\r\n        if (glyphs[i].features.pref) {\r\n           // 1. Only reorder a glyph produced by substitution during application\r\n           //    of the <pref> feature. (Note that a font may shape a Ra consonant with\r\n           //    the feature generally but block it in certain contexts.)\r\n\r\n          // Note: We just check that something got substituted.  We don't check that\r\n          // the <pref> feature actually did it...\r\n          //\r\n          // Reorder pref only if it ligated.\r\n          if (glyphs[i].isLigated && !glyphs[i].isMultiplied) {\r\n            // 2. Try to find a target position the same way as for pre-base matra.\r\n            //    If it is found, reorder pre-base consonant glyph.\r\n            //\r\n            // 3. If position is not found, reorder immediately before main\r\n            //    consonant.\r\n            let newPos = base;\r\n\r\n            // Malayalam / Tamil do not have \"half\" forms or explicit virama forms.\r\n            // The glyphs formed by 'half' are Chillus or ligated explicit viramas.\r\n            // We want to position matra after them.\r\n            if (plan.unicodeScript !== 'Malayalam' && plan.unicodeScript !== 'Tamil') {\r\n              while (newPos > start && !(glyphs[newPos - 1].shaperInfo.category & (CATEGORIES.M | HALANT_OR_COENG_FLAGS))) {\r\n                newPos--;\r\n              }\r\n\r\n              // In Khmer coeng model, a H,Ra can go *after* matras.  If it goes after a\r\n              // split matra, it should be reordered to *before* the left part of such matra.\r\n              if (newPos > start && glyphs[newPos - 1].shaperInfo.category === CATEGORIES.M) {\r\n                let oldPos = i;\r\n                for (let j = base + 1; j < oldPos; j++) {\r\n                  if (glyphs[j].shaperInfo.category === CATEGORIES.M) {\r\n                    newPos--;\r\n                    break;\r\n                  }\r\n                }\r\n              }\r\n            }\r\n\r\n            if (newPos > start && isHalantOrCoeng(glyphs[newPos - 1])) {\r\n              // -> If ZWJ or ZWNJ follow this halant, position is moved after it.\r\n              if (newPos < end && isJoiner(glyphs[newPos])) {\r\n                newPos++;\r\n              }\r\n            }\r\n\r\n            let oldPos = i;\r\n            let tmp = glyphs[oldPos];\r\n            glyphs.splice(newPos + 1, 0, ...glyphs.splice(newPos, oldPos - newPos));\r\n            glyphs[newPos] = tmp;\r\n\r\n            if (newPos <= base && base < oldPos) {\r\n              base++;\r\n            }\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Apply 'init' to the Left Matra if it's a word start.\r\n    if (glyphs[start].shaperInfo.position === POSITIONS.Pre_M && (!start || !/Cf|Mn/.test(unicode.getCategory(glyphs[start - 1].codePoints[0])))) {\r\n      glyphs[start].features.init = true;\r\n    }\r\n  }\r\n}\r\n\r\nfunction nextSyllable(glyphs, start) {\r\n  if (start >= glyphs.length) return start;\r\n  let syllable = glyphs[start].shaperInfo.syllable;\r\n  while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable);\r\n  return start;\r\n}\r\n","import DefaultShaper from './DefaultShaper';\r\nimport StateMachine from 'dfa';\r\nimport UnicodeTrie from 'unicode-trie';\r\nimport GlyphInfo from '../GlyphInfo';\r\nimport useData from './use.json';\r\n\r\nconst {categories, decompositions} = useData;\r\nconst trie = new UnicodeTrie(require('fs').readFileSync(__dirname + '/use.trie'));\r\nconst stateMachine = new StateMachine(useData);\r\n\r\n/**\r\n * This shaper is an implementation of the Universal Shaping Engine, which\r\n * uses Unicode data to shape a number of scripts without a dedicated shaping engine.\r\n * See https://www.microsoft.com/typography/OpenTypeDev/USE/intro.htm.\r\n */\r\nexport default class UniversalShaper extends DefaultShaper {\r\n  static zeroMarkWidths = 'BEFORE_GPOS';\r\n  static planFeatures(plan) {\r\n    plan.addStage(setupSyllables);\r\n\r\n    // Default glyph pre-processing group\r\n    plan.addStage(['locl', 'ccmp', 'nukt', 'akhn']);\r\n\r\n    // Reordering group\r\n    plan.addStage(clearSubstitutionFlags);\r\n    plan.addStage(['rphf'], false);\r\n    plan.addStage(recordRphf);\r\n    plan.addStage(clearSubstitutionFlags);\r\n    plan.addStage(['pref']);\r\n    plan.addStage(recordPref);\r\n\r\n    // Orthographic unit shaping group\r\n    plan.addStage(['rkrf', 'abvf', 'blwf', 'half', 'pstf', 'vatu', 'cjct']);\r\n    plan.addStage(reorder);\r\n\r\n    // Topographical features\r\n    // Scripts that need this are handled by the Arabic shaper, not implemented here for now.\r\n    // plan.addStage(['isol', 'init', 'medi', 'fina', 'med2', 'fin2', 'fin3'], false);\r\n\r\n    // Standard topographic presentation and positional feature application\r\n    plan.addStage(['abvs', 'blws', 'pres', 'psts', 'dist', 'abvm', 'blwm']);\r\n  }\r\n\r\n  static assignFeatures(plan, glyphs) {\r\n    // Decompose split vowels\r\n    // TODO: do this in a more general unicode normalizer\r\n    for (let i = glyphs.length - 1; i >= 0; i--) {\r\n      let codepoint = glyphs[i].codePoints[0];\r\n      if (decompositions[codepoint]) {\r\n        let decomposed = decompositions[codepoint].map(c => {\r\n          let g = plan.font.glyphForCodePoint(c);\r\n          return new GlyphInfo(plan.font, g.id, [c], glyphs[i].features);\r\n        });\r\n\r\n        glyphs.splice(i, 1, ...decomposed);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction useCategory(glyph) {\r\n  return trie.get(glyph.codePoints[0]);\r\n}\r\n\r\nclass USEInfo {\r\n  constructor(category, syllableType, syllable) {\r\n    this.category = category;\r\n    this.syllableType = syllableType;\r\n    this.syllable = syllable;\r\n  }\r\n}\r\n\r\nfunction setupSyllables(font, glyphs) {\r\n  let syllable = 0;\r\n  for (let [start, end, tags] of stateMachine.match(glyphs.map(useCategory))) {\r\n    ++syllable;\r\n\r\n    // Create shaper info\r\n    for (let i = start; i <= end; i++) {\r\n      glyphs[i].shaperInfo = new USEInfo(categories[useCategory(glyphs[i])], tags[0], syllable);\r\n    }\r\n\r\n    // Assign rphf feature\r\n    let limit = glyphs[start].shaperInfo.category === 'R' ? 1 : Math.min(3, end - start);\r\n    for (let i = start; i < start + limit; i++) {\r\n      glyphs[i].features.rphf = true;\r\n    }\r\n  }\r\n}\r\n\r\nfunction clearSubstitutionFlags(font, glyphs) {\r\n  for (let glyph of glyphs) {\r\n    glyph.substituted = false;\r\n  }\r\n}\r\n\r\nfunction recordRphf(font, glyphs) {\r\n  for (let glyph of glyphs) {\r\n    if (glyph.substituted && glyph.features.rphf) {\r\n      // Mark a substituted repha.\r\n      glyph.shaperInfo.category = 'R';\r\n    }\r\n  }\r\n}\r\n\r\nfunction recordPref(font, glyphs) {\r\n  for (let glyph of glyphs) {\r\n    if (glyph.substituted) {\r\n      // Mark a substituted pref as VPre, as they behave the same way.\r\n      glyph.shaperInfo.category = 'VPre';\r\n    }\r\n  }\r\n}\r\n\r\nfunction reorder(font, glyphs) {\r\n  let dottedCircle = font.glyphForCodePoint(0x25cc).id;\r\n\r\n  for (let start = 0, end = nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable(glyphs, start)) {\r\n    let i, j;\r\n    let info = glyphs[start].shaperInfo;\r\n    let type = info.syllableType;\r\n\r\n    // Only a few syllable types need reordering.\r\n    if (type !== 'virama_terminated_cluster' && type !== 'standard_cluster' && type !== 'broken_cluster') {\r\n      continue;\r\n    }\r\n\r\n    // Insert a dotted circle glyph in broken clusters.\r\n    if (type === 'broken_cluster' && dottedCircle) {\r\n      let g = new GlyphInfo(font, dottedCircle, [0x25cc]);\r\n      g.shaperInfo = info;\r\n\r\n      // Insert after possible Repha.\r\n      for (i = start; i < end && glyphs[i].shaperInfo.category === 'R'; i++);\r\n      glyphs.splice(++i, 0, g);\r\n      end++;\r\n    }\r\n\r\n    // Move things forward.\r\n    if (info.category === 'R' && end - start > 1) {\r\n      // Got a repha. Reorder it to after first base, before first halant.\r\n      for (i = start + 1; i < end; i++) {\r\n        info = glyphs[i].shaperInfo;\r\n        if (isBase(info) || isHalant(glyphs[i])) {\r\n          // If we hit a halant, move before it; otherwise it's a base: move to it's\r\n          // place, and shift things in between backward.\r\n          if (isHalant(glyphs[i])) {\r\n            i--;\r\n          }\r\n\r\n          glyphs.splice(start, 0, ...glyphs.splice(start + 1, i - start), glyphs[i]);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Move things back.\r\n    for (i = start, j = end; i < end; i++) {\r\n      info = glyphs[i].shaperInfo;\r\n      if (isBase(info) || isHalant(glyphs[i])) {\r\n        // If we hit a halant, move after it; otherwise it's a base: move to it's\r\n        // place, and shift things in between backward.\r\n        j = isHalant(glyphs[i]) ? i + 1 : i;\r\n      } else if ((info.category === 'VPre' || info.category === 'VMPre') && j < i) {\r\n        glyphs.splice(j, 1, glyphs[i], ...glyphs.splice(j, i - j));\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction nextSyllable(glyphs, start) {\r\n  if (start >= glyphs.length) return start;\r\n  let syllable = glyphs[start].shaperInfo.syllable;\r\n  while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable);\r\n  return start;\r\n}\r\n\r\nfunction isHalant(glyph) {\r\n  return glyph.shaperInfo.category === 'H' && !glyph.isLigated;\r\n}\r\n\r\nfunction isBase(info) {\r\n  return info.category === 'B' || info.category === 'GB';\r\n}\r\n","import DefaultShaper from './DefaultShaper';\r\nimport ArabicShaper from './ArabicShaper';\r\nimport HangulShaper from './HangulShaper';\r\nimport IndicShaper from './IndicShaper';\r\nimport UniversalShaper from './UniversalShaper';\r\n\r\nconst SHAPERS = {\r\n  arab: ArabicShaper,    // Arabic\r\n  mong: ArabicShaper,    // Mongolian\r\n  syrc: ArabicShaper,    // Syriac\r\n  'nko ': ArabicShaper,  // N'Ko\r\n  phag: ArabicShaper,    // Phags Pa\r\n  mand: ArabicShaper,    // Mandaic\r\n  mani: ArabicShaper,    // Manichaean\r\n  phlp: ArabicShaper,    // Psalter Pahlavi\r\n\r\n  hang: HangulShaper,    // Hangul\r\n\r\n  bng2: IndicShaper,     // Bengali\r\n  beng: IndicShaper,     // Bengali\r\n  dev2: IndicShaper,     // Devanagari\r\n  deva: IndicShaper,     // Devanagari\r\n  gjr2: IndicShaper,     // Gujarati\r\n  gujr: IndicShaper,     // Gujarati\r\n  guru: IndicShaper,     // Gurmukhi\r\n  gur2: IndicShaper,     // Gurmukhi\r\n  knda: IndicShaper,     // Kannada\r\n  knd2: IndicShaper,     // Kannada\r\n  mlm2: IndicShaper,     // Malayalam\r\n  mlym: IndicShaper,     // Malayalam\r\n  ory2: IndicShaper,     // Oriya\r\n  orya: IndicShaper,     // Oriya\r\n  taml: IndicShaper,     // Tamil\r\n  tml2: IndicShaper,     // Tamil\r\n  telu: IndicShaper,     // Telugu\r\n  tel2: IndicShaper,     // Telugu\r\n  khmr: IndicShaper,     // Khmer\r\n\r\n  bali: UniversalShaper, // Balinese\r\n  batk: UniversalShaper, // Batak\r\n  brah: UniversalShaper, // Brahmi\r\n  bugi: UniversalShaper, // Buginese\r\n  buhd: UniversalShaper, // Buhid\r\n  cakm: UniversalShaper, // Chakma\r\n  cham: UniversalShaper, // Cham\r\n  dupl: UniversalShaper, // Duployan\r\n  egyp: UniversalShaper, // Egyptian Hieroglyphs\r\n  gran: UniversalShaper, // Grantha\r\n  hano: UniversalShaper, // Hanunoo\r\n  java: UniversalShaper, // Javanese\r\n  kthi: UniversalShaper, // Kaithi\r\n  kali: UniversalShaper, // Kayah Li\r\n  khar: UniversalShaper, // Kharoshthi\r\n  khoj: UniversalShaper, // Khojki\r\n  sind: UniversalShaper, // Khudawadi\r\n  lepc: UniversalShaper, // Lepcha\r\n  limb: UniversalShaper, // Limbu\r\n  mahj: UniversalShaper, // Mahajani\r\n  // mand: UniversalShaper, // Mandaic\r\n  // mani: UniversalShaper, // Manichaean\r\n  mtei: UniversalShaper, // Meitei Mayek\r\n  modi: UniversalShaper, // Modi\r\n  // mong: UniversalShaper, // Mongolian\r\n  // 'nko ': UniversalShaper, // N’Ko\r\n  hmng: UniversalShaper, // Pahawh Hmong\r\n  // phag: UniversalShaper, // Phags-pa\r\n  // phlp: UniversalShaper, // Psalter Pahlavi\r\n  rjng: UniversalShaper, // Rejang\r\n  saur: UniversalShaper, // Saurashtra\r\n  shrd: UniversalShaper, // Sharada\r\n  sidd: UniversalShaper, // Siddham\r\n  sinh: UniversalShaper, // Sinhala\r\n  sund: UniversalShaper, // Sundanese\r\n  sylo: UniversalShaper, // Syloti Nagri\r\n  tglg: UniversalShaper, // Tagalog\r\n  tagb: UniversalShaper, // Tagbanwa\r\n  tale: UniversalShaper, // Tai Le\r\n  lana: UniversalShaper, // Tai Tham\r\n  tavt: UniversalShaper, // Tai Viet\r\n  takr: UniversalShaper, // Takri\r\n  tibt: UniversalShaper, // Tibetan\r\n  tfng: UniversalShaper, // Tifinagh\r\n  tirh: UniversalShaper, // Tirhuta\r\n\r\n  latn: DefaultShaper,   // Latin\r\n  DFLT: DefaultShaper    // Default\r\n};\r\n\r\nexport function choose(script) {\r\n  if (!Array.isArray(script)) {\r\n    script = [script];\r\n  }\r\n\r\n  for (let s of script) {\r\n    let shaper = SHAPERS[s];\r\n    if (shaper) {\r\n      return shaper;\r\n    }\r\n  }\r\n\r\n  return DefaultShaper;\r\n}\r\n","import OTProcessor from './OTProcessor';\r\nimport GlyphInfo from './GlyphInfo';\r\n\r\nexport default class GSUBProcessor extends OTProcessor {\r\n  applyLookup(lookupType, table) {\r\n    switch (lookupType) {\r\n      case 1: { // Single Substitution\r\n        let index = this.coverageIndex(table.coverage);\r\n        if (index === -1) {\r\n          return false;\r\n        }\r\n\r\n        let glyph = this.glyphIterator.cur;\r\n        switch (table.version) {\r\n          case 1:\r\n            glyph.id = (glyph.id + table.deltaGlyphID) & 0xffff;\r\n            break;\r\n\r\n          case 2:\r\n            glyph.id = table.substitute.get(index);\r\n            break;\r\n        }\r\n\r\n        return true;\r\n      }\r\n\r\n      case 2: { // Multiple Substitution\r\n        let index = this.coverageIndex(table.coverage);\r\n        if (index !== -1) {\r\n          let sequence = table.sequences.get(index);\r\n\r\n          if (sequence.length === 0) {\r\n            // If the sequence length is zero, delete the glyph.\r\n            // The OpenType spec disallows this, but seems like Harfbuzz and Uniscribe allow it.\r\n            this.glyphs.splice(this.glyphIterator.index, 1);\r\n            return true;\r\n          }\r\n\r\n          this.glyphIterator.cur.id = sequence[0];\r\n          this.glyphIterator.cur.ligatureComponent = 0;\r\n\r\n          let features = this.glyphIterator.cur.features;\r\n          let curGlyph = this.glyphIterator.cur;\r\n          let replacement = sequence.slice(1).map((gid, i) => {\r\n            let glyph = new GlyphInfo(this.font, gid, undefined, features);\r\n            glyph.shaperInfo = curGlyph.shaperInfo;\r\n            glyph.isLigated = curGlyph.isLigated;\r\n            glyph.ligatureComponent = i + 1;\r\n            glyph.substituted = true;\r\n            glyph.isMultiplied = true;\r\n            return glyph;\r\n          });\r\n\r\n          this.glyphs.splice(this.glyphIterator.index + 1, 0, ...replacement);\r\n          return true;\r\n        }\r\n\r\n        return false;\r\n      }\r\n\r\n      case 3: { // Alternate Substitution\r\n        let index = this.coverageIndex(table.coverage);\r\n        if (index !== -1) {\r\n          let USER_INDEX = 0; // TODO\r\n          this.glyphIterator.cur.id = table.alternateSet.get(index)[USER_INDEX];\r\n          return true;\r\n        }\r\n\r\n        return false;\r\n      }\r\n\r\n      case 4: { // Ligature Substitution\r\n        let index = this.coverageIndex(table.coverage);\r\n        if (index === -1) {\r\n          return false;\r\n        }\r\n\r\n        for (let ligature of table.ligatureSets.get(index)) {\r\n          let matched = this.sequenceMatchIndices(1, ligature.components);\r\n          if (!matched) {\r\n            continue;\r\n          }\r\n\r\n          let curGlyph = this.glyphIterator.cur;\r\n\r\n          // Concatenate all of the characters the new ligature will represent\r\n          let characters = curGlyph.codePoints.slice();\r\n          for (let index of matched) {\r\n            characters.push(...this.glyphs[index].codePoints);\r\n          }\r\n\r\n          // Create the replacement ligature glyph\r\n          let ligatureGlyph = new GlyphInfo(this.font, ligature.glyph, characters, curGlyph.features);\r\n          ligatureGlyph.shaperInfo = curGlyph.shaperInfo;\r\n          ligatureGlyph.isLigated = true;\r\n          ligatureGlyph.substituted = true;\r\n\r\n          // From Harfbuzz:\r\n          // - If it *is* a mark ligature, we don't allocate a new ligature id, and leave\r\n          //   the ligature to keep its old ligature id.  This will allow it to attach to\r\n          //   a base ligature in GPOS.  Eg. if the sequence is: LAM,LAM,SHADDA,FATHA,HEH,\r\n          //   and LAM,LAM,HEH for a ligature, they will leave SHADDA and FATHA with a\r\n          //   ligature id and component value of 2.  Then if SHADDA,FATHA form a ligature\r\n          //   later, we don't want them to lose their ligature id/component, otherwise\r\n          //   GPOS will fail to correctly position the mark ligature on top of the\r\n          //   LAM,LAM,HEH ligature. See https://bugzilla.gnome.org/show_bug.cgi?id=676343\r\n          //\r\n          // - If a ligature is formed of components that some of which are also ligatures\r\n          //   themselves, and those ligature components had marks attached to *their*\r\n          //   components, we have to attach the marks to the new ligature component\r\n          //   positions!  Now *that*'s tricky!  And these marks may be following the\r\n          //   last component of the whole sequence, so we should loop forward looking\r\n          //   for them and update them.\r\n          //\r\n          //   Eg. the sequence is LAM,LAM,SHADDA,FATHA,HEH, and the font first forms a\r\n          //   'calt' ligature of LAM,HEH, leaving the SHADDA and FATHA with a ligature\r\n          //   id and component == 1.  Now, during 'liga', the LAM and the LAM-HEH ligature\r\n          //   form a LAM-LAM-HEH ligature.  We need to reassign the SHADDA and FATHA to\r\n          //   the new ligature with a component value of 2.\r\n          //\r\n          //   This in fact happened to a font...  See https://bugzilla.gnome.org/show_bug.cgi?id=437633\r\n          let isMarkLigature = curGlyph.isMark;\r\n          for (let i = 0; i < matched.length && isMarkLigature; i++) {\r\n            isMarkLigature = this.glyphs[matched[i]].isMark;\r\n          }\r\n\r\n          ligatureGlyph.ligatureID = isMarkLigature ? null : this.ligatureID++;\r\n\r\n          let lastLigID = curGlyph.ligatureID;\r\n          let lastNumComps = curGlyph.codePoints.length;\r\n          let curComps = lastNumComps;\r\n          let idx = this.glyphIterator.index + 1;\r\n\r\n          // Set ligatureID and ligatureComponent on glyphs that were skipped in the matched sequence.\r\n          // This allows GPOS to attach marks to the correct ligature components.\r\n          for (let matchIndex of matched) {\r\n            // Don't assign new ligature components for mark ligatures (see above)\r\n            if (isMarkLigature) {\r\n              idx = matchIndex;\r\n            } else {\r\n              while (idx < matchIndex) {\r\n                var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[idx].ligatureComponent || 1, lastNumComps);\r\n                this.glyphs[idx].ligatureID = ligatureGlyph.ligatureID;\r\n                this.glyphs[idx].ligatureComponent = ligatureComponent;\r\n                idx++;\r\n              }\r\n            }\r\n\r\n            lastLigID = this.glyphs[idx].ligatureID;\r\n            lastNumComps = this.glyphs[idx].codePoints.length;\r\n            curComps += lastNumComps;\r\n            idx++; // skip base glyph\r\n          }\r\n\r\n          // Adjust ligature components for any marks following\r\n          if (lastLigID && !isMarkLigature) {\r\n            for (let i = idx; i < this.glyphs.length; i++) {\r\n              if (this.glyphs[i].ligatureID === lastLigID) {\r\n                var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[i].ligatureComponent || 1, lastNumComps);\r\n                this.glyphs[i].ligatureComponent = ligatureComponent;\r\n              } else {\r\n                break;\r\n              }\r\n            }\r\n          }\r\n\r\n          // Delete the matched glyphs, and replace the current glyph with the ligature glyph\r\n          for (let i = matched.length - 1; i >= 0; i--) {\r\n            this.glyphs.splice(matched[i], 1);\r\n          }\r\n\r\n          this.glyphs[this.glyphIterator.index] = ligatureGlyph;\r\n          return true;\r\n        }\r\n\r\n        return false;\r\n      }\r\n\r\n      case 5: // Contextual Substitution\r\n        return this.applyContext(table);\r\n\r\n      case 6: // Chaining Contextual Substitution\r\n        return this.applyChainingContext(table);\r\n\r\n      case 7: // Extension Substitution\r\n        return this.applyLookup(table.lookupType, table.extension);\r\n\r\n      default:\r\n        throw new Error(`GSUB lookupType ${lookupType} is not supported`);\r\n    }\r\n  }\r\n}\r\n","import OTProcessor from './OTProcessor';\r\n\r\nexport default class GPOSProcessor extends OTProcessor {\r\n  applyPositionValue(sequenceIndex, value) {\r\n    let position = this.positions[this.glyphIterator.peekIndex(sequenceIndex)];\r\n    if (value.xAdvance != null) {\r\n      position.xAdvance += value.xAdvance;\r\n    }\r\n\r\n    if (value.yAdvance != null) {\r\n      position.yAdvance += value.yAdvance;\r\n    }\r\n\r\n    if (value.xPlacement != null) {\r\n      position.xOffset += value.xPlacement;\r\n    }\r\n\r\n    if (value.yPlacement != null) {\r\n      position.yOffset += value.yPlacement;\r\n    }\r\n\r\n    // Adjustments for font variations\r\n    let variationProcessor = this.font._variationProcessor;\r\n    let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;\r\n    if (variationProcessor && variationStore) {\r\n      if (value.xPlaDevice) {\r\n        position.xOffset += variationProcessor.getDelta(variationStore, value.xPlaDevice.a, value.xPlaDevice.b);\r\n      }\r\n\r\n      if (value.yPlaDevice) {\r\n        position.yOffset += variationProcessor.getDelta(variationStore, value.yPlaDevice.a, value.yPlaDevice.b);\r\n      }\r\n\r\n      if (value.xAdvDevice) {\r\n        position.xAdvance += variationProcessor.getDelta(variationStore, value.xAdvDevice.a, value.xAdvDevice.b);\r\n      }\r\n\r\n      if (value.yAdvDevice) {\r\n        position.yAdvance += variationProcessor.getDelta(variationStore, value.yAdvDevice.a, value.yAdvDevice.b);\r\n      }\r\n    }\r\n\r\n    // TODO: device tables\r\n  }\r\n\r\n  applyLookup(lookupType, table) {\r\n    switch (lookupType) {\r\n      case 1: { // Single positioning value\r\n        let index = this.coverageIndex(table.coverage);\r\n        if (index === -1) {\r\n          return false;\r\n        }\r\n\r\n        switch (table.version) {\r\n          case 1:\r\n            this.applyPositionValue(0, table.value);\r\n            break;\r\n\r\n          case 2:\r\n            this.applyPositionValue(0, table.values.get(index));\r\n            break;\r\n        }\r\n\r\n        return true;\r\n      }\r\n\r\n      case 2: { // Pair Adjustment Positioning\r\n        let nextGlyph = this.glyphIterator.peek();\r\n        if (!nextGlyph) {\r\n          return false;\r\n        }\r\n\r\n        let index = this.coverageIndex(table.coverage);\r\n        if (index === -1) {\r\n          return false;\r\n        }\r\n\r\n        switch (table.version) {\r\n          case 1: // Adjustments for glyph pairs\r\n            let set = table.pairSets.get(index);\r\n\r\n            for (let pair of set) {\r\n              if (pair.secondGlyph === nextGlyph.id) {\r\n                this.applyPositionValue(0, pair.value1);\r\n                this.applyPositionValue(1, pair.value2);\r\n                return true;\r\n              }\r\n            }\r\n\r\n            return false;\r\n\r\n          case 2: // Class pair adjustment\r\n            let class1 = this.getClassID(this.glyphIterator.cur.id, table.classDef1);\r\n            let class2 = this.getClassID(nextGlyph.id, table.classDef2);\r\n            if (class1 === -1 || class2 === -1) {\r\n              return false;\r\n            }\r\n\r\n            var pair = table.classRecords.get(class1).get(class2);\r\n            this.applyPositionValue(0, pair.value1);\r\n            this.applyPositionValue(1, pair.value2);\r\n            return true;\r\n        }\r\n      }\r\n\r\n      case 3: { // Cursive Attachment Positioning\r\n        let nextIndex = this.glyphIterator.peekIndex();\r\n        let nextGlyph = this.glyphs[nextIndex];\r\n        if (!nextGlyph) {\r\n          return false;\r\n        }\r\n\r\n        let curRecord = table.entryExitRecords[this.coverageIndex(table.coverage)];\r\n        if (!curRecord || !curRecord.exitAnchor) {\r\n          return false;\r\n        }\r\n\r\n        let nextRecord = table.entryExitRecords[this.coverageIndex(table.coverage, nextGlyph.id)];\r\n        if (!nextRecord || !nextRecord.entryAnchor) {\r\n          return false;\r\n        }\r\n\r\n        let entry = this.getAnchor(nextRecord.entryAnchor);\r\n        let exit = this.getAnchor(curRecord.exitAnchor);\r\n\r\n        let cur = this.positions[this.glyphIterator.index];\r\n        let next = this.positions[nextIndex];\r\n\r\n        switch (this.direction) {\r\n          case 'ltr':\r\n            cur.xAdvance = exit.x + cur.xOffset;\r\n\r\n            let d = entry.x + next.xOffset;\r\n            next.xAdvance -= d;\r\n            next.xOffset -= d;\r\n            break;\r\n\r\n          case 'rtl':\r\n            d = exit.x + cur.xOffset;\r\n            cur.xAdvance -= d;\r\n            cur.xOffset -= d;\r\n            next.xAdvance = entry.x + next.xOffset;\r\n            break;\r\n        }\r\n\r\n        if (this.glyphIterator.flags.rightToLeft) {\r\n          this.glyphIterator.cur.cursiveAttachment = nextIndex;\r\n          cur.yOffset = entry.y - exit.y;\r\n        } else {\r\n          nextGlyph.cursiveAttachment = this.glyphIterator.index;\r\n          cur.yOffset = exit.y - entry.y;\r\n        }\r\n\r\n        return true;\r\n      }\r\n\r\n      case 4: { // Mark to base positioning\r\n        let markIndex = this.coverageIndex(table.markCoverage);\r\n        if (markIndex === -1) {\r\n          return false;\r\n        }\r\n\r\n        // search backward for a base glyph\r\n        let baseGlyphIndex = this.glyphIterator.index;\r\n        while (--baseGlyphIndex >= 0 && (this.glyphs[baseGlyphIndex].isMark || this.glyphs[baseGlyphIndex].ligatureComponent > 0));\r\n\r\n        if (baseGlyphIndex < 0) {\r\n          return false;\r\n        }\r\n\r\n        let baseIndex = this.coverageIndex(table.baseCoverage, this.glyphs[baseGlyphIndex].id);\r\n        if (baseIndex === -1) {\r\n          return false;\r\n        }\r\n\r\n        let markRecord = table.markArray[markIndex];\r\n        let baseAnchor = table.baseArray[baseIndex][markRecord.class];\r\n        this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);\r\n        return true;\r\n      }\r\n\r\n      case 5: { // Mark to ligature positioning\r\n        let markIndex = this.coverageIndex(table.markCoverage);\r\n        if (markIndex === -1) {\r\n          return false;\r\n        }\r\n\r\n        // search backward for a base glyph\r\n        let baseGlyphIndex = this.glyphIterator.index;\r\n        while (--baseGlyphIndex >= 0 && this.glyphs[baseGlyphIndex].isMark);\r\n\r\n        if (baseGlyphIndex < 0) {\r\n          return false;\r\n        }\r\n\r\n        let ligIndex = this.coverageIndex(table.ligatureCoverage, this.glyphs[baseGlyphIndex].id);\r\n        if (ligIndex === -1) {\r\n          return false;\r\n        }\r\n\r\n        let ligAttach = table.ligatureArray[ligIndex];\r\n        let markGlyph = this.glyphIterator.cur;\r\n        let ligGlyph = this.glyphs[baseGlyphIndex];\r\n        let compIndex = ligGlyph.ligatureID && ligGlyph.ligatureID === markGlyph.ligatureID && (markGlyph.ligatureComponent > 0)\r\n          ? Math.min(markGlyph.ligatureComponent, ligGlyph.codePoints.length) - 1\r\n          : ligGlyph.codePoints.length - 1;\r\n\r\n        let markRecord = table.markArray[markIndex];\r\n        let baseAnchor = ligAttach[compIndex][markRecord.class];\r\n        this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);\r\n        return true;\r\n      }\r\n\r\n      case 6: { // Mark to mark positioning\r\n        let mark1Index = this.coverageIndex(table.mark1Coverage);\r\n        if (mark1Index === -1) {\r\n          return false;\r\n        }\r\n\r\n        // get the previous mark to attach to\r\n        let prevIndex = this.glyphIterator.peekIndex(-1);\r\n        let prev = this.glyphs[prevIndex];\r\n        if (!prev || !prev.isMark) {\r\n          return false;\r\n        }\r\n\r\n        let cur = this.glyphIterator.cur;\r\n\r\n        // The following logic was borrowed from Harfbuzz\r\n        let good = false;\r\n        if (cur.ligatureID === prev.ligatureID) {\r\n          if (!cur.ligatureID) { // Marks belonging to the same base\r\n            good = true;\r\n          } else if (cur.ligatureComponent === prev.ligatureComponent) { // Marks belonging to the same ligature component\r\n            good = true;\r\n          }\r\n        } else {\r\n          // If ligature ids don't match, it may be the case that one of the marks\r\n          // itself is a ligature, in which case match.\r\n          if ((cur.ligatureID && !cur.ligatureComponent) || (prev.ligatureID && !prev.ligatureComponent)) {\r\n            good = true;\r\n          }\r\n        }\r\n\r\n        if (!good) {\r\n          return false;\r\n        }\r\n\r\n        let mark2Index = this.coverageIndex(table.mark2Coverage, prev.id);\r\n        if (mark2Index === -1) {\r\n          return false;\r\n        }\r\n\r\n        let markRecord = table.mark1Array[mark1Index];\r\n        let baseAnchor = table.mark2Array[mark2Index][markRecord.class];\r\n        this.applyAnchor(markRecord, baseAnchor, prevIndex);\r\n        return true;\r\n      }\r\n\r\n      case 7: // Contextual positioning\r\n        return this.applyContext(table);\r\n\r\n      case 8: // Chaining contextual positioning\r\n        return this.applyChainingContext(table);\r\n\r\n      case 9: // Extension positioning\r\n        return this.applyLookup(table.lookupType, table.extension);\r\n\r\n      default:\r\n        throw new Error(`Unsupported GPOS table: ${lookupType}`);\r\n    }\r\n  }\r\n\r\n  applyAnchor(markRecord, baseAnchor, baseGlyphIndex) {\r\n    let baseCoords = this.getAnchor(baseAnchor);\r\n    let markCoords = this.getAnchor(markRecord.markAnchor);\r\n\r\n    let basePos = this.positions[baseGlyphIndex];\r\n    let markPos = this.positions[this.glyphIterator.index];\r\n\r\n    markPos.xOffset = baseCoords.x - markCoords.x;\r\n    markPos.yOffset = baseCoords.y - markCoords.y;\r\n    this.glyphIterator.cur.markAttachment = baseGlyphIndex;\r\n  }\r\n\r\n  getAnchor(anchor) {\r\n    // TODO: contour point, device tables\r\n    let x = anchor.xCoordinate;\r\n    let y = anchor.yCoordinate;\r\n\r\n    // Adjustments for font variations\r\n    let variationProcessor = this.font._variationProcessor;\r\n    let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;\r\n    if (variationProcessor && variationStore) {\r\n      if (anchor.xDeviceTable) {\r\n        x += variationProcessor.getDelta(variationStore, anchor.xDeviceTable.a, anchor.xDeviceTable.b);\r\n      }\r\n\r\n      if (anchor.yDeviceTable) {\r\n        y += variationProcessor.getDelta(variationStore, anchor.yDeviceTable.a, anchor.yDeviceTable.b);\r\n      }\r\n    }\r\n\r\n    return {x, y};\r\n  }\r\n\r\n  applyFeatures(userFeatures, glyphs, advances) {\r\n    super.applyFeatures(userFeatures, glyphs, advances);\r\n\r\n    for (var i = 0; i < this.glyphs.length; i++) {\r\n      this.fixCursiveAttachment(i);\r\n    }\r\n\r\n    this.fixMarkAttachment();\r\n  }\r\n\r\n  fixCursiveAttachment(i) {\r\n    let glyph = this.glyphs[i];\r\n    if (glyph.cursiveAttachment != null) {\r\n      let j = glyph.cursiveAttachment;\r\n\r\n      glyph.cursiveAttachment = null;\r\n      this.fixCursiveAttachment(j);\r\n\r\n      this.positions[i].yOffset += this.positions[j].yOffset;\r\n    }\r\n  }\r\n\r\n  fixMarkAttachment() {\r\n    for (let i = 0; i < this.glyphs.length; i++) {\r\n      let glyph = this.glyphs[i];\r\n      if (glyph.markAttachment != null) {\r\n        let j = glyph.markAttachment;\r\n\r\n        this.positions[i].xOffset += this.positions[j].xOffset;\r\n        this.positions[i].yOffset += this.positions[j].yOffset;\r\n\r\n        if (this.direction === 'ltr') {\r\n          for (let k = j; k < i; k++) {\r\n            this.positions[i].xOffset -= this.positions[k].xAdvance;\r\n            this.positions[i].yOffset -= this.positions[k].yAdvance;\r\n          }\r\n        } else {\r\n          for (let k = j + 1; k < i + 1; k++) {\r\n            this.positions[i].xOffset += this.positions[k].xAdvance;\r\n            this.positions[i].yOffset += this.positions[k].yAdvance;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import ShapingPlan from './ShapingPlan';\r\nimport * as Shapers from './shapers';\r\nimport GlyphInfo from './GlyphInfo';\r\nimport GSUBProcessor from './GSUBProcessor';\r\nimport GPOSProcessor from './GPOSProcessor';\r\n\r\nexport default class OTLayoutEngine {\r\n  constructor(font) {\r\n    this.font = font;\r\n    this.glyphInfos = null;\r\n    this.plan = null;\r\n    this.GSUBProcessor = null;\r\n    this.GPOSProcessor = null;\r\n    this.fallbackPosition = true;\r\n\r\n    if (font.GSUB) {\r\n      this.GSUBProcessor = new GSUBProcessor(font, font.GSUB);\r\n    }\r\n\r\n    if (font.GPOS) {\r\n      this.GPOSProcessor = new GPOSProcessor(font, font.GPOS);\r\n    }\r\n  }\r\n\r\n  setup(glyphRun) {\r\n    // Map glyphs to GlyphInfo objects so data can be passed between\r\n    // GSUB and GPOS without mutating the real (shared) Glyph objects.\r\n    this.glyphInfos = glyphRun.glyphs.map(glyph => new GlyphInfo(this.font, glyph.id, [...glyph.codePoints]));\r\n\r\n    // Select a script based on what is available in GSUB/GPOS.\r\n    let script = null;\r\n    if (this.GPOSProcessor) {\r\n      script = this.GPOSProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);\r\n    }\r\n\r\n    if (this.GSUBProcessor) {\r\n      script = this.GSUBProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);\r\n    }\r\n\r\n    // Choose a shaper based on the script, and setup a shaping plan.\r\n    // This determines which features to apply to which glyphs.\r\n    this.shaper = Shapers.choose(script);\r\n    this.plan = new ShapingPlan(this.font, script, glyphRun.direction);\r\n    this.shaper.plan(this.plan, this.glyphInfos, glyphRun.features);\r\n\r\n    // Assign chosen features to output glyph run\r\n    for (let key in this.plan.allFeatures) {\r\n      glyphRun.features[key] = true;\r\n    }\r\n  }\r\n\r\n  substitute(glyphRun) {\r\n    if (this.GSUBProcessor) {\r\n      this.plan.process(this.GSUBProcessor, this.glyphInfos);\r\n\r\n      // Map glyph infos back to normal Glyph objects\r\n      glyphRun.glyphs = this.glyphInfos.map(glyphInfo => this.font.getGlyph(glyphInfo.id, glyphInfo.codePoints));\r\n    }\r\n  }\r\n\r\n  position(glyphRun) {\r\n    if (this.shaper.zeroMarkWidths === 'BEFORE_GPOS') {\r\n      this.zeroMarkAdvances(glyphRun.positions);\r\n    }\r\n\r\n    if (this.GPOSProcessor) {\r\n      this.plan.process(this.GPOSProcessor, this.glyphInfos, glyphRun.positions);\r\n    }\r\n\r\n    if (this.shaper.zeroMarkWidths === 'AFTER_GPOS') {\r\n      this.zeroMarkAdvances(glyphRun.positions);\r\n    }\r\n\r\n    // Reverse the glyphs and positions if the script is right-to-left\r\n    if (glyphRun.direction === 'rtl') {\r\n      glyphRun.glyphs.reverse();\r\n      glyphRun.positions.reverse();\r\n    }\r\n\r\n    return this.GPOSProcessor && this.GPOSProcessor.features;\r\n  }\r\n\r\n  zeroMarkAdvances(positions) {\r\n    for (let i = 0; i < this.glyphInfos.length; i++) {\r\n      if (this.glyphInfos[i].isMark) {\r\n        positions[i].xAdvance = 0;\r\n        positions[i].yAdvance = 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  cleanup() {\r\n    this.glyphInfos = null;\r\n    this.plan = null;\r\n    this.shaper = null;\r\n  }\r\n\r\n  getAvailableFeatures(script, language) {\r\n    let features = [];\r\n\r\n    if (this.GSUBProcessor) {\r\n      this.GSUBProcessor.selectScript(script, language);\r\n      features.push(...Object.keys(this.GSUBProcessor.features));\r\n    }\r\n\r\n    if (this.GPOSProcessor) {\r\n      this.GPOSProcessor.selectScript(script, language);\r\n      features.push(...Object.keys(this.GPOSProcessor.features));\r\n    }\r\n\r\n    return features;\r\n  }\r\n}\r\n","import KernProcessor from './KernProcessor';\r\nimport UnicodeLayoutEngine from './UnicodeLayoutEngine';\r\nimport GlyphRun from './GlyphRun';\r\nimport GlyphPosition from './GlyphPosition';\r\nimport * as Script from './Script';\r\nimport unicode from 'unicode-properties';\r\nimport AATLayoutEngine from '../aat/AATLayoutEngine';\r\nimport OTLayoutEngine from '../opentype/OTLayoutEngine';\r\n\r\nexport default class LayoutEngine {\r\n  constructor(font) {\r\n    this.font = font;\r\n    this.unicodeLayoutEngine = null;\r\n    this.kernProcessor = null;\r\n\r\n    // Choose an advanced layout engine. We try the AAT morx table first since more\r\n    // scripts are currently supported because the shaping logic is built into the font.\r\n    if (this.font.morx) {\r\n      this.engine = new AATLayoutEngine(this.font);\r\n\r\n    } else if (this.font.GSUB || this.font.GPOS) {\r\n      this.engine = new OTLayoutEngine(this.font);\r\n    }\r\n  }\r\n\r\n  layout(string, features, script, language, direction) {\r\n    // Make the features parameter optional\r\n    if (typeof features === 'string') {\r\n      direction = language;\r\n      language = script;\r\n      script = features;\r\n      features = [];\r\n    }\r\n\r\n    // Map string to glyphs if needed\r\n    if (typeof string === 'string') {\r\n      // Attempt to detect the script from the string if not provided.\r\n      if (script == null) {\r\n        script = Script.forString(string);\r\n      }\r\n\r\n      var glyphs = this.font.glyphsForString(string);\r\n    } else {\r\n      // Attempt to detect the script from the glyph code points if not provided.\r\n      if (script == null) {\r\n        let codePoints = [];\r\n        for (let glyph of string) {\r\n          codePoints.push(...glyph.codePoints);\r\n        }\r\n\r\n        script = Script.forCodePoints(codePoints);\r\n      }\r\n\r\n      var glyphs = string;\r\n    }\r\n\r\n    let glyphRun = new GlyphRun(glyphs, features, script, language, direction);\r\n\r\n    // Return early if there are no glyphs\r\n    if (glyphs.length === 0) {\r\n      glyphRun.positions = [];\r\n      return glyphRun;\r\n    }\r\n\r\n    // Setup the advanced layout engine\r\n    if (this.engine && this.engine.setup) {\r\n      this.engine.setup(glyphRun);\r\n    }\r\n\r\n    // Substitute and position the glyphs\r\n    this.substitute(glyphRun);\r\n    this.position(glyphRun);\r\n\r\n    this.hideDefaultIgnorables(glyphRun.glyphs, glyphRun.positions);\r\n\r\n    // Let the layout engine clean up any state it might have\r\n    if (this.engine && this.engine.cleanup) {\r\n      this.engine.cleanup();\r\n    }\r\n\r\n    return glyphRun;\r\n  }\r\n\r\n  substitute(glyphRun) {\r\n    // Call the advanced layout engine to make substitutions\r\n    if (this.engine && this.engine.substitute) {\r\n      this.engine.substitute(glyphRun);\r\n    }\r\n  }\r\n\r\n  position(glyphRun) {\r\n    // Get initial glyph positions\r\n    glyphRun.positions = glyphRun.glyphs.map(glyph => new GlyphPosition(glyph.advanceWidth));\r\n    let positioned = null;\r\n\r\n    // Call the advanced layout engine. Returns the features applied.\r\n    if (this.engine && this.engine.position) {\r\n      positioned = this.engine.position(glyphRun);\r\n    }\r\n\r\n    // if there is no GPOS table, use unicode properties to position marks.\r\n    if (!positioned && (!this.engine || this.engine.fallbackPosition)) {\r\n      if (!this.unicodeLayoutEngine) {\r\n        this.unicodeLayoutEngine = new UnicodeLayoutEngine(this.font);\r\n      }\r\n\r\n      this.unicodeLayoutEngine.positionGlyphs(glyphRun.glyphs, glyphRun.positions);\r\n    }\r\n\r\n    // if kerning is not supported by GPOS, do kerning with the TrueType/AAT kern table\r\n    if ((!positioned || !positioned.kern) && glyphRun.features.kern !== false && this.font.kern) {\r\n      if (!this.kernProcessor) {\r\n        this.kernProcessor = new KernProcessor(this.font);\r\n      }\r\n\r\n      this.kernProcessor.process(glyphRun.glyphs, glyphRun.positions);\r\n      glyphRun.features.kern = true;\r\n    }\r\n  }\r\n\r\n  hideDefaultIgnorables(glyphs, positions) {\r\n    let space = this.font.glyphForCodePoint(0x20);\r\n    for (let i = 0; i < glyphs.length; i++) {\r\n      if (this.isDefaultIgnorable(glyphs[i].codePoints[0])) {\r\n        glyphs[i] = space;\r\n        positions[i].xAdvance = 0;\r\n        positions[i].yAdvance = 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  isDefaultIgnorable(ch) {\r\n    // From DerivedCoreProperties.txt in the Unicode database,\r\n    // minus U+115F, U+1160, U+3164 and U+FFA0, which is what\r\n    // Harfbuzz and Uniscribe do.\r\n    let plane = ch >> 16;\r\n    if (plane === 0) {\r\n      // BMP\r\n      switch (ch >> 8) {\r\n      \tcase 0x00: return ch === 0x00AD;\r\n      \tcase 0x03: return ch === 0x034F;\r\n      \tcase 0x06: return ch === 0x061C;\r\n      \tcase 0x17: return 0x17B4 <= ch && ch <= 0x17B5;\r\n      \tcase 0x18: return 0x180B <= ch && ch <= 0x180E;\r\n      \tcase 0x20: return (0x200B <= ch && ch <= 0x200F) || (0x202A <= ch && ch <= 0x202E) || (0x2060 <= ch && ch <= 0x206F);\r\n      \tcase 0xFE: return (0xFE00 <= ch && ch <= 0xFE0F) || ch === 0xFEFF;\r\n      \tcase 0xFF: return 0xFFF0 <= ch && ch <= 0xFFF8;\r\n      \tdefault:   return false;\r\n      }\r\n    } else {\r\n      // Other planes\r\n      switch (plane) {\r\n      \tcase 0x01: return (0x1BCA0 <= ch && ch <= 0x1BCA3) || (0x1D173 <= ch && ch <= 0x1D17A);\r\n      \tcase 0x0E: return 0xE0000 <= ch && ch <= 0xE0FFF;\r\n      \tdefault:   return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  getAvailableFeatures(script, language) {\r\n    let features = [];\r\n\r\n    if (this.engine) {\r\n      features.push(...this.engine.getAvailableFeatures(script, language));\r\n    }\r\n\r\n    if (this.font.kern && features.indexOf('kern') === -1) {\r\n      features.push('kern');\r\n    }\r\n\r\n    return features;\r\n  }\r\n\r\n  stringsForGlyph(gid) {\r\n    let result = new Set;\r\n\r\n    let codePoints = this.font._cmapProcessor.codePointsForGlyph(gid);\r\n    for (let codePoint of codePoints) {\r\n      result.add(String.fromCodePoint(codePoint));\r\n    }\r\n\r\n    if (this.engine && this.engine.stringsForGlyph) {\r\n      for (let string of this.engine.stringsForGlyph(gid)) {\r\n        result.add(string);\r\n      }\r\n    }\r\n\r\n    return Array.from(result);\r\n  }\r\n}\r\n","import BBox from './BBox';\r\n\r\nconst SVG_COMMANDS = {\r\n  moveTo: 'M',\r\n  lineTo: 'L',\r\n  quadraticCurveTo: 'Q',\r\n  bezierCurveTo: 'C',\r\n  closePath: 'Z'\r\n};\r\n\r\n/**\r\n * Path objects are returned by glyphs and represent the actual\r\n * vector outlines for each glyph in the font. Paths can be converted\r\n * to SVG path data strings, or to functions that can be applied to\r\n * render the path to a graphics context.\r\n */\r\nexport default class Path {\r\n  constructor() {\r\n    this.commands = [];\r\n    this._bbox = null;\r\n    this._cbox = null;\r\n  }\r\n\r\n  /**\r\n   * Compiles the path to a JavaScript function that can be applied with\r\n   * a graphics context in order to render the path.\r\n   * @return {string}\r\n   */\r\n  toFunction() {\r\n    return ctx => {\r\n      this.commands.forEach(c => {\r\n        return ctx[c.command].apply(ctx, c.args)\r\n      })\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Converts the path to an SVG path data string\r\n   * @return {string}\r\n   */\r\n  toSVG() {\r\n    let cmds = this.commands.map(c => {\r\n      let args = c.args.map(arg => Math.round(arg * 100) / 100);\r\n      return `${SVG_COMMANDS[c.command]}${args.join(' ')}`;\r\n    });\r\n\r\n    return cmds.join('');\r\n  }\r\n\r\n  /**\r\n   * Gets the \"control box\" of a path.\r\n   * This is like the bounding box, but it includes all points including\r\n   * control points of bezier segments and is much faster to compute than\r\n   * the real bounding box.\r\n   * @type {BBox}\r\n   */\r\n  get cbox() {\r\n    if (!this._cbox) {\r\n      let cbox = new BBox;\r\n      for (let command of this.commands) {\r\n        for (let i = 0; i < command.args.length; i += 2) {\r\n          cbox.addPoint(command.args[i], command.args[i + 1]);\r\n        }\r\n      }\r\n\r\n      this._cbox = Object.freeze(cbox);\r\n    }\r\n\r\n    return this._cbox;\r\n  }\r\n\r\n  /**\r\n   * Gets the exact bounding box of the path by evaluating curve segments.\r\n   * Slower to compute than the control box, but more accurate.\r\n   * @type {BBox}\r\n   */\r\n  get bbox() {\r\n    if (this._bbox) {\r\n      return this._bbox;\r\n    }\r\n\r\n    let bbox = new BBox;\r\n    let cx = 0, cy = 0;\r\n\r\n    let f = t => (\r\n      Math.pow(1 - t, 3) * p0[i]\r\n        + 3 * Math.pow(1 - t, 2) * t * p1[i]\r\n        + 3 * (1 - t) * Math.pow(t, 2) * p2[i]\r\n        + Math.pow(t, 3) * p3[i]\r\n    );\r\n\r\n    for (let c of this.commands) {\r\n      switch (c.command) {\r\n        case 'moveTo':\r\n        case 'lineTo':\r\n          let [x, y] = c.args;\r\n          bbox.addPoint(x, y);\r\n          cx = x;\r\n          cy = y;\r\n          break;\r\n\r\n        case 'quadraticCurveTo':\r\n        case 'bezierCurveTo':\r\n          if (c.command === 'quadraticCurveTo') {\r\n            // http://fontforge.org/bezier.html\r\n            var [qp1x, qp1y, p3x, p3y] = c.args;\r\n            var cp1x = cx + 2 / 3 * (qp1x - cx);    // CP1 = QP0 + 2/3 * (QP1-QP0)\r\n            var cp1y = cy + 2 / 3 * (qp1y - cy);\r\n            var cp2x = p3x + 2 / 3 * (qp1x - p3x);  // CP2 = QP2 + 2/3 * (QP1-QP2)\r\n            var cp2y = p3y + 2 / 3 * (qp1y - p3y);\r\n          } else {\r\n            var [cp1x, cp1y, cp2x, cp2y, p3x, p3y] = c.args;\r\n          }\r\n\r\n          // http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\r\n          bbox.addPoint(p3x, p3y);\r\n\r\n          var p0 = [cx, cy];\r\n          var p1 = [cp1x, cp1y];\r\n          var p2 = [cp2x, cp2y];\r\n          var p3 = [p3x, p3y];\r\n\r\n          for (var i = 0; i <= 1; i++) {\r\n            let b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];\r\n            let a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];\r\n            c = 3 * p1[i] - 3 * p0[i];\r\n\r\n            if (a === 0) {\r\n              if (b === 0) {\r\n                continue;\r\n              }\r\n\r\n              let t = -c / b;\r\n              if (0 < t && t < 1) {\r\n                if (i === 0) {\r\n                  bbox.addPoint(f(t), bbox.maxY);\r\n                } else if (i === 1) {\r\n                  bbox.addPoint(bbox.maxX, f(t));\r\n                }\r\n              }\r\n\r\n              continue;\r\n            }\r\n\r\n            let b2ac = Math.pow(b, 2) - 4 * c * a;\r\n            if (b2ac < 0) {\r\n              continue;\r\n            }\r\n\r\n            let t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\r\n            if (0 < t1 && t1 < 1) {\r\n              if (i === 0) {\r\n                bbox.addPoint(f(t1), bbox.maxY);\r\n              } else if (i === 1) {\r\n                bbox.addPoint(bbox.maxX, f(t1));\r\n              }\r\n            }\r\n\r\n            let t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\r\n            if (0 < t2 && t2 < 1) {\r\n              if (i === 0) {\r\n                bbox.addPoint(f(t2), bbox.maxY);\r\n              } else if (i === 1) {\r\n                bbox.addPoint(bbox.maxX, f(t2));\r\n              }\r\n            }\r\n          }\r\n\r\n          cx = p3x;\r\n          cy = p3y;\r\n          break;\r\n      }\r\n    }\r\n\r\n    return this._bbox = Object.freeze(bbox);\r\n  }\r\n\r\n  /**\r\n   * Applies a mapping function to each point in the path.\r\n   * @param {function} fn\r\n   * @return {Path}\r\n   */\r\n  mapPoints(fn) {\r\n    let path = new Path;\r\n\r\n    for (let c of this.commands) {\r\n      let args = [];\r\n      for (let i = 0; i < c.args.length; i += 2) {\r\n        let [x, y] = fn(c.args[i], c.args[i + 1]);\r\n        args.push(x, y);\r\n      }\r\n\r\n      path[c.command](...args);\r\n    }\r\n\r\n    return path;\r\n  }\r\n\r\n  /**\r\n   * Transforms the path by the given matrix.\r\n   */\r\n  transform(m0, m1, m2, m3, m4, m5) {\r\n    return this.mapPoints((x, y) => {\r\n      x = m0 * x + m2 * y + m4;\r\n      y = m1 * x + m3 * y + m5;\r\n      return [x, y];\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Translates the path by the given offset.\r\n   */\r\n  translate(x, y) {\r\n    return this.transform(1, 0, 0, 1, x, y);\r\n  }\r\n\r\n  /**\r\n   * Rotates the path by the given angle (in radians).\r\n   */\r\n  rotate(angle) {\r\n    let cos = Math.cos(angle);\r\n    let sin = Math.sin(angle);\r\n    return this.transform(cos, sin, -sin, cos, 0, 0);\r\n  }\r\n\r\n  /**\r\n   * Scales the path.\r\n   */\r\n  scale(scaleX, scaleY = scaleX) {\r\n    return this.transform(scaleX, 0, 0, scaleY, 0, 0);\r\n  }\r\n}\r\n\r\nfor (let command of ['moveTo', 'lineTo', 'quadraticCurveTo', 'bezierCurveTo', 'closePath']) {\r\n  Path.prototype[command] = function(...args) {\r\n    this._bbox = this._cbox = null;\r\n    this.commands.push({\r\n      command,\r\n      args\r\n    });\r\n\r\n    return this;\r\n  };\r\n}\r\n","export default [\r\n  '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',\r\n  'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',\r\n  'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',\r\n  'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\r\n  'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',\r\n  'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\r\n  'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',\r\n  'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',\r\n  'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',\r\n  'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',\r\n  'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',\r\n  'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',\r\n  'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',\r\n  'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',\r\n  'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',\r\n  'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',\r\n  'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',\r\n  'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',\r\n  'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',\r\n  'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',\r\n  'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',\r\n  'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',\r\n  'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',\r\n  'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',\r\n  'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'\r\n];\r\n","import { cache } from '../decorators';\r\nimport Path from './Path';\r\nimport unicode from 'unicode-properties';\r\nimport StandardNames from './StandardNames';\r\n\r\n/**\r\n * Glyph objects represent a glyph in the font. They have various properties for accessing metrics and\r\n * the actual vector path the glyph represents, and methods for rendering the glyph to a graphics context.\r\n *\r\n * You do not create glyph objects directly. They are created by various methods on the font object.\r\n * There are several subclasses of the base Glyph class internally that may be returned depending\r\n * on the font format, but they all inherit from this class.\r\n */\r\nexport default class Glyph {\r\n  constructor(id, codePoints, font) {\r\n    /**\r\n     * The glyph id in the font\r\n     * @type {number}\r\n     */\r\n    this.id = id;\r\n\r\n    /**\r\n     * An array of unicode code points that are represented by this glyph.\r\n     * There can be multiple code points in the case of ligatures and other glyphs\r\n     * that represent multiple visual characters.\r\n     * @type {number[]}\r\n     */\r\n    this.codePoints = codePoints;\r\n    this._font = font;\r\n\r\n    // TODO: get this info from GDEF if available\r\n    this.isMark = this.codePoints.length > 0 && this.codePoints.every(unicode.isMark);\r\n    this.isLigature = this.codePoints.length > 1;\r\n  }\r\n\r\n  _getPath() {\r\n    return new Path();\r\n  }\r\n\r\n  _getCBox() {\r\n    return this.path.cbox;\r\n  }\r\n\r\n  _getBBox() {\r\n    return this.path.bbox;\r\n  }\r\n\r\n  _getTableMetrics(table) {\r\n    if (this.id < table.metrics.length) {\r\n      return table.metrics.get(this.id);\r\n    }\r\n\r\n    let metric = table.metrics.get(table.metrics.length - 1);\r\n    let res = {\r\n      advance: metric ? metric.advance : 0,\r\n      bearing: table.bearings.get(this.id - table.metrics.length) || 0\r\n    };\r\n\r\n    return res;\r\n  }\r\n\r\n  _getMetrics(cbox) {\r\n    if (this._metrics) { return this._metrics; }\r\n\r\n    let {advance:advanceWidth, bearing:leftBearing} = this._getTableMetrics(this._font.hmtx);\r\n\r\n    // For vertical metrics, use vmtx if available, or fall back to global data from OS/2 or hhea\r\n    if (this._font.vmtx) {\r\n      var {advance:advanceHeight, bearing:topBearing} = this._getTableMetrics(this._font.vmtx);\r\n\r\n    } else {\r\n      let os2;\r\n      if (typeof cbox === 'undefined' || cbox === null) { ({ cbox } = this); }\r\n\r\n      if ((os2 = this._font['OS/2']) && os2.version > 0) {\r\n        var advanceHeight = Math.abs(os2.typoAscender - os2.typoDescender);\r\n        var topBearing = os2.typoAscender - cbox.maxY;\r\n\r\n      } else {\r\n        let { hhea } = this._font;\r\n        var advanceHeight = Math.abs(hhea.ascent - hhea.descent);\r\n        var topBearing = hhea.ascent - cbox.maxY;\r\n      }\r\n    }\r\n\r\n    if (this._font._variationProcessor && this._font.HVAR) {\r\n      advanceWidth += this._font._variationProcessor.getAdvanceAdjustment(this.id, this._font.HVAR);\r\n    }\r\n\r\n    return this._metrics = { advanceWidth, advanceHeight, leftBearing, topBearing };\r\n  }\r\n\r\n  /**\r\n   * The glyph’s control box.\r\n   * This is often the same as the bounding box, but is faster to compute.\r\n   * Because of the way bezier curves are defined, some of the control points\r\n   * can be outside of the bounding box. Where `bbox` takes this into account,\r\n   * `cbox` does not. Thus, cbox is less accurate, but faster to compute.\r\n   * See [here](http://www.freetype.org/freetype2/docs/glyphs/glyphs-6.html#section-2)\r\n   * for a more detailed description.\r\n   *\r\n   * @type {BBox}\r\n   */\r\n  @cache\r\n  get cbox() {\r\n    return this._getCBox();\r\n  }\r\n\r\n  /**\r\n   * The glyph’s bounding box, i.e. the rectangle that encloses the\r\n   * glyph outline as tightly as possible.\r\n   * @type {BBox}\r\n   */\r\n  @cache\r\n  get bbox() {\r\n    return this._getBBox();\r\n  }\r\n\r\n  /**\r\n   * A vector Path object representing the glyph outline.\r\n   * @type {Path}\r\n   */\r\n  @cache\r\n  get path() {\r\n    // Cache the path so we only decode it once\r\n    // Decoding is actually performed by subclasses\r\n    return this._getPath();\r\n  }\r\n\r\n  /**\r\n   * Returns a path scaled to the given font size.\r\n   * @param {number} size\r\n   * @return {Path}\r\n   */\r\n  getScaledPath(size) {\r\n    let scale = 1 / this._font.unitsPerEm * size;\r\n    return this.path.scale(scale);\r\n  }\r\n\r\n  /**\r\n   * The glyph's advance width.\r\n   * @type {number}\r\n   */\r\n  @cache\r\n  get advanceWidth() {\r\n    return this._getMetrics().advanceWidth;\r\n  }\r\n\r\n  /**\r\n   * The glyph's advance height.\r\n   * @type {number}\r\n   */\r\n  @cache\r\n  get advanceHeight() {\r\n    return this._getMetrics().advanceHeight;\r\n  }\r\n\r\n  get ligatureCaretPositions() {}\r\n\r\n  _getName() {\r\n    let { post } = this._font;\r\n    if (!post) {\r\n      return null;\r\n    }\r\n\r\n    switch (post.version) {\r\n      case 1:\r\n        return StandardNames[this.id];\r\n\r\n      case 2:\r\n        let id = post.glyphNameIndex[this.id];\r\n        if (id < StandardNames.length) {\r\n          return StandardNames[id];\r\n        }\r\n\r\n        return post.names[id - StandardNames.length];\r\n\r\n      case 2.5:\r\n        return StandardNames[this.id + post.offsets[this.id]];\r\n\r\n      case 4:\r\n        return String.fromCharCode(post.map[this.id]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The glyph's name\r\n   * @type {string}\r\n   */\r\n  @cache\r\n  get name() {\r\n    return this._getName();\r\n  }\r\n\r\n  /**\r\n   * Renders the glyph to the given graphics context, at the specified font size.\r\n   * @param {CanvasRenderingContext2d} ctx\r\n   * @param {number} size\r\n   */\r\n  render(ctx, size) {\r\n    ctx.save();\r\n\r\n    let scale = 1 / this._font.head.unitsPerEm * size;\r\n    ctx.scale(scale, scale);\r\n\r\n    let fn = this.path.toFunction();\r\n    fn(ctx);\r\n    ctx.fill();\r\n\r\n    ctx.restore();\r\n  }\r\n}\r\n","import Glyph from './Glyph';\r\nimport Path from './Path';\r\nimport BBox from './BBox';\r\nimport r from '@foliojs-fork/restructure';\r\n\r\n// The header for both simple and composite glyphs\r\nlet GlyfHeader = new r.Struct({\r\n  numberOfContours: r.int16, // if negative, this is a composite glyph\r\n  xMin:             r.int16,\r\n  yMin:             r.int16,\r\n  xMax:             r.int16,\r\n  yMax:             r.int16\r\n});\r\n\r\n// Flags for simple glyphs\r\nconst ON_CURVE        = 1 << 0;\r\nconst X_SHORT_VECTOR  = 1 << 1;\r\nconst Y_SHORT_VECTOR  = 1 << 2;\r\nconst REPEAT          = 1 << 3;\r\nconst SAME_X          = 1 << 4;\r\nconst SAME_Y          = 1 << 5;\r\n\r\n// Flags for composite glyphs\r\nconst ARG_1_AND_2_ARE_WORDS     = 1 << 0;\r\nconst ARGS_ARE_XY_VALUES        = 1 << 1;\r\nconst ROUND_XY_TO_GRID          = 1 << 2;\r\nconst WE_HAVE_A_SCALE           = 1 << 3;\r\nconst MORE_COMPONENTS           = 1 << 5;\r\nconst WE_HAVE_AN_X_AND_Y_SCALE  = 1 << 6;\r\nconst WE_HAVE_A_TWO_BY_TWO      = 1 << 7;\r\nconst WE_HAVE_INSTRUCTIONS      = 1 << 8;\r\nconst USE_MY_METRICS            = 1 << 9;\r\nconst OVERLAP_COMPOUND          = 1 << 10;\r\nconst SCALED_COMPONENT_OFFSET   = 1 << 11;\r\nconst UNSCALED_COMPONENT_OFFSET = 1 << 12;\r\n\r\n// Represents a point in a simple glyph\r\nexport class Point {\r\n  constructor(onCurve, endContour, x = 0, y = 0) {\r\n    this.onCurve = onCurve;\r\n    this.endContour = endContour;\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n\r\n  copy() {\r\n    return new Point(this.onCurve, this.endContour, this.x, this.y);\r\n  }\r\n}\r\n\r\n// Represents a component in a composite glyph\r\nclass Component {\r\n  constructor(glyphID, dx, dy) {\r\n    this.glyphID = glyphID;\r\n    this.dx = dx;\r\n    this.dy = dy;\r\n    this.pos = 0;\r\n    this.scaleX = this.scaleY = 1;\r\n    this.scale01 = this.scale10 = 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Represents a TrueType glyph.\r\n */\r\nexport default class TTFGlyph extends Glyph {\r\n  // Parses just the glyph header and returns the bounding box\r\n  _getCBox(internal) {\r\n    // We need to decode the glyph if variation processing is requested,\r\n    // so it's easier just to recompute the path's cbox after decoding.\r\n    if (this._font._variationProcessor && !internal) {\r\n      return this.path.cbox;\r\n    }\r\n\r\n    let stream = this._font._getTableStream('glyf');\r\n    stream.pos += this._font.loca.offsets[this.id];\r\n    let glyph = GlyfHeader.decode(stream);\r\n\r\n    let cbox = new BBox(glyph.xMin, glyph.yMin, glyph.xMax, glyph.yMax);\r\n    return Object.freeze(cbox);\r\n  }\r\n\r\n  // Parses a single glyph coordinate\r\n  _parseGlyphCoord(stream, prev, short, same) {\r\n    if (short) {\r\n      var val = stream.readUInt8();\r\n      if (!same) {\r\n        val = -val;\r\n      }\r\n\r\n      val += prev;\r\n    } else {\r\n      if (same) {\r\n        var val = prev;\r\n      } else {\r\n        var val = prev + stream.readInt16BE();\r\n      }\r\n    }\r\n\r\n    return val;\r\n  }\r\n\r\n  // Decodes the glyph data into points for simple glyphs,\r\n  // or components for composite glyphs\r\n  _decode() {\r\n    let glyfPos = this._font.loca.offsets[this.id];\r\n    let nextPos = this._font.loca.offsets[this.id + 1];\r\n\r\n    // Nothing to do if there is no data for this glyph\r\n    if (glyfPos === nextPos) { return null; }\r\n\r\n    let stream = this._font._getTableStream('glyf');\r\n    stream.pos += glyfPos;\r\n    let startPos = stream.pos;\r\n\r\n    let glyph = GlyfHeader.decode(stream);\r\n\r\n    if (glyph.numberOfContours > 0) {\r\n      this._decodeSimple(glyph, stream);\r\n\r\n    } else if (glyph.numberOfContours < 0) {\r\n      this._decodeComposite(glyph, stream, startPos);\r\n    }\r\n\r\n    return glyph;\r\n  }\r\n\r\n  _decodeSimple(glyph, stream) {\r\n    // this is a simple glyph\r\n    glyph.points = [];\r\n\r\n    let endPtsOfContours = new r.Array(r.uint16, glyph.numberOfContours).decode(stream);\r\n    glyph.instructions = new r.Array(r.uint8, r.uint16).decode(stream);\r\n\r\n    let flags = [];\r\n    let numCoords = endPtsOfContours[endPtsOfContours.length - 1] + 1;\r\n\r\n    while (flags.length < numCoords) {\r\n      var flag = stream.readUInt8();\r\n      flags.push(flag);\r\n\r\n      // check for repeat flag\r\n      if (flag & REPEAT) {\r\n        let count = stream.readUInt8();\r\n        for (let j = 0; j < count; j++) {\r\n          flags.push(flag);\r\n        }\r\n      }\r\n    }\r\n\r\n    for (var i = 0; i < flags.length; i++) {\r\n      var flag = flags[i];\r\n      let point = new Point(!!(flag & ON_CURVE), endPtsOfContours.indexOf(i) >= 0, 0, 0);\r\n      glyph.points.push(point);\r\n    }\r\n\r\n    let px = 0;\r\n    for (var i = 0; i < flags.length; i++) {\r\n      var flag = flags[i];\r\n      glyph.points[i].x = px = this._parseGlyphCoord(stream, px, flag & X_SHORT_VECTOR, flag & SAME_X);\r\n    }\r\n\r\n    let py = 0;\r\n    for (var i = 0; i < flags.length; i++) {\r\n      var flag = flags[i];\r\n      glyph.points[i].y = py = this._parseGlyphCoord(stream, py, flag & Y_SHORT_VECTOR, flag & SAME_Y);\r\n    }\r\n\r\n    if (this._font._variationProcessor) {\r\n      let points = glyph.points.slice();\r\n      points.push(...this._getPhantomPoints(glyph));\r\n\r\n      this._font._variationProcessor.transformPoints(this.id, points);\r\n      glyph.phantomPoints = points.slice(-4);\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  _decodeComposite(glyph, stream, offset = 0) {\r\n    // this is a composite glyph\r\n    glyph.components = [];\r\n    let haveInstructions = false;\r\n    let flags = MORE_COMPONENTS;\r\n\r\n    while (flags & MORE_COMPONENTS) {\r\n      flags = stream.readUInt16BE();\r\n      let gPos = stream.pos - offset;\r\n      let glyphID = stream.readUInt16BE();\r\n      if (!haveInstructions) {\r\n        haveInstructions = (flags & WE_HAVE_INSTRUCTIONS) !== 0;\r\n      }\r\n\r\n      if (flags & ARG_1_AND_2_ARE_WORDS) {\r\n        var dx = stream.readInt16BE();\r\n        var dy = stream.readInt16BE();\r\n      } else {\r\n        var dx = stream.readInt8();\r\n        var dy = stream.readInt8();\r\n      }\r\n\r\n      var component = new Component(glyphID, dx, dy);\r\n      component.pos = gPos;\r\n\r\n      if (flags & WE_HAVE_A_SCALE) {\r\n        // fixed number with 14 bits of fraction\r\n        component.scaleX =\r\n        component.scaleY = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\r\n\r\n      } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {\r\n        component.scaleX = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\r\n        component.scaleY = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\r\n\r\n      } else if (flags & WE_HAVE_A_TWO_BY_TWO) {\r\n        component.scaleX  = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\r\n        component.scale01 = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\r\n        component.scale10 = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\r\n        component.scaleY  = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\r\n      }\r\n\r\n      glyph.components.push(component);\r\n    }\r\n\r\n    if (this._font._variationProcessor) {\r\n      let points = [];\r\n      for (let j = 0; j < glyph.components.length; j++) {\r\n        var component = glyph.components[j];\r\n        points.push(new Point(true, true, component.dx, component.dy));\r\n      }\r\n\r\n      points.push(...this._getPhantomPoints(glyph));\r\n\r\n      this._font._variationProcessor.transformPoints(this.id, points);\r\n      glyph.phantomPoints = points.splice(-4, 4);\r\n\r\n      for (let i = 0; i < points.length; i++) {\r\n        let point = points[i];\r\n        glyph.components[i].dx = point.x;\r\n        glyph.components[i].dy = point.y;\r\n      }\r\n    }\r\n\r\n    return haveInstructions;\r\n  }\r\n\r\n  _getPhantomPoints(glyph) {\r\n    let cbox = this._getCBox(true);\r\n    if (this._metrics == null) {\r\n      this._metrics = Glyph.prototype._getMetrics.call(this, cbox);\r\n    }\r\n\r\n    let { advanceWidth, advanceHeight, leftBearing, topBearing } = this._metrics;\r\n\r\n    return [\r\n      new Point(false, true, glyph.xMin - leftBearing, 0),\r\n      new Point(false, true, glyph.xMin - leftBearing + advanceWidth, 0),\r\n      new Point(false, true, 0, glyph.yMax + topBearing),\r\n      new Point(false, true, 0, glyph.yMax + topBearing + advanceHeight)\r\n    ];\r\n  }\r\n\r\n  // Decodes font data, resolves composite glyphs, and returns an array of contours\r\n  _getContours() {\r\n    let glyph = this._decode();\r\n    if (!glyph) {\r\n      return [];\r\n    }\r\n\r\n    let points = [];\r\n\r\n    if (glyph.numberOfContours < 0) {\r\n      // resolve composite glyphs\r\n      for (let component of glyph.components) {\r\n        let contours = this._font.getGlyph(component.glyphID)._getContours();\r\n        for (let i = 0; i < contours.length; i++) {\r\n          let contour = contours[i];\r\n          for (let j = 0; j < contour.length; j++) {\r\n            let point = contour[j];\r\n            let x = point.x * component.scaleX + point.y * component.scale01 + component.dx;\r\n            let y = point.y * component.scaleY + point.x * component.scale10 + component.dy;\r\n            points.push(new Point(point.onCurve, point.endContour, x, y));\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      points = glyph.points || [];\r\n    }\r\n\r\n    // Recompute and cache metrics if we performed variation processing, and don't have an HVAR table\r\n    if (glyph.phantomPoints && !this._font.directory.tables.HVAR) {\r\n      this._metrics.advanceWidth  = glyph.phantomPoints[1].x - glyph.phantomPoints[0].x;\r\n      this._metrics.advanceHeight = glyph.phantomPoints[3].y - glyph.phantomPoints[2].y;\r\n      this._metrics.leftBearing   = glyph.xMin - glyph.phantomPoints[0].x;\r\n      this._metrics.topBearing    = glyph.phantomPoints[2].y - glyph.yMax;\r\n    }\r\n\r\n    let contours = [];\r\n    let cur = [];\r\n    for (let k = 0; k < points.length; k++) {\r\n      var point = points[k];\r\n      cur.push(point);\r\n      if (point.endContour) {\r\n        contours.push(cur);\r\n        cur = [];\r\n      }\r\n    }\r\n\r\n    return contours;\r\n  }\r\n\r\n  _getMetrics() {\r\n    if (this._metrics) {\r\n      return this._metrics;\r\n    }\r\n\r\n    let cbox = this._getCBox(true);\r\n    super._getMetrics(cbox);\r\n\r\n    if (this._font._variationProcessor && !this._font.HVAR) {\r\n      // No HVAR table, decode the glyph. This triggers recomputation of metrics.\r\n      this.path;\r\n    }\r\n\r\n    return this._metrics;\r\n  }\r\n\r\n  // Converts contours to a Path object that can be rendered\r\n  _getPath() {\r\n    let contours = this._getContours();\r\n    let path = new Path;\r\n\r\n    for (let i = 0; i < contours.length; i++) {\r\n      let contour = contours[i];\r\n      let firstPt = contour[0];\r\n      let lastPt = contour[contour.length - 1];\r\n      let start = 0;\r\n\r\n      if (firstPt.onCurve) {\r\n        // The first point will be consumed by the moveTo command, so skip in the loop\r\n        var curvePt = null;\r\n        start = 1;\r\n      } else {\r\n        if (lastPt.onCurve) {\r\n          // Start at the last point if the first point is off curve and the last point is on curve\r\n          firstPt = lastPt;\r\n        } else {\r\n          // Start at the middle if both the first and last points are off curve\r\n          firstPt = new Point(false, false, (firstPt.x + lastPt.x) / 2, (firstPt.y + lastPt.y) / 2);\r\n        }\r\n\r\n        var curvePt = firstPt;\r\n      }\r\n\r\n      path.moveTo(firstPt.x, firstPt.y);\r\n\r\n      for (let j = start; j < contour.length; j++) {\r\n        let pt = contour[j];\r\n        let prevPt = j === 0 ? firstPt : contour[j - 1];\r\n\r\n        if (prevPt.onCurve && pt.onCurve) {\r\n          path.lineTo(pt.x, pt.y);\r\n\r\n        } else if (prevPt.onCurve && !pt.onCurve) {\r\n          var curvePt = pt;\r\n\r\n        } else if (!prevPt.onCurve && !pt.onCurve) {\r\n          let midX = (prevPt.x + pt.x) / 2;\r\n          let midY = (prevPt.y + pt.y) / 2;\r\n          path.quadraticCurveTo(prevPt.x, prevPt.y, midX, midY);\r\n          var curvePt = pt;\r\n\r\n        } else if (!prevPt.onCurve && pt.onCurve) {\r\n          path.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);\r\n          var curvePt = null;\r\n\r\n        } else {\r\n          throw new Error(\"Unknown TTF path state\");\r\n        }\r\n      }\r\n\r\n      // Connect the first and last points\r\n      if (curvePt) {\r\n        path.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);\r\n      }\r\n\r\n      path.closePath();\r\n    }\r\n\r\n    return path;\r\n  }\r\n}\r\n","import Glyph from './Glyph';\r\nimport Path from './Path';\r\n\r\n/**\r\n * Represents an OpenType PostScript glyph, in the Compact Font Format.\r\n */\r\nexport default class CFFGlyph extends Glyph {\r\n  _getName() {\r\n    if (this._font.CFF2) {\r\n      return super._getName();\r\n    }\r\n\r\n    return this._font['CFF '].getGlyphName(this.id);\r\n  }\r\n\r\n  bias(s) {\r\n    if (s.length < 1240) {\r\n      return 107;\r\n    } else if (s.length < 33900) {\r\n      return 1131;\r\n    } else {\r\n      return 32768;\r\n    }\r\n  }\r\n\r\n  _getPath() {\r\n    let cff = this._font.CFF2 || this._font['CFF '];\r\n    let { stream } = cff;\r\n    let str = cff.topDict.CharStrings[this.id];\r\n    let end = str.offset + str.length;\r\n    stream.pos = str.offset;\r\n\r\n    let path = new Path;\r\n    let stack = [];\r\n    let trans = [];\r\n\r\n    let width = null;\r\n    let nStems = 0;\r\n    let x = 0, y = 0;\r\n    let usedGsubrs;\r\n    let usedSubrs;\r\n    let open = false;\r\n\r\n    this._usedGsubrs = usedGsubrs = {};\r\n    this._usedSubrs = usedSubrs = {};\r\n\r\n    let gsubrs = cff.globalSubrIndex || [];\r\n    let gsubrsBias = this.bias(gsubrs);\r\n\r\n    let privateDict = cff.privateDictForGlyph(this.id) || {};\r\n    let subrs = privateDict.Subrs || [];\r\n    let subrsBias = this.bias(subrs);\r\n\r\n    let vstore = cff.topDict.vstore && cff.topDict.vstore.itemVariationStore;\r\n    let vsindex = privateDict.vsindex;\r\n    let variationProcessor = this._font._variationProcessor;\r\n\r\n    function checkWidth() {\r\n      if (width == null) {\r\n        width = stack.shift() + privateDict.nominalWidthX;\r\n      }\r\n    }\r\n\r\n    function parseStems() {\r\n      if (stack.length % 2 !== 0) {\r\n        checkWidth();\r\n      }\r\n\r\n      nStems += stack.length >> 1;\r\n      return stack.length = 0;\r\n    }\r\n\r\n    function moveTo(x, y) {\r\n      if (open) {\r\n        path.closePath();\r\n      }\r\n\r\n      path.moveTo(x, y);\r\n      open = true;\r\n    }\r\n\r\n    let parse = function() {\r\n      while (stream.pos < end) {\r\n        let op = stream.readUInt8();\r\n        if (op < 32) {\r\n          switch (op) {\r\n            case 1:  // hstem\r\n            case 3:  // vstem\r\n            case 18: // hstemhm\r\n            case 23: // vstemhm\r\n              parseStems();\r\n              break;\r\n\r\n            case 4: // vmoveto\r\n              if (stack.length > 1) {\r\n                checkWidth();\r\n              }\r\n\r\n              y += stack.shift();\r\n              moveTo(x, y);\r\n              break;\r\n\r\n            case 5: // rlineto\r\n              while (stack.length >= 2) {\r\n                x += stack.shift();\r\n                y += stack.shift();\r\n                path.lineTo(x, y);\r\n              }\r\n              break;\r\n\r\n            case 6: // hlineto\r\n            case 7: // vlineto\r\n              let phase = op === 6;\r\n              while (stack.length >= 1) {\r\n                if (phase) {\r\n                  x += stack.shift();\r\n                } else {\r\n                  y += stack.shift();\r\n                }\r\n\r\n                path.lineTo(x, y);\r\n                phase = !phase;\r\n              }\r\n              break;\r\n\r\n            case 8: // rrcurveto\r\n              while (stack.length > 0) {\r\n                var c1x = x + stack.shift();\r\n                var c1y = y + stack.shift();\r\n                var c2x = c1x + stack.shift();\r\n                var c2y = c1y + stack.shift();\r\n                x = c2x + stack.shift();\r\n                y = c2y + stack.shift();\r\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\r\n              }\r\n              break;\r\n\r\n            case 10: // callsubr\r\n              let index = stack.pop() + subrsBias;\r\n              let subr = subrs[index];\r\n              if (subr) {\r\n                usedSubrs[index] = true;\r\n                var p = stream.pos;\r\n                var e = end;\r\n                stream.pos = subr.offset;\r\n                end = subr.offset + subr.length;\r\n                parse();\r\n                stream.pos = p;\r\n                end = e;\r\n              }\r\n              break;\r\n\r\n            case 11: // return\r\n              if (cff.version >= 2) {\r\n                break;\r\n              }\r\n              return;\r\n\r\n            case 14: // endchar\r\n              if (cff.version >= 2) {\r\n                break;\r\n              }\r\n\r\n              if (stack.length > 0) {\r\n                checkWidth();\r\n              }\r\n\r\n              if (open) {\r\n                path.closePath();\r\n                open = false;\r\n              }\r\n              break;\r\n\r\n            case 15: { // vsindex\r\n              if (cff.version < 2) {\r\n                throw new Error('vsindex operator not supported in CFF v1');\r\n              }\r\n\r\n              vsindex = stack.pop();\r\n              break;\r\n            }\r\n\r\n            case 16: { // blend\r\n              if (cff.version < 2) {\r\n                throw new Error('blend operator not supported in CFF v1');\r\n              }\r\n\r\n              if (!variationProcessor) {\r\n                throw new Error('blend operator in non-variation font');\r\n              }\r\n\r\n              let blendVector = variationProcessor.getBlendVector(vstore, vsindex);\r\n              let numBlends = stack.pop();\r\n              let numOperands = numBlends * blendVector.length;\r\n              let delta = stack.length - numOperands;\r\n              let base = delta - numBlends;\r\n\r\n              for (let i = 0; i < numBlends; i++) {\r\n                let sum = stack[base + i];\r\n                for (let j = 0; j < blendVector.length; j++) {\r\n                  sum += blendVector[j] * stack[delta++];\r\n                }\r\n\r\n                stack[base + i] = sum;\r\n              }\r\n\r\n              while (numOperands--) {\r\n                stack.pop();\r\n              }\r\n\r\n              break;\r\n            }\r\n\r\n            case 19: // hintmask\r\n            case 20: // cntrmask\r\n              parseStems();\r\n              stream.pos += (nStems + 7) >> 3;\r\n              break;\r\n\r\n            case 21: // rmoveto\r\n              if (stack.length > 2) {\r\n                checkWidth();\r\n              }\r\n\r\n              x += stack.shift();\r\n              y += stack.shift();\r\n              moveTo(x, y);\r\n              break;\r\n\r\n            case 22: // hmoveto\r\n              if (stack.length > 1) {\r\n                checkWidth();\r\n              }\r\n\r\n              x += stack.shift();\r\n              moveTo(x, y);\r\n              break;\r\n\r\n            case 24: // rcurveline\r\n              while (stack.length >= 8) {\r\n                var c1x = x + stack.shift();\r\n                var c1y = y + stack.shift();\r\n                var c2x = c1x + stack.shift();\r\n                var c2y = c1y + stack.shift();\r\n                x = c2x + stack.shift();\r\n                y = c2y + stack.shift();\r\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\r\n              }\r\n\r\n              x += stack.shift();\r\n              y += stack.shift();\r\n              path.lineTo(x, y);\r\n              break;\r\n\r\n            case 25: // rlinecurve\r\n              while (stack.length >= 8) {\r\n                x += stack.shift();\r\n                y += stack.shift();\r\n                path.lineTo(x, y);\r\n              }\r\n\r\n              var c1x = x + stack.shift();\r\n              var c1y = y + stack.shift();\r\n              var c2x = c1x + stack.shift();\r\n              var c2y = c1y + stack.shift();\r\n              x = c2x + stack.shift();\r\n              y = c2y + stack.shift();\r\n              path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\r\n              break;\r\n\r\n            case 26: // vvcurveto\r\n              if (stack.length % 2) {\r\n                x += stack.shift();\r\n              }\r\n\r\n              while (stack.length >= 4) {\r\n                c1x = x;\r\n                c1y = y + stack.shift();\r\n                c2x = c1x + stack.shift();\r\n                c2y = c1y + stack.shift();\r\n                x = c2x;\r\n                y = c2y + stack.shift();\r\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\r\n              }\r\n              break;\r\n\r\n            case 27: // hhcurveto\r\n              if (stack.length % 2) {\r\n                y += stack.shift();\r\n              }\r\n\r\n              while (stack.length >= 4) {\r\n                c1x = x + stack.shift();\r\n                c1y = y;\r\n                c2x = c1x + stack.shift();\r\n                c2y = c1y + stack.shift();\r\n                x = c2x + stack.shift();\r\n                y = c2y;\r\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\r\n              }\r\n              break;\r\n\r\n            case 28: // shortint\r\n              stack.push(stream.readInt16BE());\r\n              break;\r\n\r\n            case 29: // callgsubr\r\n              index = stack.pop() + gsubrsBias;\r\n              subr = gsubrs[index];\r\n              if (subr) {\r\n                usedGsubrs[index] = true;\r\n                var p = stream.pos;\r\n                var e = end;\r\n                stream.pos = subr.offset;\r\n                end = subr.offset + subr.length;\r\n                parse();\r\n                stream.pos = p;\r\n                end = e;\r\n              }\r\n              break;\r\n\r\n            case 30: // vhcurveto\r\n            case 31: // hvcurveto\r\n              phase = op === 31;\r\n              while (stack.length >= 4) {\r\n                if (phase) {\r\n                  c1x = x + stack.shift();\r\n                  c1y = y;\r\n                  c2x = c1x + stack.shift();\r\n                  c2y = c1y + stack.shift();\r\n                  y = c2y + stack.shift();\r\n                  x = c2x + (stack.length === 1 ? stack.shift() : 0);\r\n                } else {\r\n                  c1x = x;\r\n                  c1y = y + stack.shift();\r\n                  c2x = c1x + stack.shift();\r\n                  c2y = c1y + stack.shift();\r\n                  x = c2x + stack.shift();\r\n                  y = c2y + (stack.length === 1 ? stack.shift() : 0);\r\n                }\r\n\r\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\r\n                phase = !phase;\r\n              }\r\n              break;\r\n\r\n            case 12:\r\n              op = stream.readUInt8();\r\n              switch (op) {\r\n                case 3: // and\r\n                  let a = stack.pop();\r\n                  let b = stack.pop();\r\n                  stack.push(a && b ? 1 : 0);\r\n                  break;\r\n\r\n                case 4: // or\r\n                  a = stack.pop();\r\n                  b = stack.pop();\r\n                  stack.push(a || b ? 1 : 0);\r\n                  break;\r\n\r\n                case 5: // not\r\n                  a = stack.pop();\r\n                  stack.push(a ? 0 : 1);\r\n                  break;\r\n\r\n                case 9: // abs\r\n                  a = stack.pop();\r\n                  stack.push(Math.abs(a));\r\n                  break;\r\n\r\n                case 10: // add\r\n                  a = stack.pop();\r\n                  b = stack.pop();\r\n                  stack.push(a + b);\r\n                  break;\r\n\r\n                case 11: // sub\r\n                  a = stack.pop();\r\n                  b = stack.pop();\r\n                  stack.push(a - b);\r\n                  break;\r\n\r\n                case 12: // div\r\n                  a = stack.pop();\r\n                  b = stack.pop();\r\n                  stack.push(a / b);\r\n                  break;\r\n\r\n                case 14: // neg\r\n                  a = stack.pop();\r\n                  stack.push(-a);\r\n                  break;\r\n\r\n                case 15: // eq\r\n                  a = stack.pop();\r\n                  b = stack.pop();\r\n                  stack.push(a === b ? 1 : 0);\r\n                  break;\r\n\r\n                case 18: // drop\r\n                  stack.pop();\r\n                  break;\r\n\r\n                case 20: // put\r\n                  let val = stack.pop();\r\n                  let idx = stack.pop();\r\n                  trans[idx] = val;\r\n                  break;\r\n\r\n                case 21: // get\r\n                  idx = stack.pop();\r\n                  stack.push(trans[idx] || 0);\r\n                  break;\r\n\r\n                case 22: // ifelse\r\n                  let s1 = stack.pop();\r\n                  let s2 = stack.pop();\r\n                  let v1 = stack.pop();\r\n                  let v2 = stack.pop();\r\n                  stack.push(v1 <= v2 ? s1 : s2);\r\n                  break;\r\n\r\n                case 23: // random\r\n                  stack.push(Math.random());\r\n                  break;\r\n\r\n                case 24: // mul\r\n                  a = stack.pop();\r\n                  b = stack.pop();\r\n                  stack.push(a * b);\r\n                  break;\r\n\r\n                case 26: // sqrt\r\n                  a = stack.pop();\r\n                  stack.push(Math.sqrt(a));\r\n                  break;\r\n\r\n                case 27: // dup\r\n                  a = stack.pop();\r\n                  stack.push(a, a);\r\n                  break;\r\n\r\n                case 28: // exch\r\n                  a = stack.pop();\r\n                  b = stack.pop();\r\n                  stack.push(b, a);\r\n                  break;\r\n\r\n                case 29: // index\r\n                  idx = stack.pop();\r\n                  if (idx < 0) {\r\n                    idx = 0;\r\n                  } else if (idx > stack.length - 1) {\r\n                    idx = stack.length - 1;\r\n                  }\r\n\r\n                  stack.push(stack[idx]);\r\n                  break;\r\n\r\n                case 30: // roll\r\n                  let n = stack.pop();\r\n                  let j = stack.pop();\r\n\r\n                  if (j >= 0) {\r\n                    while (j > 0) {\r\n                      var t = stack[n - 1];\r\n                      for (let i = n - 2; i >= 0; i--) {\r\n                        stack[i + 1] = stack[i];\r\n                      }\r\n\r\n                      stack[0] = t;\r\n                      j--;\r\n                    }\r\n                  } else {\r\n                    while (j < 0) {\r\n                      var t = stack[0];\r\n                      for (let i = 0; i <= n; i++) {\r\n                        stack[i] = stack[i + 1];\r\n                      }\r\n\r\n                      stack[n - 1] = t;\r\n                      j++;\r\n                    }\r\n                  }\r\n                  break;\r\n\r\n                case 34: // hflex\r\n                  c1x = x + stack.shift();\r\n                  c1y = y;\r\n                  c2x = c1x + stack.shift();\r\n                  c2y = c1y + stack.shift();\r\n                  let c3x = c2x + stack.shift();\r\n                  let c3y = c2y;\r\n                  let c4x = c3x + stack.shift();\r\n                  let c4y = c3y;\r\n                  let c5x = c4x + stack.shift();\r\n                  let c5y = c4y;\r\n                  let c6x = c5x + stack.shift();\r\n                  let c6y = c5y;\r\n                  x = c6x;\r\n                  y = c6y;\r\n\r\n                  path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);\r\n                  path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);\r\n                  break;\r\n\r\n                case 35: // flex\r\n                  let pts = [];\r\n\r\n                  for (let i = 0; i <= 5; i++) {\r\n                    x += stack.shift();\r\n                    y += stack.shift();\r\n                    pts.push(x, y);\r\n                  }\r\n\r\n                  path.bezierCurveTo(...pts.slice(0, 6));\r\n                  path.bezierCurveTo(...pts.slice(6));\r\n                  stack.shift(); // fd\r\n                  break;\r\n\r\n                case 36: // hflex1\r\n                  c1x = x + stack.shift();\r\n                  c1y = y + stack.shift();\r\n                  c2x = c1x + stack.shift();\r\n                  c2y = c1y + stack.shift();\r\n                  c3x = c2x + stack.shift();\r\n                  c3y = c2y;\r\n                  c4x = c3x + stack.shift();\r\n                  c4y = c3y;\r\n                  c5x = c4x + stack.shift();\r\n                  c5y = c4y + stack.shift();\r\n                  c6x = c5x + stack.shift();\r\n                  c6y = c5y;\r\n                  x = c6x;\r\n                  y = c6y;\r\n\r\n                  path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);\r\n                  path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);\r\n                  break;\r\n\r\n                case 37: // flex1\r\n                  let startx = x;\r\n                  let starty = y;\r\n\r\n                  pts = [];\r\n                  for (let i = 0; i <= 4; i++) {\r\n                    x += stack.shift();\r\n                    y += stack.shift();\r\n                    pts.push(x, y);\r\n                  }\r\n\r\n                  if (Math.abs(x - startx) > Math.abs(y - starty)) { // horizontal\r\n                    x += stack.shift();\r\n                    y = starty;\r\n                  } else {\r\n                    x = startx;\r\n                    y += stack.shift();\r\n                  }\r\n\r\n                  pts.push(x, y);\r\n                  path.bezierCurveTo(...pts.slice(0, 6));\r\n                  path.bezierCurveTo(...pts.slice(6));\r\n                  break;\r\n\r\n                default:\r\n                  throw new Error(`Unknown op: 12 ${op}`);\r\n              }\r\n              break;\r\n\r\n            default:\r\n              throw new Error(`Unknown op: ${op}`);\r\n          }\r\n\r\n        } else if (op < 247) {\r\n          stack.push(op - 139);\r\n        } else if (op < 251) {\r\n          var b1 = stream.readUInt8();\r\n          stack.push((op - 247) * 256 + b1 + 108);\r\n        } else if (op < 255) {\r\n          var b1 = stream.readUInt8();\r\n          stack.push(-(op - 251) * 256 - b1 - 108);\r\n        } else {\r\n          stack.push(stream.readInt32BE() / 65536);\r\n        }\r\n      }\r\n    };\r\n\r\n    parse();\r\n\r\n    if (open) {\r\n      path.closePath();\r\n    }\r\n\r\n    return path;\r\n  }\r\n}\r\n","import TTFGlyph from './TTFGlyph';\r\nimport r from '@foliojs-fork/restructure';\r\n\r\nlet SBIXImage = new r.Struct({\r\n  originX: r.uint16,\r\n  originY: r.uint16,\r\n  type: new r.String(4),\r\n  data: new r.Buffer(t => t.parent.buflen - t._currentOffset)\r\n});\r\n\r\n/**\r\n * Represents a color (e.g. emoji) glyph in Apple's SBIX format.\r\n */\r\nexport default class SBIXGlyph extends TTFGlyph {\r\n  /**\r\n   * Returns an object representing a glyph image at the given point size.\r\n   * The object has a data property with a Buffer containing the actual image data,\r\n   * along with the image type, and origin.\r\n   *\r\n   * @param {number} size\r\n   * @return {object}\r\n   */\r\n  getImageForSize(size) {\r\n    for (let i = 0; i < this._font.sbix.imageTables.length; i++) {\r\n      var table = this._font.sbix.imageTables[i];\r\n      if (table.ppem >= size) { break; }\r\n    }\r\n\r\n    let offsets = table.imageOffsets;\r\n    let start = offsets[this.id];\r\n    let end = offsets[this.id + 1];\r\n\r\n    if (start === end) {\r\n      return null;\r\n    }\r\n\r\n    this._font.stream.pos = start;\r\n    return SBIXImage.decode(this._font.stream, {buflen: end - start});\r\n  }\r\n\r\n  render(ctx, size) {\r\n    let img = this.getImageForSize(size);\r\n    if (img != null) {\r\n      let scale = size / this._font.unitsPerEm;\r\n      ctx.image(img.data, {height: size, x: img.originX, y: (this.bbox.minY - img.originY) * scale});\r\n    }\r\n\r\n    if (this._font.sbix.flags.renderOutlines) {\r\n      super.render(ctx, size);\r\n    }\r\n  }\r\n}\r\n","import Glyph from './Glyph';\r\nimport BBox from './BBox';\r\n\r\nclass COLRLayer {\r\n  constructor(glyph, color) {\r\n    this.glyph = glyph;\r\n    this.color = color;\r\n  }\r\n}\r\n\r\n/**\r\n * Represents a color (e.g. emoji) glyph in Microsoft's COLR format.\r\n * Each glyph in this format contain a list of colored layers, each\r\n * of which  is another vector glyph.\r\n */\r\nexport default class COLRGlyph extends Glyph {\r\n  _getBBox() {\r\n    let bbox = new BBox;\r\n    for (let i = 0; i < this.layers.length; i++) {\r\n      let layer = this.layers[i];\r\n      let b = layer.glyph.bbox;\r\n      bbox.addPoint(b.minX, b.minY);\r\n      bbox.addPoint(b.maxX, b.maxY);\r\n    }\r\n\r\n    return bbox;\r\n  }\r\n\r\n  /**\r\n   * Returns an array of objects containing the glyph and color for\r\n   * each layer in the composite color glyph.\r\n   * @type {object[]}\r\n   */\r\n  get layers() {\r\n    let cpal = this._font.CPAL;\r\n    let colr = this._font.COLR;\r\n    let low = 0;\r\n    let high = colr.baseGlyphRecord.length - 1;\r\n\r\n    while (low <= high) {\r\n      let mid = (low + high) >> 1;\r\n      var rec = colr.baseGlyphRecord[mid];\r\n\r\n      if (this.id < rec.gid) {\r\n        high = mid - 1;\r\n      } else if (this.id > rec.gid) {\r\n        low = mid + 1;\r\n      } else {\r\n        var baseLayer = rec;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // if base glyph not found in COLR table,\r\n    // default to normal glyph from glyf or CFF\r\n    if (baseLayer == null) {\r\n      var g = this._font._getBaseGlyph(this.id);\r\n      var color = {\r\n        red: 0,\r\n        green: 0,\r\n        blue: 0,\r\n        alpha: 255\r\n      };\r\n\r\n      return [new COLRLayer(g, color)];\r\n    }\r\n\r\n    // otherwise, return an array of all the layers\r\n    let layers = [];\r\n    for (let i = baseLayer.firstLayerIndex; i < baseLayer.firstLayerIndex + baseLayer.numLayers; i++) {\r\n      var rec = colr.layerRecords[i];\r\n      var color = cpal.colorRecords[rec.paletteIndex];\r\n      var g = this._font._getBaseGlyph(rec.gid);\r\n      layers.push(new COLRLayer(g, color));\r\n    }\r\n\r\n    return layers;\r\n  }\r\n\r\n  render(ctx, size) {\r\n    for (let {glyph, color} of this.layers) {\r\n      ctx.fillColor([color.red, color.green, color.blue], color.alpha / 255 * 100);\r\n      glyph.render(ctx, size);\r\n    }\r\n\r\n    return;\r\n  }\r\n}\r\n","const TUPLES_SHARE_POINT_NUMBERS = 0x8000;\r\nconst TUPLE_COUNT_MASK           = 0x0fff;\r\nconst EMBEDDED_TUPLE_COORD       = 0x8000;\r\nconst INTERMEDIATE_TUPLE         = 0x4000;\r\nconst PRIVATE_POINT_NUMBERS      = 0x2000;\r\nconst TUPLE_INDEX_MASK           = 0x0fff;\r\nconst POINTS_ARE_WORDS           = 0x80;\r\nconst POINT_RUN_COUNT_MASK       = 0x7f;\r\nconst DELTAS_ARE_ZERO            = 0x80;\r\nconst DELTAS_ARE_WORDS           = 0x40;\r\nconst DELTA_RUN_COUNT_MASK       = 0x3f;\r\n\r\n/**\r\n * This class is transforms TrueType glyphs according to the data from\r\n * the Apple Advanced Typography variation tables (fvar, gvar, and avar).\r\n * These tables allow infinite adjustments to glyph weight, width, slant,\r\n * and optical size without the designer needing to specify every exact style.\r\n *\r\n * Apple's documentation for these tables is not great, so thanks to the\r\n * Freetype project for figuring much of this out.\r\n *\r\n * @private\r\n */\r\nexport default class GlyphVariationProcessor {\r\n  constructor(font, coords) {\r\n    this.font = font;\r\n    this.normalizedCoords = this.normalizeCoords(coords);\r\n    this.blendVectors = new Map;\r\n  }\r\n\r\n  normalizeCoords(coords) {\r\n    // the default mapping is linear along each axis, in two segments:\r\n    // from the minValue to defaultValue, and from defaultValue to maxValue.\r\n    let normalized = [];\r\n    for (var i = 0; i < this.font.fvar.axis.length; i++) {\r\n      let axis = this.font.fvar.axis[i];\r\n      if (coords[i] < axis.defaultValue) {\r\n        normalized.push((coords[i] - axis.defaultValue + Number.EPSILON) / (axis.defaultValue - axis.minValue + Number.EPSILON));\r\n      } else {\r\n        normalized.push((coords[i] - axis.defaultValue + Number.EPSILON) / (axis.maxValue - axis.defaultValue + Number.EPSILON));\r\n      }\r\n    }\r\n\r\n    // if there is an avar table, the normalized value is calculated\r\n    // by interpolating between the two nearest mapped values.\r\n    if (this.font.avar) {\r\n      for (var i = 0; i < this.font.avar.segment.length; i++) {\r\n        let segment = this.font.avar.segment[i];\r\n        for (let j = 0; j < segment.correspondence.length; j++) {\r\n          let pair = segment.correspondence[j];\r\n          if (j >= 1 && normalized[i] < pair.fromCoord) {\r\n            let prev = segment.correspondence[j - 1];\r\n            normalized[i] = ((normalized[i] - prev.fromCoord) * (pair.toCoord - prev.toCoord) + Number.EPSILON) /\r\n              (pair.fromCoord - prev.fromCoord + Number.EPSILON) +\r\n              prev.toCoord;\r\n\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return normalized;\r\n  }\r\n\r\n  transformPoints(gid, glyphPoints) {\r\n    if (!this.font.fvar || !this.font.gvar) { return; }\r\n\r\n    let { gvar } = this.font;\r\n    if (gid >= gvar.glyphCount) { return; }\r\n\r\n    let offset = gvar.offsets[gid];\r\n    if (offset === gvar.offsets[gid + 1]) { return; }\r\n\r\n    // Read the gvar data for this glyph\r\n    let { stream } = this.font;\r\n    stream.pos = offset;\r\n    if (stream.pos >= stream.length) {\r\n      return;\r\n    }\r\n\r\n    let tupleCount = stream.readUInt16BE();\r\n    let offsetToData = offset + stream.readUInt16BE();\r\n\r\n    if (tupleCount & TUPLES_SHARE_POINT_NUMBERS) {\r\n      var here = stream.pos;\r\n      stream.pos = offsetToData;\r\n      var sharedPoints = this.decodePoints();\r\n      offsetToData = stream.pos;\r\n      stream.pos = here;\r\n    }\r\n\r\n    let origPoints = glyphPoints.map(pt => pt.copy());\r\n\r\n    tupleCount &= TUPLE_COUNT_MASK;\r\n    for (let i = 0; i < tupleCount; i++) {\r\n      let tupleDataSize = stream.readUInt16BE();\r\n      let tupleIndex = stream.readUInt16BE();\r\n\r\n      if (tupleIndex & EMBEDDED_TUPLE_COORD) {\r\n        var tupleCoords = [];\r\n        for (let a = 0; a < gvar.axisCount; a++) {\r\n          tupleCoords.push(stream.readInt16BE() / 16384);\r\n        }\r\n\r\n      } else {\r\n        if ((tupleIndex & TUPLE_INDEX_MASK) >= gvar.globalCoordCount) {\r\n          throw new Error('Invalid gvar table');\r\n        }\r\n\r\n        var tupleCoords = gvar.globalCoords[tupleIndex & TUPLE_INDEX_MASK];\r\n      }\r\n\r\n      if (tupleIndex & INTERMEDIATE_TUPLE) {\r\n        var startCoords = [];\r\n        for (let a = 0; a < gvar.axisCount; a++) {\r\n          startCoords.push(stream.readInt16BE() / 16384);\r\n        }\r\n\r\n        var endCoords = [];\r\n        for (let a = 0; a < gvar.axisCount; a++) {\r\n          endCoords.push(stream.readInt16BE() / 16384);\r\n        }\r\n      }\r\n\r\n      // Get the factor at which to apply this tuple\r\n      let factor = this.tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords);\r\n      if (factor === 0) {\r\n        offsetToData += tupleDataSize;\r\n        continue;\r\n      }\r\n\r\n      var here = stream.pos;\r\n      stream.pos = offsetToData;\r\n\r\n      if (tupleIndex & PRIVATE_POINT_NUMBERS) {\r\n        var points = this.decodePoints();\r\n      } else {\r\n        var points = sharedPoints;\r\n      }\r\n\r\n      // points.length = 0 means there are deltas for all points\r\n      let nPoints = points.length === 0 ? glyphPoints.length : points.length;\r\n      let xDeltas = this.decodeDeltas(nPoints);\r\n      let yDeltas = this.decodeDeltas(nPoints);\r\n\r\n      if (points.length === 0) { // all points\r\n        for (let i = 0; i < glyphPoints.length; i++) {\r\n          var point = glyphPoints[i];\r\n          point.x += Math.round(xDeltas[i] * factor);\r\n          point.y += Math.round(yDeltas[i] * factor);\r\n        }\r\n      } else {\r\n        let outPoints = origPoints.map(pt => pt.copy());\r\n        let hasDelta = glyphPoints.map(() => false);\r\n\r\n        for (let i = 0; i < points.length; i++) {\r\n          let idx = points[i];\r\n          if (idx < glyphPoints.length) {\r\n            let point = outPoints[idx];\r\n            hasDelta[idx] = true;\r\n\r\n            point.x += Math.round(xDeltas[i] * factor);\r\n            point.y += Math.round(yDeltas[i] * factor);\r\n          }\r\n        }\r\n\r\n        this.interpolateMissingDeltas(outPoints, origPoints, hasDelta);\r\n\r\n        for (let i = 0; i < glyphPoints.length; i++) {\r\n          let deltaX = outPoints[i].x - origPoints[i].x;\r\n          let deltaY = outPoints[i].y - origPoints[i].y;\r\n\r\n          glyphPoints[i].x += deltaX;\r\n          glyphPoints[i].y += deltaY;\r\n        }\r\n      }\r\n\r\n      offsetToData += tupleDataSize;\r\n      stream.pos = here;\r\n    }\r\n  }\r\n\r\n  decodePoints() {\r\n    let stream = this.font.stream;\r\n    let count = stream.readUInt8();\r\n\r\n    if (count & POINTS_ARE_WORDS) {\r\n      count = (count & POINT_RUN_COUNT_MASK) << 8 | stream.readUInt8();\r\n    }\r\n\r\n    let points = new Uint16Array(count);\r\n    let i = 0;\r\n    let point = 0;\r\n    while (i < count) {\r\n      let run = stream.readUInt8();\r\n      let runCount = (run & POINT_RUN_COUNT_MASK) + 1;\r\n      let fn = run & POINTS_ARE_WORDS ? stream.readUInt16 : stream.readUInt8;\r\n\r\n      for (let j = 0; j < runCount && i < count; j++) {\r\n        point += fn.call(stream);\r\n        points[i++] = point;\r\n      }\r\n    }\r\n\r\n    return points;\r\n  }\r\n\r\n  decodeDeltas(count) {\r\n    let stream = this.font.stream;\r\n    let i = 0;\r\n    let deltas = new Int16Array(count);\r\n\r\n    while (i < count) {\r\n      let run = stream.readUInt8();\r\n      let runCount = (run & DELTA_RUN_COUNT_MASK) + 1;\r\n\r\n      if (run & DELTAS_ARE_ZERO) {\r\n        i += runCount;\r\n\r\n      } else {\r\n        let fn = run & DELTAS_ARE_WORDS ? stream.readInt16BE : stream.readInt8;\r\n        for (let j = 0; j < runCount && i < count; j++) {\r\n          deltas[i++] = fn.call(stream);\r\n        }\r\n      }\r\n    }\r\n\r\n    return deltas;\r\n  }\r\n\r\n  tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords) {\r\n    let normalized = this.normalizedCoords;\r\n    let { gvar } = this.font;\r\n    let factor = 1;\r\n\r\n    for (let i = 0; i < gvar.axisCount; i++) {\r\n      if (tupleCoords[i] === 0) {\r\n        continue;\r\n      }\r\n\r\n      if (normalized[i] === 0) {\r\n        return 0;\r\n      }\r\n\r\n      if ((tupleIndex & INTERMEDIATE_TUPLE) === 0) {\r\n        if ((normalized[i] < Math.min(0, tupleCoords[i])) ||\r\n            (normalized[i] > Math.max(0, tupleCoords[i]))) {\r\n          return 0;\r\n        }\r\n\r\n        factor = (factor * normalized[i] + Number.EPSILON) / (tupleCoords[i] + Number.EPSILON);\r\n      } else {\r\n        if ((normalized[i] < startCoords[i]) ||\r\n            (normalized[i] > endCoords[i])) {\r\n          return 0;\r\n\r\n        } else if (normalized[i] < tupleCoords[i]) {\r\n          factor = factor * (normalized[i] - startCoords[i] + Number.EPSILON) / (tupleCoords[i] - startCoords[i] + Number.EPSILON);\r\n\r\n        } else {\r\n          factor = factor * (endCoords[i] - normalized[i] + Number.EPSILON) / (endCoords[i] - tupleCoords[i] + Number.EPSILON);\r\n        }\r\n      }\r\n    }\r\n\r\n    return factor;\r\n  }\r\n\r\n  // Interpolates points without delta values.\r\n  // Needed for the Ø and Q glyphs in Skia.\r\n  // Algorithm from Freetype.\r\n  interpolateMissingDeltas(points, inPoints, hasDelta) {\r\n    if (points.length === 0) {\r\n      return;\r\n    }\r\n\r\n    let point = 0;\r\n    while (point < points.length) {\r\n      let firstPoint = point;\r\n\r\n      // find the end point of the contour\r\n      let endPoint = point;\r\n      let pt = points[endPoint];\r\n      while (!pt.endContour) {\r\n        pt = points[++endPoint];\r\n      }\r\n\r\n      // find the first point that has a delta\r\n      while (point <= endPoint && !hasDelta[point]) {\r\n        point++;\r\n      }\r\n\r\n      if (point > endPoint) {\r\n        continue;\r\n      }\r\n\r\n      let firstDelta = point;\r\n      let curDelta = point;\r\n      point++;\r\n\r\n      while (point <= endPoint) {\r\n        // find the next point with a delta, and interpolate intermediate points\r\n        if (hasDelta[point]) {\r\n          this.deltaInterpolate(curDelta + 1, point - 1, curDelta, point, inPoints, points);\r\n          curDelta = point;\r\n        }\r\n\r\n        point++;\r\n      }\r\n\r\n      // shift contour if we only have a single delta\r\n      if (curDelta === firstDelta) {\r\n        this.deltaShift(firstPoint, endPoint, curDelta, inPoints, points);\r\n      } else {\r\n        // otherwise, handle the remaining points at the end and beginning of the contour\r\n        this.deltaInterpolate(curDelta + 1, endPoint, curDelta, firstDelta, inPoints, points);\r\n\r\n        if (firstDelta > 0) {\r\n          this.deltaInterpolate(firstPoint, firstDelta - 1, curDelta, firstDelta, inPoints, points);\r\n        }\r\n      }\r\n\r\n      point = endPoint + 1;\r\n    }\r\n  }\r\n\r\n  deltaInterpolate(p1, p2, ref1, ref2, inPoints, outPoints) {\r\n    if (p1 > p2) {\r\n      return;\r\n    }\r\n\r\n    let iterable = ['x', 'y'];\r\n    for (let i = 0; i < iterable.length; i++) {\r\n      let k = iterable[i];\r\n      if (inPoints[ref1][k] > inPoints[ref2][k]) {\r\n        var p = ref1;\r\n        ref1 = ref2;\r\n        ref2 = p;\r\n      }\r\n\r\n      let in1 = inPoints[ref1][k];\r\n      let in2 = inPoints[ref2][k];\r\n      let out1 = outPoints[ref1][k];\r\n      let out2 = outPoints[ref2][k];\r\n\r\n      // If the reference points have the same coordinate but different\r\n      // delta, inferred delta is zero.  Otherwise interpolate.\r\n      if (in1 !== in2 || out1 === out2) {\r\n        let scale = in1 === in2 ? 0 : (out2 - out1) / (in2 - in1);\r\n\r\n        for (let p = p1; p <= p2; p++) {\r\n          let out = inPoints[p][k];\r\n\r\n          if (out <= in1) {\r\n            out += out1 - in1;\r\n          } else if (out >= in2) {\r\n            out += out2 - in2;\r\n          } else {\r\n            out = out1 + (out - in1) * scale;\r\n          }\r\n\r\n          outPoints[p][k] = out;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  deltaShift(p1, p2, ref, inPoints, outPoints) {\r\n    let deltaX = outPoints[ref].x - inPoints[ref].x;\r\n    let deltaY = outPoints[ref].y - inPoints[ref].y;\r\n\r\n    if (deltaX === 0 && deltaY === 0) {\r\n      return;\r\n    }\r\n\r\n    for (let p = p1; p <= p2; p++) {\r\n      if (p !== ref) {\r\n        outPoints[p].x += deltaX;\r\n        outPoints[p].y += deltaY;\r\n      }\r\n    }\r\n  }\r\n\r\n  getAdvanceAdjustment(gid, table) {\r\n    let outerIndex, innerIndex;\r\n\r\n    if (table.advanceWidthMapping) {\r\n      let idx = gid;\r\n      if (idx >= table.advanceWidthMapping.mapCount) {\r\n        idx = table.advanceWidthMapping.mapCount - 1;\r\n      }\r\n\r\n      let entryFormat = table.advanceWidthMapping.entryFormat;\r\n      ({outerIndex, innerIndex} = table.advanceWidthMapping.mapData[idx]);\r\n    } else {\r\n      outerIndex = 0;\r\n      innerIndex = gid;\r\n    }\r\n\r\n    return this.getDelta(table.itemVariationStore, outerIndex, innerIndex);\r\n  }\r\n\r\n  // See pseudo code from `Font Variations Overview'\r\n  // in the OpenType specification.\r\n  getDelta(itemStore, outerIndex, innerIndex) {\r\n    if (outerIndex >= itemStore.itemVariationData.length) {\r\n      return 0;\r\n    }\r\n\r\n    let varData = itemStore.itemVariationData[outerIndex];\r\n    if (innerIndex >= varData.deltaSets.length) {\r\n      return 0;\r\n    }\r\n\r\n    let deltaSet = varData.deltaSets[innerIndex];\r\n    let blendVector = this.getBlendVector(itemStore, outerIndex);\r\n    let netAdjustment = 0;\r\n\r\n    for (let master = 0; master < varData.regionIndexCount; master++) {\r\n      netAdjustment += deltaSet.deltas[master] * blendVector[master];\r\n    }\r\n\r\n    return netAdjustment;\r\n  }\r\n\r\n  getBlendVector(itemStore, outerIndex) {\r\n    let varData = itemStore.itemVariationData[outerIndex];\r\n    if (this.blendVectors.has(varData)) {\r\n      return this.blendVectors.get(varData);\r\n    }\r\n\r\n    let normalizedCoords = this.normalizedCoords;\r\n    let blendVector = [];\r\n\r\n    // outer loop steps through master designs to be blended\r\n    for (let master = 0; master < varData.regionIndexCount; master++) {\r\n      let scalar = 1;\r\n      let regionIndex = varData.regionIndexes[master];\r\n      let axes = itemStore.variationRegionList.variationRegions[regionIndex];\r\n\r\n      // inner loop steps through axes in this region\r\n      for (let j = 0; j < axes.length; j++) {\r\n        let axis = axes[j];\r\n        let axisScalar;\r\n\r\n        // compute the scalar contribution of this axis\r\n        // ignore invalid ranges\r\n        if (axis.startCoord > axis.peakCoord || axis.peakCoord > axis.endCoord) {\r\n          axisScalar = 1;\r\n\r\n        } else if (axis.startCoord < 0 && axis.endCoord > 0 && axis.peakCoord !== 0) {\r\n          axisScalar = 1;\r\n\r\n        // peak of 0 means ignore this axis\r\n        } else if (axis.peakCoord === 0) {\r\n          axisScalar = 1;\r\n\r\n        // ignore this region if coords are out of range\r\n        } else if (normalizedCoords[j] < axis.startCoord || normalizedCoords[j] > axis.endCoord) {\r\n          axisScalar = 0;\r\n\r\n        // calculate a proportional factor\r\n        } else {\r\n          if (normalizedCoords[j] === axis.peakCoord) {\r\n            axisScalar = 1;\r\n          } else if (normalizedCoords[j] < axis.peakCoord) {\r\n            axisScalar = (normalizedCoords[j] - axis.startCoord + Number.EPSILON) /\r\n              (axis.peakCoord - axis.startCoord + Number.EPSILON);\r\n          } else {\r\n            axisScalar = (axis.endCoord - normalizedCoords[j] + Number.EPSILON) /\r\n              (axis.endCoord - axis.peakCoord + Number.EPSILON);\r\n          }\r\n        }\r\n\r\n        // take product of all the axis scalars\r\n        scalar *= axisScalar;\r\n      }\r\n\r\n      blendVector[master] = scalar;\r\n    }\r\n\r\n    this.blendVectors.set(varData, blendVector);\r\n    return blendVector;\r\n  }\r\n}\r\n","import r from '@foliojs-fork/restructure';\r\n\r\nconst resolved = Promise.resolve();\r\n\r\nexport default class Subset {\r\n  constructor(font) {\r\n    this.font = font;\r\n    this.glyphs = [];\r\n    this.mapping = {};\r\n\r\n    // always include the missing glyph\r\n    this.includeGlyph(0);\r\n  }\r\n\r\n  includeGlyph(glyph) {\r\n    if (typeof glyph === 'object') {\r\n      glyph = glyph.id;\r\n    }\r\n\r\n    if (this.mapping[glyph] == null) {\r\n      this.glyphs.push(glyph);\r\n      this.mapping[glyph] = this.glyphs.length - 1;\r\n    }\r\n\r\n    return this.mapping[glyph];\r\n  }\r\n\r\n  encodeStream() {\r\n    let s = new r.EncodeStream();\r\n\r\n    resolved.then(() => {\r\n      this.encode(s);\r\n      return s.end();\r\n    });\r\n\r\n    return s;\r\n  }\r\n}\r\n","import r from '@foliojs-fork/restructure';\r\n\r\n// Flags for simple glyphs\r\nconst ON_CURVE        = 1 << 0;\r\nconst 