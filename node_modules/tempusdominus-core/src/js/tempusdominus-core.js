import jQuery from 'jquery';
import moment from 'moment';

// ReSharper disable once InconsistentNaming
const DateTimePicker = (($, moment) => {
    function escapeRegExp(text) {
        return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    }

    function isValidDate(date) {
        return Object.prototype.toString.call(date) === '[object Date]' && !isNaN(date.getTime());
    }

    function isValidDateTimeStr(str) {
        return isValidDate(new Date(str));
    }

    // ReSharper disable InconsistentNaming
    const trim = str => str.replace(/(^\s+)|(\s+$)/g, ''),
        NAME = 'datetimepicker',
        DATA_KEY = `${NAME}`,
        EVENT_KEY = `.${DATA_KEY}`,
        DATA_API_KEY = '.data-api',
        Selector = {
            DATA_TOGGLE: `[data-toggle="${DATA_KEY}"]`
        },
        ClassName = {
            INPUT: `${NAME}-input`
        },
        Event = {
            CHANGE: `change${EVENT_KEY}`,
            BLUR: `blur${EVENT_KEY}`,
            KEYUP: `keyup${EVENT_KEY}`,
            KEYDOWN: `keydown${EVENT_KEY}`,
            FOCUS: `focus${EVENT_KEY}`,
            CLICK_DATA_API: `click${EVENT_KEY}${DATA_API_KEY}`,
            //emitted
            UPDATE: `update${EVENT_KEY}`,
            ERROR: `error${EVENT_KEY}`,
            HIDE: `hide${EVENT_KEY}`,
            SHOW: `show${EVENT_KEY}`
        },
        DatePickerModes = [{
            CLASS_NAME: 'days',
            NAV_FUNCTION: 'M',
            NAV_STEP: 1
        }, {
            CLASS_NAME: 'months',
            NAV_FUNCTION: 'y',
            NAV_STEP: 1
        }, {
            CLASS_NAME: 'years',
            NAV_FUNCTION: 'y',
            NAV_STEP: 10
        }, {
            CLASS_NAME: 'decades',
            NAV_FUNCTION: 'y',
            NAV_STEP: 100
        }],
        KeyMap = {
            'up': 38,
            38: 'up',
            'down': 40,
            40: 'down',
            'left': 37,
            37: 'left',
            'right': 39,
            39: 'right',
            'tab': 9,
            9: 'tab',
            'escape': 27,
            27: 'escape',
            'enter': 13,
            13: 'enter',
            'pageUp': 33,
            33: 'pageUp',
            'pageDown': 34,
            34: 'pageDown',
            'shift': 16,
            16: 'shift',
            'control': 17,
            17: 'control',
            'space': 32,
            32: 'space',
            't': 84,
            84: 't',
            'delete': 46,
            46: 'delete'
        },
        ViewModes = ['times', 'days', 'months', 'years', 'decades'],
        keyState = {},
        keyPressHandled = {},
        optionsSortMap = {
            timeZone: -39,
            format: -38,
            dayViewHeaderFormat: -37,
            extraFormats: -36,
            stepping: -35,
            minDate: -34,
            maxDate: -33,
            useCurrent: -32,
            collapse: -31,
            locale: -30,
            defaultDate: -29,
            disabledDates: -28,
            enabledDates: -27,
            icons: -26,
            tooltips: -25,
            useStrict: -24,
            sideBySide: -23,
            daysOfWeekDisabled: -22,
            calendarWeeks: -21,
            viewMode: -20,
            toolbarPlacement: -19,
            buttons: -18,
            widgetPositioning: -17,
            widgetParent: -16,
            ignoreReadonly: -15,
            keepOpen: -14,
            focusOnShow: -13,
            inline: -12,
            keepInvalid: -11,
            keyBinds: -10,
            debug: -9,
            allowInputToggle: -8,
            disabledTimeIntervals: -7,
            disabledHours: -6,
            enabledHours: -5,
            viewDate: -4,
            allowMultidate: -3,
            multidateSeparator: -2,
            updateOnlyThroughDateOption: -1,
            date: 1
        },
        defaultFeatherIcons = {
            time: 'clock',
            date: 'calendar',
            up: 'arrow-up',
            down: 'arrow-down',
            previous: 'arrow-left',
            next: 'arrow-right',
            today: 'arrow-down-circle',
            clear: 'trash-2',
            close: 'x'
        };

    function optionsSortFn(optionKeyA, optionKeyB) {
        if (optionsSortMap[optionKeyA] && optionsSortMap[optionKeyB]) {
            if (optionsSortMap[optionKeyA] < 0 && optionsSortMap[optionKeyB] < 0) {
                return Math.abs(optionsSortMap[optionKeyB]) - Math.abs(optionsSortMap[optionKeyA]);
            }
            else if (optionsSortMap[optionKeyA] < 0) {
                return -1;
            }
            else if (optionsSortMap[optionKeyB] < 0) {
                return 1;
            }
            return optionsSortMap[optionKeyA] - optionsSortMap[optionKeyB];
        }
        else if (optionsSortMap[optionKeyA]) {
            return optionsSortMap[optionKeyA];
        }
        else if (optionsSortMap[optionKeyB]) {
            return optionsSortMap[optionKeyB];
        }
        return 0;
    }

    let Default = {
        timeZone: '',
        format: false,
        dayViewHeaderFormat: 'MMMM YYYY',
        extraFormats: false,
        stepping: 1,
        minDate: false,
        maxDate: false,
        useCurrent: true,
        collapse: true,
        locale: moment.locale(),
        defaultDate: false,
        disabledDates: false,
        enabledDates: false,
        icons: {
            type: 'class',
            time: 'fa fa-clock-o',
            date: 'fa fa-calendar',
            up: 'fa fa-arrow-up',
            down: 'fa fa-arrow-down',
            previous: 'fa fa-chevron-left',
            next: 'fa fa-chevron-right',
            today: 'fa fa-calendar-check-o',
            clear: 'fa fa-trash',
            close: 'fa fa-times'
        },
        tooltips: {
            today: 'Go to today',
            clear: 'Clear selection',
            close: 'Close the picker',
            selectMonth: 'Select Month',
            prevMonth: 'Previous Month',
            nextMonth: 'Next Month',
            selectYear: 'Select Year',
            prevYear: 'Previous Year',
            nextYear: 'Next Year',
            selectDecade: 'Select Decade',
            prevDecade: 'Previous Decade',
            nextDecade: 'Next Decade',
            prevCentury: 'Previous Century',
            nextCentury: 'Next Century',
            pickHour: 'Pick Hour',
            incrementHour: 'Increment Hour',
            decrementHour: 'Decrement Hour',
            pickMinute: 'Pick Minute',
            incrementMinute: 'Increment Minute',
            decrementMinute: 'Decrement Minute',
            pickSecond: 'Pick Second',
            incrementSecond: 'Increment Second',
            decrementSecond: 'Decrement Second',
            togglePeriod: 'Toggle Period',
            selectTime: 'Select Time',
            selectDate: 'Select Date'
        },
        useStrict: false,
        sideBySide: false,
        daysOfWeekDisabled: false,
        calendarWeeks: false,
        viewMode: 'days',
        toolbarPlacement: 'default',
        buttons: {
            showToday: false,
            showClear: false,
            showClose: false
        },
        widgetPositioning: {
            horizontal: 'auto',
            vertical: 'auto'
        },
        widgetParent: null,
        readonly: false,
        ignoreReadonly: false,
        keepOpen: false,
        focusOnShow: true,
        inline: false,
        keepInvalid: false,
        keyBinds: {
            up: function () {
                if (!this.widget) {
                    return false;
                }
                const d = this._dates[0] || this.getMoment();
                if (this.widget.find('.datepicker').is(':visible')) {
                    this.date(d.clone().subtract(7, 'd'));
                } else {
                    this.date(d.clone().add(this.stepping(), 'm'));
                }
                return true;
            },
            down: function () {
                if (!this.widget) {
                    this.show();
                    return false;
                }
                const d = this._dates[0] || this.getMoment();
                if (this.widget.find('.datepicker').is(':visible')) {
                    this.date(d.clone().add(7, 'd'));
                } else {
                    this.date(d.clone().subtract(this.stepping(), 'm'));
                }
                return true;
            },
            'control up': function () {
                if (!this.widget) {
                    return false;
                }
                const d = this._dates[0] || this.getMoment();
                if (this.widget.find('.datepicker').is(':visible')) {
                    this.date(d.clone().subtract(1, 'y'));
                } else {
                    this.date(d.clone().add(1, 'h'));
                }
                return true;
            },
            'control down': function () {
                if (!this.widget) {
                    return false;
                }
                const d = this._dates[0] || this.getMoment();
                if (this.widget.find('.datepicker').is(':visible')) {
                    this.date(d.clone().add(1, 'y'));
                } else {
                    this.date(d.clone().subtract(1, 'h'));
                }
                return true;
            },
            left: function () {
                if (!this.widget) {
                    return false;
                }
                const d = this._dates[0] || this.getMoment();
                if (this.widget.find('.datepicker').is(':visible')) {
                    this.date(d.clone().subtract(1, 'd'));
                }
                return true;
            },
            right: function () {
                if (!this.widget) {
                    return false;
                }
                const d = this._dates[0] || this.getMoment();
                if (this.widget.find('.datepicker').is(':visible')) {
                    this.date(d.clone().add(1, 'd'));
                }
                return true;
            },
            pageUp: function () {
                if (!this.widget) {
                    return false;
                }
                const d = this._dates[0] || this.getMoment();
                if (this.widget.find('.datepicker').is(':visible')) {
                    this.date(d.clone().subtract(1, 'M'));
                }
                return true;
            },
            pageDown: function () {
                if (!this.widget) {
                    return false;
                }
                const d = this._dates[0] || this.getMoment();
                if (this.widget.find('.datepicker').is(':visible')) {
                    this.date(d.clone().add(1, 'M'));
                }
                return true;
            },
            enter: function () {
                if (!this.widget) {
                    return false;
                }
                this.hide();
                return true;
            },
            escape: function () {
                if (!this.widget) {
                    return false;
                }
                this.hide();
                return true;
            },
            'control space': function () {
                if (!this.widget) {
                    return false;
                }
                if (this.widget.find('.timepicker').is(':visible')) {
                    this.widget.find('.btn[data-action="togglePeriod"]').click();
                }
                return true;
            },
            t: function () {
                if (!this.widget) {
                    return false;
                }
                this.date(this.getMoment());
                return true;
            },
            'delete': function () {
                if (!this.widget) {
                    return false;
                }
                this.clear();
                return true;
            }
        },
        debug: false,
        allowInputToggle: false,
        disabledTimeIntervals: false,
        disabledHours: false,
        enabledHours: false,
        viewDate: false,
        allowMultidate: false,
        multidateSeparator: ', ',
        updateOnlyThroughDateOption: false,
        promptTimeOnDateChange: false,
        promptTimeOnDateChangeTransitionDelay: 200
    };

    // ReSharper restore InconsistentNaming

    // ReSharper disable once DeclarationHides
    // ReSharper disable once InconsistentNaming
    class DateTimePicker {
        /** @namespace eData.dateOptions */
        /** @namespace moment.tz */

        constructor(element, options) {
            this._options = this._getOptions(options);
            this._element = element;
            this._dates = [];
            this._datesFormatted = [];
            this._viewDate = null;
            this.unset = true;
            this.component = false;
            this.widget = false;
            this.use24Hours = null;
            this.actualFormat = null;
            this.parseFormats = null;
            this.currentViewMode = null;
            this.MinViewModeNumber = 0;
            this.isInitFormatting = false;
            this.isInit = false;
            this.isDateUpdateThroughDateOptionFromClientCode = false;
            this.hasInitDate = false;
            this.initDate = void 0;
            this._notifyChangeEventContext = void 0;
            this._currentPromptTimeTimeout = null;

            this._int();
        }

        /**
         * @return {string}
         */
        static get NAME() {
            return NAME;
        }

        /**
         * @return {string}
         */
        static get DATA_KEY() {
            return DATA_KEY;
        }

        /**
         * @return {string}
         */
        static get EVENT_KEY() {
            return EVENT_KEY;
        }

        /**
         * @return {string}
         */
        static get DATA_API_KEY() {
            return DATA_API_KEY;
        }

        static get DatePickerModes() {
            return DatePickerModes;
        }

        static get ViewModes() {
            return ViewModes;
        }

        static get Event() {
            return Event;
        }

        static get Selector() {
            return Selector;
        }

        static get Default() {
            return Default;
        }

        static set Default(value) {
            Default = value;
        }

        static get ClassName() {
            return ClassName;
        }

        //private

        _int() {
            this.isInit = true;
            const targetInput = this._element.data('target-input');
            if (this._element.is('input')) {
                this.input = this._element;
            } else if (targetInput !== undefined) {
                if (targetInput === 'nearest') {
                    this.input = this._element.find('input');
                } else {
                    this.input = $(targetInput);
                }
            }

            this._dates = [];
            this._dates[0] = this.getMoment();
            this._viewDate = this.getMoment().clone();

            $.extend(true, this._options, this._dataToOptions());

            this.hasInitDate = false;
            this.initDate = void 0;
            this.options(this._options);

            this.isInitFormatting = true;
            this._initFormatting();
            this.isInitFormatting = false;

            if (this.input !== undefined && this.input.is('input') && this.input.val().trim().length !== 0) {
                this._setValue(this._parseInputDate(this.input.val().trim()), 0);
            } else if (this._options.defaultDate && this.input !== undefined && this.input.attr('placeholder') === undefined) {
                this._setValue(this._options.defaultDate, 0);
            }
            if (this.hasInitDate) {
                this.date(this.initDate);
            }

            if (this._options.inline) {
                this.show();
            }
            this.isInit = false;
        }

        _update() {
            if (!this.widget) {
                return;
            }
            this._fillDate();
            this._fillTime();
        }

        _setValue(targetMoment, index) {
            const noIndex = (typeof index === 'undefined'),
                isClear = !targetMoment && noIndex,
                isDateUpdateThroughDateOptionFromClientCode = this.isDateUpdateThroughDateOptionFromClientCode,
                isNotAllowedProgrammaticUpdate = !this.isInit && this._options.updateOnlyThroughDateOption && !isDateUpdateThroughDateOptionFromClientCode;
            let outpValue = '', isInvalid = false, oldDate = this.unset ? null : this._dates[index];
            if (!oldDate && !this.unset && noIndex && isClear) {
                oldDate = this._dates[this._dates.length - 1];
            }

            // case of calling setValue(null or false)
            if (!targetMoment) {
                if (isNotAllowedProgrammaticUpdate) {
                    this._notifyEvent({
                        type: DateTimePicker.Event.CHANGE,
                        date: targetMoment,
                        oldDate: oldDate,
                        isClear,
                        isInvalid,
                        isDateUpdateThroughDateOptionFromClientCode,
                        isInit: this.isInit
                    });
                    return;
                }
                if (!this._options.allowMultidate || this._dates.length === 1 || isClear) {
                    this.unset = true;
                    this._dates = [];
                    this._datesFormatted = [];
                } else {
                    outpValue = `${this._element.data('date')}${this._options.multidateSeparator}`;
                    outpValue = (oldDate && outpValue.replace(
                        `${oldDate.format(this.actualFormat)}${this._options.multidateSeparator}`, ''
                    )
                    .replace(`${this._options.multidateSeparator}${this._options.multidateSeparator}`, '')
                    .replace(new RegExp(`${escapeRegExp(this._options.multidateSeparator)}\\s*$`), '')) || '';
                    this._dates.splice(index, 1);
                    this._datesFormatted.splice(index, 1);
                }
                outpValue = trim(outpValue);
                if (this.input !== undefined) {
                    this.input.val(outpValue);
                    this.input.trigger('input');
                }
                this._element.data('date', outpValue);
                this._notifyEvent({
                    type: DateTimePicker.Event.CHANGE,
                    date: false,
                    oldDate: oldDate,
                    isClear,
                    isInvalid,
                    isDateUpdateThroughDateOptionFromClientCode,
                    isInit: this.isInit
                });
                this._update();
                return;
            }

            targetMoment = targetMoment.clone().locale(this._options.locale);

            if (this._hasTimeZone()) {
                targetMoment.tz(this._options.timeZone);
            }

            if (this._options.stepping !== 1) {
                targetMoment.minutes(Math.round(targetMoment.minutes() / this._options.stepping) * this._options.stepping).seconds(0);
            }

            if (this._isValid(targetMoment)) {
                if (isNotAllowedProgrammaticUpdate) {
                    this._notifyEvent({
                        type: DateTimePicker.Event.CHANGE,
                        date: targetMoment.clone(),
                        oldDate: oldDate,
                        isClear,
                        isInvalid,
                        isDateUpdateThroughDateOptionFromClientCode,
                        isInit: this.isInit
                    });
                    return;
                }
                this._dates[index] = targetMoment;
                this._datesFormatted[index] = targetMoment.format('YYYY-MM-DD');
                this._viewDate = targetMoment.clone();
                if (this._options.allowMultidate && this._dates.length > 1) {
                    for (let i = 0; i < this._dates.length; i++) {
                        outpValue += `${this._dates[i].format(this.actualFormat)}${this._options.multidateSeparator}`;
                    }
                    outpValue = outpValue.replace(new RegExp(`${this._options.multidateSeparator}\\s*$`), '');
                } else {
                    outpValue = this._dates[index].format(this.actualFormat);
                }
                outpValue = trim(outpValue)
                if (this.input !== undefined) {
                    this.input.val(outpValue);
                    this.input.trigger('input');
                }
                this._element.data('date', outpValue);

                this.unset = false;
                this._update();
                this._notifyEvent({
                    type: DateTimePicker.Event.CHANGE,
                    date: this._dates[index].clone(),
                    oldDate: oldDate,
                    isClear,
                    isInvalid,
                    isDateUpdateThroughDateOptionFromClientCode,
                    isInit: this.isInit
                });
            } else {
                isInvalid = true;
                if (!this._options.keepInvalid) {
                    if (this.input !== undefined) {
                        this.input.val(`${this.unset ? '' : this._dates[index].format(this.actualFormat)}`);
                        this.input.trigger('input');
                    }
                } else {
                    this._notifyEvent({
                        type: DateTimePicker.Event.CHANGE,
                        date: targetMoment,
                        oldDate: oldDate,
                        isClear,
                        isInvalid,
                        isDateUpdateThroughDateOptionFromClientCode,
                        isInit: this.isInit
                    });
                }
                this._notifyEvent({
                    type: DateTimePicker.Event.ERROR,
                    date: targetMoment,
                    oldDate: oldDate
                });
            }
        }

        _change(e) {
            const val = $(e.target).val().trim(),
                parsedDate = val ? this._parseInputDate(val) : null;
            this._setValue(parsedDate, 0);
            e.stopImmediatePropagation();
            return false;
        